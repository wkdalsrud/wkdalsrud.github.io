I"_t<h1 id="-보행자-천국">📌 보행자 천국</h1>

<blockquote>
  <p>난이도 ⭐⭐⭐</p>
</blockquote>

<h2 id="-문제">🚀 문제</h2>

<p><img src="https://user-images.githubusercontent.com/42318591/111895476-12133000-8a56-11eb-9f76-e19daed73c81.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/42318591/111895477-1b9c9800-8a56-11eb-823d-8774d7768997.png" alt="image" /></p>

<p><br /></p>

<h2 id="-내-풀이">🚀 내 풀이</h2>

<h3 id="-1-차-풀이--dp-">🔥 1 차 풀이 : DP ⭕</h3>

<blockquote>
  <p>자동차는 오른쪽, 아래쪽 이 2 가지 방향으로만 바라볼 수 있다. (자동차는 오른쪽, 아래 방향으로만 이동이 가능하다고 문제에서 주어졌기 때문이다.)</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/42318591/112012664-bb4c4a00-8b6c-11eb-8b1c-83ee6975e259.png" alt="image" /></p>

<ul>
  <li>🟥 빨간색 글씨
    <ul>
      <li>통행할 수 없는 곳이므로 오른쪽 바라볼 때 경로 수, 아래쪽 바라볼 때 경로수 모두 0 으로 설정</li>
    </ul>
  </li>
  <li>⬜ 하얀색 글씨
    <ul>
      <li>첫 행은 <u>통행 할 수 없는 곳 까지만</u> 오른쪽 바라볼 때 경로 수를 1 로 지정한다.</li>
      <li>아래 쪽 바라볼 때 경로수는 0 으로 지정한다. (위쪽은 범위를 벗어난 지역이기 때문에 위에서 올 순 없기 때문이다.)</li>
    </ul>
  </li>
  <li>🟨 노란색 글씨
    <ul>
      <li>예를 들어 (두 번째행, 네 번째 열)의 아래쪽 바라볼 때 방향의 경로수는 위쪽 지점이 자유롭게 통행할 수 있는 지점이였기 때문데 위쪽 지점의 아래쪽 바라볼 때 경로수, 오른쪽 바라볼 때 경로수를 모두 더해 결정하게 된다.</li>
      <li>이처럼 자유로운 지점으로부터 온 방향의 경로수는 노란색으로 표시함</li>
    </ul>
  </li>
  <li>🟧 주황색 글씨
    <ul>
      <li>예를 들어 (세 번째행, 다섯 번째 열)의 오른쪽 바라볼 때 방향의 경로수는 왼쪽 지점이 회전할 수 없는 지점이였기 때문데 왼쪽 지점의 오른쪽 바라볼 때 경로수만 물려받아 결정하게 된다.</li>
      <li>이처럼 회전이 불가한 지점으로부터 온 방향의 경로 수는 방향이 일치하는 경로 수만 물려받기 때문에 이를 주황색으로 표시함</li>
    </ul>
  </li>
</ul>

<hr />

<p>이처럼 지점이 <code class="language-plaintext highlighter-rouge">2</code> 인 경우! 즉, 좌회전 우회전이 금지되는 지점에선 <code class="language-plaintext highlighter-rouge">2</code>인 곳으로부터 <strong>수평 수직 방향이 일치하는 방향의 경로 수만 물려받아야하기 때문에</strong> <u>불가피하게 모든 지점이 2 가지 방향별로 경로 수를 저장하고 있어야 한다. 즉 바라보는 방향별로 경로 수를 저장해야 한다.</u> 그러므로  <code class="language-plaintext highlighter-rouge">dp</code> 테이블을 (x좌표, y좌표, 방향) 이렇게 3차원 테이블로 설정하고 (x좌표, y좌표, 방향)  별로 경로수를 저장해야 한다. 나는 3 차원 배열을 사용하진 않았고 두 가지 방향별로 저장할 <code class="language-plaintext highlighter-rouge">pair</code>를 원소로 하는 2 차원 배열을 사용했다.</p>

<ul class="notice--warning">
  <li><strong>점화식</strong>
    <ul>
      <li><strong>첫 행</strong> <u>통행 불가한 곳이 등장할 때 까지만</u> 👉<strong>dp[0][i].right = 1</strong>, 👉<strong>dp[0][i].down = 0</strong></li>
      <li><strong>첫 열</strong> 👉 <u>통행 불가한 곳이 등장할 때 까지만</u> 👉<strong>dp[0][i].right = 0</strong>, 👉<strong>dp[0][i].down = 1</strong></li>
      <li><strong>그 외</strong>
        <ul>
          <li>👉 <strong>dp[i][j].right = 왼쪽에서 오는 경로 수</strong>
            <ul>
              <li>왼쪽에서 오는 경로 수 <u>dp[i][j].right</u>
                <ul>
                  <li>왼쪽이 통행 불가한 지점이라면 : <strong>0</strong>
                    <ul>
                      <li>왼쪽에서 오는건 불가능</li>
                    </ul>
                  </li>
                  <li>왼쪽이 통행 자유로운 지점이라면 : <strong>dp[i][j - 1].down + dp[i][j - 1].right</strong>
                    <ul>
                      <li>아래를 바라보는 방향으로 올 수도 있고(좌회전) 오른쪽을 바라보는 방향에서도 올 수 있다.(직진)</li>
                    </ul>
                  </li>
                  <li>왼쪽이 좌회전 우회전 불가능한 지점이라면 : <strong>dp[i][j - 1].right</strong>
                    <ul>
                      <li>오른쪽을 바라보는 방향으로만 올 수도 있다.(직진) 좌회전이 불가하기 때문에 아래쪽을 바라보는 방향을 꺾을 수가 없기 때문이다.(수직 방향이였는데 수평 방향으로 바꾸려는 시도니까)</li>
                      <li>따라서 왼쪽 지점에선 오른쪽을 바라보는 방향의 경로 수만 물려받을 수 있다.</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>👉 <strong>dp[i][j].down = 위쪽에서 오는 경로 수</strong>
            <ul>
              <li>위쪽에서 오는 경로 수 <u>dp[i][j].down</u>
                <ul>
                  <li>위쪽이 통행 불가한 지점이라면 : <strong>0</strong>
                    <ul>
                      <li>위쪽에서 오는건 불가능</li>
                    </ul>
                  </li>
                  <li>위쪽이 통행 자유로운 지점이라면 : <strong>dp[i - 1][j].down + dp[i - 1][j].right</strong>
                    <ul>
                      <li>아래를 바라보는 방향으로 올 수도 있고(직진) 오른쪽을 바라보는 방향에서도 올 수 있다.(우회전)</li>
                    </ul>
                  </li>
                  <li>위쪽이 좌회전 우회전 불가능한 지점이라면 : <strong>dp[i - 1][j].down</strong>
                    <ul>
                      <li>아래를 바라보는 방향으로만 올 수도 있다.(직진) 우회전이 불가하기 때문에 오른쪽을 바라보는 방향에선 꺾어서 내려올 수가 없기 때문이다.(수평 방향이였는데 수직 방향으로 바꾸려는 시도니까)</li>
                      <li>따라서 위쪽 지점에선 아래를 바라보는 방향의 경로 수만 물려받을 수 있다.</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>해당 지점까지 올 수 있는 경로의 수 👉 <strong>dp[i][j].right + dp[i][j].down</strong></p>
</blockquote>

<p>두 방향까지의 경로의 수를 더하면 된다.</p>

<hr />

<p>또한 덧셈 연산으로 인하여 경로 수가 계속해서 커지기 때문에 정수 표현 범위를 벗어날 것을 우려하여 <code class="language-plaintext highlighter-rouge">20170805</code>로 나눈 나머지를 리턴하라고 문제에서 지시하고 있다. 그러니, 덧셈 연산의 결과를 꼭 <code class="language-plaintext highlighter-rouge">20170805</code>로 나눈 나머지로서 테이블에 저장하도록 하자.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">MOD</span> <span class="o">=</span> <span class="mi">20170805</span><span class="p">;</span>
<span class="cp">#define down first
#define right second
</span>
<span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">city_map</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="c1">// {아래쪽 바라볼 때 경로의 수, 오른쪽 바라볼 때 경로의 수} pair 를 원소로하는 2차원 dp 테이블</span>
    <span class="c1">// 일단 모두 {0, 0} 으로 초기화</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}));</span> 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">city_map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 통행 불가한 지점이 나오지 않을 때 까지</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">down</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 1 열의 아래쪽 바라볼 때 경로의 수는 1 로 통일</span>
    <span class="p">}</span>
        
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">city_map</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 통행 불가한 지점이 나오지 않을 때 까지</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">right</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 1 행의 오른쪽 바라볼 떄 경로의 수는 1 로 통일</span>
    <span class="p">}</span>
        
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// down 아래쪽을 바라볼 때 (= 즉, 위쪽에서 왔을 때)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">city_map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 위쪽이 자유롭게 통행할 수 있는 지점이라면 -&gt; 위쪽에서 직진도 가능, 위쪽에서 꺾어서 오는것도 가능</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">down</span> <span class="o">=</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">down</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">right</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span><span class="p">;</span> 
            <span class="k">if</span> <span class="p">(</span><span class="n">city_map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 위쪽이 통행 불가한 지점이라면 -&gt; 위쪽에서 오는건 불가능</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">down</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
            <span class="k">if</span> <span class="p">(</span><span class="n">city_map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// 위쪽이 회전이 금지된 지점이라면 -&gt; 위쪽에서 직진해서만 올 수 있음</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">down</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">down</span><span class="p">;</span>

            <span class="c1">// right 오른쪽을 바라볼 때 (= 즉, 왼쪽에서 왔을 때)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">city_map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 왼쪽이 자유롭게 통행할 수 있는 지점이라면 -&gt; 왼쪽에서 직진도 가능, 왼쪽에서 꺾어서 오는것도 가능</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">down</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">right</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">city_map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 왼쪽이 통행 불가한 지점이라면 -&gt; 왼쪽에서 오는건 불가능</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">city_map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// 왼쪽이 회전이 금지된 지점이라면 -&gt; 왼쪽에서 직진해서만 올 수 있음</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">right</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 도시가 1x1 크기라 출발지가 곧 도착지라면 답은 1 (경로가 가만히 있는 그 한 개 뿐)</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">down</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">right</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span><span class="p">;</span> <span class="c1">// 두 방향까지의 경로의 수를 더하면 그게 바로 그 지점까지 올 수 있는 모든 경로의 수</span>
    
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="-2-차-풀이--dfs-시도-시간초과">🔥 2 차 풀이 : DFS 시도 ⏰(시간초과)</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">MOD</span> <span class="o">=</span> <span class="mi">20170805</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">;</span>
<span class="cp">#define down 0
#define right 1
</span>
<span class="kt">void</span> <span class="nf">DFS</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">city_map</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">answer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 목적지에 도착할 때마다 경로수 +1</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="p">(</span><span class="n">answer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">city_map</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 현재 지점이 자유롭게 통행할 수 있는 곳이라면 -&gt; 2 가지 방향 모두 들어갈 수 있다.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="o">&amp;&amp;</span> <span class="n">city_map</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">DFS</span><span class="p">(</span><span class="n">city_map</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">down</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">city_map</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">DFS</span><span class="p">(</span><span class="n">city_map</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">city_map</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 현재 지점이 회전이 불가능한 곳이라면 -&gt; 현재 방향과 일치하는 곳으로만 들어간다.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">down</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="o">&amp;&amp;</span> <span class="n">city_map</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">DFS</span><span class="p">(</span><span class="n">city_map</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">down</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">city_map</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">DFS</span><span class="p">(</span><span class="n">city_map</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">city_map</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

    <span class="n">DFS</span><span class="p">(</span><span class="n">city_map</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">down</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p class="notice--warning"><strong>시간 초과나는 틀린 풀이입니다!</strong></p>

<p>예제 2개는 다 맞는데 실행시키면 시간 초과나는 풀이이다. 예제들은 다 맞는 것 보면 이 DFS 자체가 틀린 풀이는 아닌듯 한데 아무래도 시간을 많이 잡아먹는듯 하다.</p>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET