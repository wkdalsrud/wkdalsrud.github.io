I":d<h2 id="-플로이드-와샬-알고리즘">👩🏼 플로이드 와샬 알고리즘</h2>

<p>다익스트라 알고리즘과 같이 <u>최단 거리</u>를 구할 수 있는 알고리즘이다.</p>

<h3 id="원리">원리</h3>

<ul>
  <li><strong>다익스트라 알고리즘</strong>
    <ul>
      <li>출발지 정점을 하나 정해놓고 그곳에서부터 다른 모든 정점으로의 최단 경로를 구한다.</li>
      <li>가장 적은 비용을 하나씩 선택해나간다. (<code class="language-plaintext highlighter-rouge">우선순위 큐</code> 사용)</li>
    </ul>
  </li>
  <li><strong>플로이드 와샬 알고리즘</strong>
    <ul>
      <li><u>모든 정점에서 모든 정점으로의 최단 경로</u>를 한번에 구한다. 즉 정점과 정점, 모든 쌍의 최단 경로를 구하게 된다.
        <ul>
          <li>모든 쌍을 표현하는 <code class="language-plaintext highlighter-rouge">행렬</code>(이차원 배열)을 선언하고 <u>다이나믹 프로그래밍</u> 방식으로 각각의 원소들(각 쌍의 최단거리)을 업데이트 해나간다.
            <ul>
              <li>업데이트 기준 👉 현재 거쳐가는 정점</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><u>거쳐가는 정점</u>을 기준으로 알고리즘을 수행한다.
        <ul>
          <li>i 에서 j 로 가는데 해당 정점을 경유해서 가는 것이 더 빠르다면 그 정점을 거쳐서 가는걸로 업데이트 한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>플로이드 와샬의 시각적인 진행 과정은 <a href="https://m.blog.naver.com/PostView.nhn?blogId=ndb796&amp;logNo=221234427842&amp;proxyReferer=https:%2F%2Fwww.google.com%2F">나동빈님 블로그</a>에서 참고하기.</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">i</code>행과 <code class="language-plaintext highlighter-rouge">j</code>열의 원소인 (i, j) 원소는 정점<code class="language-plaintext highlighter-rouge">i</code>로부터 정점<code class="language-plaintext highlighter-rouge">j</code>까지의 최단 경로를 뜻한다.</li>
  <li>Dynamic Programming 방식으로 진행된다.
    <ul>
      <li><strong><em>점화식 👉 distance[i,j] = min(distance[i,j], distance[i,n] + distance[n,j])</em></strong>
        <ul>
          <li>정점 <code class="language-plaintext highlighter-rouge">i</code>에서 정점 <code class="language-plaintext highlighter-rouge">n</code>을 거쳐서 정점 <code class="language-plaintext highlighter-rouge">j</code>로 갈 때, <code class="language-plaintext highlighter-rouge">n</code>을 거쳐 가는 것이 더 최단경로일 경우 업데이트 한다.</li>
          <li>이렇게 거쳐갈 정점을 차례대로 모두 검사하여 업데이트 해나간다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>행렬 초기화
    <ul>
      <li>그래프 모양을 참고하여 초기화 한다.</li>
      <li>직접적으로 인접하여 연결되어 있지 않은 정점들의 경우 <code class="language-plaintext highlighter-rouge">INF</code> 무한대로 초기화 한다.</li>
      <li>자기 자신과 자기 자신이 연결되어 있진 않기 때문에 행렬의 대각선은 모두 0 이 된다.</li>
    </ul>
  </li>
  <li>거쳐갈 정점들을 처음부터 차례대로 검사하여 해당 정점을 거쳐 가는 것이 더 최단 경로일 경우 원소를 업데이트 한다. 매번 행렬 전체 원소들에 대해 진행!!
    <ul>
      <li>ex)
        <ul>
          <li>정점 1 을 거쳐갈 때
            <ul>
              <li>기존의 (i, j) 원소값 보다 (i, 1) + (1 + j) 값이 더 작으면 이 값으로 업데이트. 아니면 냅두기.</li>
              <li>즉 ! 정점 1 을 거쳐가는게 더 최단 경로일 경우 업데이트 하는 것이다.</li>
            </ul>
          </li>
          <li>정점 2 을 거쳐갈 때
            <ul>
              <li>기존의 (i, j) 원소값 보다 (i, 2) + (2 + j) 값이 더 작으면 이 값으로 업데이트. 아니면 냅두기.</li>
              <li>기존의 (i, j)는 정점 1 을 거쳐오는 경우도 고려해서 최단 경로를 업데이트 기존에 됐던 경우다.</li>
              <li>정점 2 을 거쳐가는게 더 최단 경로일 경우 업데이트 하고 아니라면 정점 2 거쳐가지 말고 기존 값 그대로 냅두기 !</li>
            </ul>
          </li>
          <li>이런식으로 모든 정점을 거쳐가는 경우를 쭉쭉 따져서 전체 행렬 원소들을 업데이트 해나가면 된다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="코드">코드</h3>

<blockquote>
  <p>코드 출처 <a href="https://m.blog.naver.com/PostView.nhn?blogId=ndb796&amp;logNo=221234427842&amp;proxyReferer=https:%2F%2Fwww.google.com%2F">나동빈님 블로그</a></p>
</blockquote>

<p>플로이드 와샬 알고리즘 코드는 굉장히 간단하다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">INF</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">INF</span><span class="p">,</span> <span class="mi">8</span> <span class="p">},</span>
  <span class="p">{</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">INF</span> <span class="p">},</span>
  <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="n">INF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="p">},</span>
  <span class="p">{</span> <span class="n">INF</span><span class="p">,</span> <span class="n">INF</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 시간복잡도 V^3</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>  <span class="c1">// k 는 거쳐가는 정점</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="c1">// i 는 행 (출발 정점)</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>  <span class="c1">// j 는 열 (도착 정점)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>  <span class="c1">// 점화식 distance[i,j] = min(distance[i,j], distance[i,n] + distance[n,j])</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="응용-코드">응용 코드</h4>

<blockquote>
  <p><a href="https://ansohxxn.github.io/programmers/kit38/#%ED%92%80%EC%9D%B4-2%EF%B8%8F%E2%83%A3-%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%99%80%EC%83%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">프로그래머스 ‘순위’ 문제 풀이</a></p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">results</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]][</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span> <span class="o">&amp;&amp;</span> <span class="n">graph</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
                    <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span> <span class="o">||</span> <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
                <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">answer</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/42318591/99629728-d7839180-2a7b-11eb-9af9-8804eb78305f.png" alt="image" /></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span> <span class="o">&amp;&amp;</span> <span class="n">graph</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
                    <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</code></pre></div></div>

<p>(i, j) 원소는 <code class="language-plaintext highlighter-rouge">i</code> 선수가 <code class="language-plaintext highlighter-rouge">j</code> 선수를 이길 수 있느냐에 대한 bool 값이다. <code class="language-plaintext highlighter-rouge">i</code> 선수가 <code class="language-plaintext highlighter-rouge">n</code>선수를 거쳐서도 <code class="language-plaintext highlighter-rouge">j</code> 선수를 이길 수 있는게 확실하다면 원소 값을 True로 설정한다. <u>확실하지 않다면 기존 값으로 냅둔다.</u>  즉 <strong>선수 n을 통해(경유해서) 승리를 확신할 수 있게 된 경우엔 True로 업데이트 해준다.</strong> False로 갱신되는 경우는 없음!! (경유 할 수 없으면 False로 바꿔야 하나 하고 혼란스러웠던 적이 있다.)</p>

<p><img src="https://user-images.githubusercontent.com/42318591/99629764-e66a4400-2a7b-11eb-8000-3310e4f37253.png" alt="image" /></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span> <span class="o">||</span> <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
                <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">answer</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>내가 확실히 승리할 수 있는 선수의 수와 내가 붙으면 확실히 지는 선수의 수를 합한 값이 <code class="language-plaintext highlighter-rouge">n - 1</code> 이라면 모두와의 비교가 가능하다는 뜻이니 나는 순위를 확실히 정할 수 있는 사람이므로 이때 <code class="language-plaintext highlighter-rouge">answer</code>를 1 증가시킨다. <code class="language-plaintext highlighter-rouge">graph[i][j]</code>, <code class="language-plaintext highlighter-rouge">graph[j][i]</code> 둘 중 하나라도 True 값이라면 동일한 경기에서 누구는 지고 누구는 이겼다는 뜻이니 비교 가능한 경우다.</p>

<p><br /></p>

<h2 id="️-최단-경로-찾는-알고리즘-비교-bfs-다익스트라-벨만포드-플로이드-와샬">👱‍♀️ 최단 경로 찾는 알고리즘 비교 (BFS, 다익스트라, 벨만포드, 플로이드 와샬)</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><strong>BFS</strong></th>
      <th style="text-align: center"><strong>다익스트라</strong></th>
      <th style="text-align: center"><strong>벨만포드</strong></th>
      <th style="text-align: center"><strong>플로이드 와샬</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">가중치가 있는 그래프 ❌불가능 <br /> 가중치가 모두 동일하거나 없어야 한다. 이건 DFS도 마찬가지!</td>
      <td style="text-align: center">가중치가 모두 다른 그래프 ⭕가능</td>
      <td style="text-align: center">가중치가 모두 다른 그래프 ⭕가능</td>
      <td style="text-align: center">가중치가 모두 다른 그래프 ⭕가능</td>
    </tr>
    <tr>
      <td style="text-align: center">가중치 없고 모두 동일한 중요도를 가져야 함</td>
      <td style="text-align: center">가중치가 양의 정수일 때만 가능하다.</td>
      <td style="text-align: center">가중치가 음의 정수일 때도 가능하다.</td>
      <td style="text-align: center">가중치가 음의 정수일 때도 가능하다.(단, 음의 사이클이 없어야 한다.)</td>
    </tr>
    <tr>
      <td style="text-align: center">큐 사용</td>
      <td style="text-align: center">우선순위 큐 사용</td>
      <td style="text-align: center">Dynamic Programming 방식 <br /> <strong>distance[n] = min(distance[n], distance[m] + E(m, n))</strong></td>
      <td style="text-align: center">Dynamic Programming 방식 <br /> <strong>distance[i,j] = min(distance[i,j], distance[i,n] + distance[n,j])</strong> <br />  이차원 배열(행렬) 사용</td>
    </tr>
    <tr>
      <td style="text-align: center">O(E)</td>
      <td style="text-align: center">우선순위 큐를 사용할 경우 O(ElogV) <br /> 플로이드 처럼 모든 정점-모든 정점 최단 경로를 구할 경우 O(V * ElogV)</td>
      <td style="text-align: center">O(VE)</td>
      <td style="text-align: center">3중 for문을 사용하므로 O(V^3)</td>
    </tr>
    <tr>
      <td style="text-align: center">하나의 특정 정점에서 다른 정점들까지의 최단 경로를 구함 <code class="language-plaintext highlighter-rouge">1:N</code></td>
      <td style="text-align: center">하나의 특정 정점에서 다른 정점들까지의 최단 경로를 구함 <code class="language-plaintext highlighter-rouge">1:N</code></td>
      <td style="text-align: center">하나의 특정 정점에서 다른 정점들까지의 최단 경로를 구함 <code class="language-plaintext highlighter-rouge">1:N</code></td>
      <td style="text-align: center"><u>모든 정점들간의 쌍에 대해 최단 경로를 한번에 구함</u> <br /> 즉 모든 정점들간의 최단 경로를 모두 구한다.<code class="language-plaintext highlighter-rouge">N:M</code></td>
    </tr>
  </tbody>
</table>

<ul>
  <li>다익스트라 시간복잡도 설명
    <ul>
      <li>👉 O(VlogV + ElogV) = O((V + E)logV) = O(ElogV)</li>
      <li>V * logV
        <ul>
          <li>모든 정점마다 한번씩 방문하게 됨 <code class="language-plaintext highlighter-rouge">V</code></li>
          <li>루트를 pop 하고 다시 힙정렬하는 과정이 <code class="language-plaintext highlighter-rouge">logV</code></li>
        </ul>
      </li>
      <li>E * logV
        <ul>
          <li>이웃 정점을 예약하는건 곧 간선을 검사하는 것과 같다. <code class="language-plaintext highlighter-rouge">E</code></li>
          <li>이웃 정점 push 하고 다시 힙정렬하는 과정이 <code class="language-plaintext highlighter-rouge">logV</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET