I"<p class="notice--warning">인프런에 있는 Rookiss님의 강의 <strong>Part2: 자료구조와 알고리즘</strong> 를 듣고 정리한 필기입니다. 😀</p>

<h2 id="-big-o-표기법">🔔 Big-O 표기법</h2>

<h3 id="사용하는-이유">사용하는 이유</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Big-O 표기법</code>
    <ul>
      <li>알고리즘의 <u>성능을 객관적으로 측정</u>하기 위하여 사용.
        <ul>
          <li><em>단순히 실행 속도를 비교</em>하는 것으로 알고리즘 성능을 측정하는건 컴퓨터 실행 환경에 따라 차이가 있기 때문에 별로 좋지 못하다.</li>
          <li>입력이 적은 구간과 많은 구간에서 성능이 확연히 차이가 나는 경우도 있을 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="표기법">표기법</h3>

<h4 id="1단계--수행-연산의-개수를-대략적으로-판단">1단계 : 수행 연산의 개수를 대략적으로 판단</h4>

<blockquote>
  <p>수행되는 연산의 개수를 대략적으로 판단한다.</p>
</blockquote>

<ul>
  <li>어떤 연산이 1 개만 있다면 <code class="language-plaintext highlighter-rouge">1 개</code></li>
  <li>어떤 연산이 N 번 도는 for문 안에 있다면 <code class="language-plaintext highlighter-rouge">N 개</code></li>
  <li>어떤 연산이 N 번 도는 이중 for문 안에 있다면 <code class="language-plaintext highlighter-rouge">N^2 개</code></li>
</ul>

<h4 id="2단계--대장만-남긴다">2단계 : 대장만 남긴다.</h4>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">int</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>   <span class="c1">//  1 번</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>  <span class="c1">// N 번</span>
        <span class="n">sum</span> <span class="p">+=</span> <span class="n">i</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">2</span> <span class="p">*</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>  <span class="c1">// 4 * N^2 번 ⭐⭐ 얘가 가장 영향력이 크다. N^2니까.</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="p">&lt;</span> <span class="m">2</span> <span class="p">*</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="p">++)</span> 
          <span class="n">sum</span> <span class="p">+=</span> <span class="m">5</span><span class="p">;</span>
    
    <span class="n">sum</span> <span class="p">+=</span> <span class="m">1234567</span><span class="p">;</span>   <span class="c1">// 1 번</span>

    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>영향력이 가장 큰 대표적인 연산만 남긴다.
    <ul>
      <li>O(1 + N + 4 * \(N^2\) + 1) = O(4 * \(N^2\))</li>
      <li>가장 영향력이 큰 4 * \(N^2\) 번 연산만 남긴다.</li>
    </ul>
  </li>
  <li>상수는 무시한다.
    <ul>
      <li>O(4 * \(N^2\)) = O(\(N^2\))</li>
      <li>위 코드의 성능은 최종적으로 O(\(N^2\)) 라고 할 수 있다.
        <ul>
          <li><em>cf) O는 Order Of라고 읽는다.</em></li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>거시적인 관점에서 보면, N 이 무한으로 커지면 커질 수록 N 과 \(N^2\)의 차이는 매우 커지게 된다. 따라서 대표적인 연산만 남기고 더 작은 연산들은 무시하는 것.</p>
</blockquote>

<ul>
  <li>이차함수가 일차함수보다 같은 N 이라도 이차 함수가 증가폭이 훨씬 더 크니까..!</li>
</ul>

<p><br /></p>

<h3 id="크기-순서">크기 순서</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">N</code>은 데이터(입력)의 크기가 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">O(1)</code> &lt; <code class="language-plaintext highlighter-rouge">O(logN)</code> &lt; <code class="language-plaintext highlighter-rouge">O(N)</code> &lt; <code class="language-plaintext highlighter-rouge">O(NlogN)</code> &lt; <code class="language-plaintext highlighter-rouge">O(N^2)</code> &lt; <code class="language-plaintext highlighter-rouge">O(2^N)</code> &lt; <code class="language-plaintext highlighter-rouge">O(N!)</code>
    <ul>
      <li>👉 작을 수록 연산이 적게 걸린다는 것이니 가장 좋은 알고리즘이라는 뜻!</li>
      <li><code class="language-plaintext highlighter-rouge">O(N)</code>까지는 보통 무리가 없다고 얘기한다.</li>
    </ul>
  </li>
</ul>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET