I"h~<h1 id="그리디-섬-연결하기">[그리디] 섬 연결하기</h1>

<blockquote>
  <p>난이도 ⭐⭐⭐</p>
</blockquote>

<h2 id="문제">문제</h2>

<p><img src="https://user-images.githubusercontent.com/42318591/96554053-f9f58400-12f0-11eb-94f2-99345c882abb.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/42318591/96554087-02e65580-12f1-11eb-880c-ce3dcc267f24.png" alt="image" /></p>

<p><br /></p>

<h2 id="내-풀이-">내 풀이 ❌</h2>

<blockquote>
  <p><u>이 문제는 틀린 풀이 입니다! 참고하지 마세요!ㅠㅠㅠ</u> 틀린 풀이이긴 하지만 나중에 다시 풀기위해 기록하는 차원에서 정리한 것입니다.</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/42318591/96684966-6c309c00-13b7-11eb-9145-3f9e6e31330e.png" alt="image" /></p>

<p>이 풀이는 테스트 케이스 7번만 틀린다. 온갖 테스트 케이스 12개 가량을 추가하여 다 테스트 해봤지만 다 통과되었고 오직 프로그래머스에서 제공하는 테스트 케이스 7번만 틀렸다.. 테스트 케이스 7 번이 뭔지 알 길이 없으니 이틀 동안 계속 고민해 보았지만 그 반례를 찾지 못했다. 그래도 이 문제의 대표 풀이법이라고 하는 크루스칼 알고리즘과 얼추 비슷한 방법으로 풀었으니 그것으로 만족하고 포기해야겠다.. 흑흑… 더 이상 붙들고 있을 수는 없다. 😭 <strong><u>혹시 우연히 제 블로그에 방문하셔서 이 풀이의 반례를 찾아주신 분이 계시다면 ㅠㅠㅠ 댓글 간곡히 부탁드립니다ㅠㅠㅠ!!!!!!!!!</u></strong> 이 풀이의 문제점이 도대체 뭘지 너무 궁금하다… 나중에 한번 다시 풀어 봐야겠다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">compare</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">costs</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">island</span><span class="p">;</span>

	<span class="n">sort</span><span class="p">(</span><span class="n">costs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">costs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">compare</span><span class="p">);</span>

	<span class="n">island</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">});</span>
	<span class="n">island</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">});</span>
	<span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">group</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">costs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">island</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">island</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">island</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

    <span class="kt">bool</span> <span class="n">vertex1Exists</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="kt">bool</span> <span class="n">vertex2Exists</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">group1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">group2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">island</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">island</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
			<span class="p">{</span>
				<span class="n">vertex1Exists</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">group1</span> <span class="o">=</span> <span class="n">island</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">island</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
			<span class="p">{</span>
				<span class="n">vertex2Exists</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">group2</span> <span class="o">=</span> <span class="n">island</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vertex1Exists</span> <span class="o">&amp;&amp;</span> <span class="n">vertex2Exists</span> <span class="o">&amp;&amp;</span> <span class="n">group1</span> <span class="o">==</span> <span class="n">group2</span><span class="p">)</span> <span class="c1">// 둘 다 이미 있는데 같은 그룹 - 사이클을 형성하므로 X</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vertex1Exists</span> <span class="o">&amp;&amp;</span> <span class="n">vertex2Exists</span> <span class="o">&amp;&amp;</span> <span class="n">group1</span> <span class="o">!=</span> <span class="n">group2</span><span class="p">)</span> <span class="c1">// 둘 다 이미 있는데 다른 그룹 - union 한 그룹으로 합쳐야 함</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">minGroup</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">group1</span><span class="p">,</span> <span class="n">group2</span><span class="p">);</span>
			<span class="kt">int</span> <span class="n">maxGroup</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">group1</span><span class="p">,</span> <span class="n">group2</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">island</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">island</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">maxGroup</span><span class="p">)</span>
					<span class="n">island</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">minGroup</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">group</span><span class="o">--</span><span class="p">;</span>
			<span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vertex1Exists</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vertex2Exists</span><span class="p">)</span>  <span class="c1">// 둘 다 없음 (새로운 그룹)</span>
		<span class="p">{</span>
			<span class="n">group</span><span class="o">++</span><span class="p">;</span>
			<span class="n">island</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">group</span><span class="p">});</span>
			<span class="n">island</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">group</span><span class="p">});</span>
			<span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vertex1Exists</span><span class="p">)</span>  <span class="c1">// 두 번째 정점을 첫 번째 정점이 속한 그룹에 추가</span>
		<span class="p">{</span>
			<span class="n">island</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">group1</span><span class="p">});</span>
			<span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vertex2Exists</span><span class="p">)</span> <span class="c1">// 첫 번째 정점을 두 번째 정점이 속한 그룹에 추가</span>
		<span class="p">{</span>
			<span class="n">island</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">group2</span><span class="p">});</span>
			<span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>이 문제의 포인트</p>
</blockquote>

<ul>
  <li>최소 비용으로 짓되 모든 섬을 통핼할 수 있어야 한다.</li>
  <li>단 사이클이 있어선 안된다.
    <ul>
      <li>👉 즉, 다리를 여러번 건너더라도 건너 건너 도달할 수만 있으면 통행 가능하다고 보기 때문에.</li>
      <li>최소한의 비용만으로 다리를 최소한으로 놓으면서 모든 섬이 통행 가능하게만 하면 되기 때문에 사이클이 있어선 안된다.</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">compare</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">sort</span><span class="p">(</span><span class="n">costs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">costs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">compare</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">costs</code> 원소(vector)들의 <code class="language-plaintext highlighter-rouge">2</code>인덱스엔 다리를 짓는 비용이 들어있다. 다리를 짓는 비용에 따라 <code class="language-plaintext highlighter-rouge">costs</code>를 오름차순 정렬한다. <strong>최소 비용이 드는 다리를 우선적인 후보로 선택해야 하기 때문이다.</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">island</span><span class="p">;</span>  <span class="c1">// 다리가 연결된 섬들의 모음</span>

	<span class="n">island</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">});</span>
	<span class="n">island</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">});</span>
	<span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">group</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">island</code> : 현재 직접적인 다리가 놓아진 섬들의 모임
    <ul>
      <li>각 원소들은 섬.
        <ul>
          <li>원소[0] 은 그 자체로 섬 (Vertex 번호)</li>
          <li>원소[1] 은 <strong>해당 섬이 현재 속한 그룹</strong>
            <ul>
              <li>설명 예시
                <ul>
                  <li>[1, 4] 섬끼리 연결되어 있고 [2, 10, 19] 섬끼리 연결 되있는 상태라면, [1, 4]를 그룹 2 / [2, 10, 19]를 그룹 5 라고 하자. 두 그룹은 서로 통행할 수 없다.
                    <ul>
                      <li>1 과 4 는 통행 가능하고 2 와 19도 통행 가능하지만 1 과 2 는 통행 불가.</li>
                    </ul>
                  </li>
                  <li>4 섬과 10 섬을 연결하는 다리가 나왔을 때 두 그룹을 이제 합쳐주어야 한다. 두 그룹이 서로 통행이 가능해졌으니까!</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>정렬을 끝낸 <code class="language-plaintext highlighter-rouge">costs</code>의 첫번째 원소는 가장 최소 비용으로 드는 다리의 비용이다. 따라서 이 다리는 무조건 선택하므로 일단 이 다리가 연결하는 2 개의 섬을 <code class="language-plaintext highlighter-rouge">island</code>에 추가해준다.
    <ul>
      <li>두 섬이 속한 그룹을 일단 <code class="language-plaintext highlighter-rouge">1</code>로</li>
      <li><code class="language-plaintext highlighter-rouge">answer</code>에 비용 누적합</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">group</code> : 현재 그룹 갯수. 다리 딱 하나를 둔 상태니까 현재 그룹은 1 개다. 초기값 1.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">costs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">costs</code> 비용 순대로 오름 차순 정렬된 다리 비용들을 살펴보며 놓을 수 있는 다리인지 없는 다리인지를 차례 차례 따질 것이다. 최소 비용 다리는 미리 놨으니 <code class="language-plaintext highlighter-rouge">i = 1</code>부터 시작.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">if</span> <span class="p">(</span><span class="n">island</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">island</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">island</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>종료 조건
    <ul>
      <li><code class="language-plaintext highlighter-rouge">island</code>에 현재 모든 섬이 들어가 있고
        <ul>
          <li>모든 섬이 다리가 놓아진 상태</li>
          <li>하지만 이것 만으로는 종료조건이 되지 않는다. 모든 섬에 다리가 놓아 졌더라도 그룹이 여러개면 단절되는 섬이 있다는 얘기니까</li>
        </ul>
      </li>
      <li>모든 섬이 속한 그룹이 전부 다 <code class="language-plaintext highlighter-rouge">1</code>이어야 함.
        <ul>
          <li>즉 모든 섬이 다 통행이 가능하게 하나의 그룹으로서 연결 되어 있는 상태면 더 이상 다리를 놓아지 않아도 되므로 종료.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="kt">bool</span> <span class="n">vertex1Exists</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="kt">bool</span> <span class="n">vertex2Exists</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">group1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">group2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">island</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">island</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
			<span class="p">{</span>
				<span class="n">vertex1Exists</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">group1</span> <span class="o">=</span> <span class="n">island</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">island</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
			<span class="p">{</span>
				<span class="n">vertex2Exists</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">group2</span> <span class="o">=</span> <span class="n">island</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
			<span class="p">}</span>
		<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>상태 변수. for문 지역 변수이므로 매번 다리 <code class="language-plaintext highlighter-rouge">costs[i]</code> 마다 새롭게 선언 됨.
    <ul>
      <li>해당 다리 <code class="language-plaintext highlighter-rouge">costs[i]</code>가 이을 수 있는 두 섬 중, <code class="language-plaintext highlighter-rouge">costs[i][0]</code>을 첫 번째 섬이라고 하고, 이게 기존에 다리를 한번 놓은적이 있어서 <code class="language-plaintext highlighter-rouge">island</code>에 이미 속해 있다면 <code class="language-plaintext highlighter-rouge">vertex1Exists</code>를 True 로 설정할 것이다. 아직까진 다리가 놓아진적이 없는 섬이라면 False.</li>
      <li>해당 다리 <code class="language-plaintext highlighter-rouge">costs[i]</code>가 이을 수 있는 두 섬 중, <code class="language-plaintext highlighter-rouge">costs[i][1]</code>을 두 번째 섬이라 하고 마찬가지로 기존에 다리가 놓아져 이미 연결되어 있다면 <code class="language-plaintext highlighter-rouge">vertex2Exists</code>는 True가 되도록 할 것이다.</li>
      <li><code class="language-plaintext highlighter-rouge">group1</code> 👉 해당 다리 <code class="language-plaintext highlighter-rouge">costs[i]</code>가 이을 수 있는 두 섬 중, 첫 번째 섬이 속한 그룹.
        <ul>
          <li>기존에 다리를 한번 놓은적이 있어서 <code class="language-plaintext highlighter-rouge">island</code>에 이미 속해 있는 섬이라면 해당 섬이 현재 속해있는 그룹이 기록 될 것</li>
          <li>아직까지 다리가 놓아진적이 없는 섬이라면 초기값인 <code class="language-plaintext highlighter-rouge">-1</code>로 남을 것.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">group2</code> 👉 해당 다리 <code class="language-plaintext highlighter-rouge">costs[i]</code>가 이을 수 있는 두 섬 중, 두 번째 섬이 속한 그룹.</li>
    </ul>
  </li>
  <li>for문 돌면서 <code class="language-plaintext highlighter-rouge">island</code>에 있는지, 즉 기존에 다리가 놓아진적이 있는 섬인지 검사하고 업뎃한다.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">if</span> <span class="p">(</span><span class="n">vertex1Exists</span> <span class="o">&amp;&amp;</span> <span class="n">vertex2Exists</span> <span class="o">&amp;&amp;</span> <span class="n">group1</span> <span class="o">==</span> <span class="n">group2</span><span class="p">)</span> <span class="c1">// 둘 다 이미 있는데 같은 그룹 - 사이클을 형성하므로 X</span>
			<span class="k">continue</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>1️⃣ 해당 다리 <code class="language-plaintext highlighter-rouge">costs[i]</code>가 이을 수 있는 두 섬이 다 다리가 놓아진적이 있고 And 같은 그룹이라면
    <ul>
      <li>같은 그룹의 섬이라는 것은 건너 건너 연결이 되어 있는 섬이므로 여기서 또 연결해버리면 사이클이 생긴다.</li>
      <li>따라서 이 같은 경우엔 다리를 놓지 않는다.</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">if</span> <span class="p">(</span><span class="n">vertex1Exists</span> <span class="o">&amp;&amp;</span> <span class="n">vertex2Exists</span> <span class="o">&amp;&amp;</span> <span class="n">group1</span> <span class="o">!=</span> <span class="n">group2</span><span class="p">)</span> <span class="c1">// 둘 다 이미 있는데 다른 그룹 - union 한 그룹으로 합쳐야 함</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">minGroup</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">group1</span><span class="p">,</span> <span class="n">group2</span><span class="p">);</span>
			<span class="kt">int</span> <span class="n">maxGroup</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">group1</span><span class="p">,</span> <span class="n">group2</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">island</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">island</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">maxGroup</span><span class="p">)</span>
					<span class="n">island</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">minGroup</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">group</span><span class="o">--</span><span class="p">;</span>
			<span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>2️⃣ 해당 다리 <code class="language-plaintext highlighter-rouge">costs[i]</code>가 이을 수 있는 두 섬이 다 다리가 놓아진적이 있지만 서로 다른 그룹이라면
    <ul>
      <li>이제 두 그룹을 한 그룹으로 합쳐주어야 한다. 이 <code class="language-plaintext highlighter-rouge">costs[i]</code> 다리로 인하여 서로 통행이 가능 해 질테니까.</li>
      <li>종료 조건을 모든 섬의 그룹이 <code class="language-plaintext highlighter-rouge">1</code>로 통일될 때로 할 것이기 때문에 큰 수의 그룹을 작은 수의 그룹으로 바꿔 주어 두 그룹을 합쳤다.</li>
      <li>그룹의 수는 1 줄어드니 <code class="language-plaintext highlighter-rouge">group--</code></li>
      <li>다리를 이었으므로 <code class="language-plaintext highlighter-rouge">answer += costs[i][2]</code></li>
      <li><code class="language-plaintext highlighter-rouge">island</code>에 추가해줄 필요는 없다. 이미 두 섬 다 <code class="language-plaintext highlighter-rouge">islad</code>에 있으니까.</li>
      <li>예를 들어
        <ul>
          <li>[1,4,5] 가 그룹 3 이고, [2, 8] 이 그룹 7 일 때, [1, 2] 다리를 잇게 되어 두 그룹이 합쳐진다면 [2, 8] 그룹을 7 에서 3 으로 변경한다. <code class="language-plaintext highlighter-rouge">group</code>또한 7 에서 6 으로 변경될 것이다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vertex1Exists</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">vertex2Exists</span><span class="p">)</span>  <span class="c1">// 둘 다 없음 (새로운 그룹)</span>
		<span class="p">{</span>
			<span class="n">group</span><span class="o">++</span><span class="p">;</span>
			<span class="n">island</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">group</span><span class="p">});</span>
			<span class="n">island</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">group</span><span class="p">});</span>
			<span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>3️⃣ 해당 다리 <code class="language-plaintext highlighter-rouge">costs[i]</code>가 이을 수 있는 두 섬이 모두 이전에 한번도 다리가 놓아진 적이 없다면
    <ul>
      <li>이 두 섬을 새로운 그룹으로서 <code class="language-plaintext highlighter-rouge">island</code>에 추가해야 한다.
        <ul>
          <li>그룹이 늘어났으니 <code class="language-plaintext highlighter-rouge">group++</code></li>
          <li>두 섬을 <code class="language-plaintext highlighter-rouge">island</code>에 추가하 되, 그룹은 방금 증가시킨 <code class="language-plaintext highlighter-rouge">group</code>으로 한다.
            <ul>
              <li>현재 그룹이 3 개라면, 이제 그룹 4 개가 되므로 4 로 설정하여 넣어준다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">if</span> <span class="p">(</span><span class="n">vertex1Exists</span><span class="p">)</span>  <span class="c1">// 두 번째 정점을 첫 번째 정점이 속한 그룹에 추가</span>
		<span class="p">{</span>
			<span class="n">island</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">group1</span><span class="p">});</span>
			<span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>4️⃣ 해당 다리 <code class="language-plaintext highlighter-rouge">costs[i]</code>가 이을 수 있는 두 섬 中 첫 번째 섬이 이미 다리가 놓아진 섬이라면
    <ul>
      <li>이제 다리가 놓아지면 첫 번째 섬이 속한 그룹에 속할 수 있으므로, 두 번째 섬만 추가하고 그룹은 첫 번째 섬이 속한 그룹으로.</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">if</span> <span class="p">(</span><span class="n">vertex2Exists</span><span class="p">)</span> <span class="c1">// 첫 번째 정점을 두 번째 정점이 속한 그룹에 추가</span>
		<span class="p">{</span>
			<span class="n">island</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">group2</span><span class="p">});</span>
			<span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>5️⃣ 해당 다리 <code class="language-plaintext highlighter-rouge">costs[i]</code>가 이을 수 있는 두 섬 中 두 번째 섬이 이미 다리가 놓아진 섬이라면
    <ul>
      <li>이제 다리가 놓아지면 두 번째 섬이 속한 그룹에 속할 수 있으므로, 첫 번째 섬만 추가하고 그룹은 두 번째 섬이 속한 그룹으로.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="정답-풀이">정답 풀이</h2>

<h3 id="1️⃣">1️⃣</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">compare</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">costs</span><span class="p">)</span> <span class="p">{</span>	

	  <span class="n">sort</span><span class="p">(</span><span class="n">costs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">costs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">compare</span><span class="p">);</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">usedBridge</span><span class="p">(</span><span class="n">costs</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visitedIsland</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">numOfVisitedIsland</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="n">usedBridge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">numOfVisitedIsland</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
    
    <span class="k">while</span><span class="p">(</span><span class="n">numOfVisitedIsland</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">costs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&amp;&amp;</span> <span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">continue</span><span class="p">;</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">usedBridge</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">continue</span><span class="p">;</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">||</span> <span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
            <span class="p">{</span>
                <span class="n">usedBridge</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">numOfVisitedIsland</span><span class="o">++</span><span class="p">;</span>
                <span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>          
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

	<span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">costs</code>를 비용 순으로 오름차순 정렬해놓는것은 같다. 이 방법은 다리 연결한 정점이 <code class="language-plaintext highlighter-rouge">n</code>개에 도달했는지를 검사하는 큰 while 반복문과, 차례대로 놓아도 되는 다리를 검사하기 위해 <code class="language-plaintext highlighter-rouge">costs</code>를 두 번째 for 반복문 이렇게 이중 for문을 사용한다. 즉, 섬 하나 연결할 때마다 새롭게 for문을 돌려 처음부터 <code class="language-plaintext highlighter-rouge">costs</code>를 검사한다.</p>

<ul>
  <li>이 문제의 포인트
    <ul>
      <li>오직 현재까지 만들어진 기준에서의 <code class="language-plaintext highlighter-rouge">MST</code>에 연결되어 있는 간선을 선택한다.
        <ul>
          <li>이전 풀이와 다르게, 새로운 트리를 두지 않고 동일한 트리를 확장해가는 식</li>
          <li>따라서 매번 새롭게 <code class="language-plaintext highlighter-rouge">costs</code>를 처음부터 검사한다.
            <ul>
              <li>그러기 위해 이미 연결 완료된 다리를 체크해서 중복 검사하지 않도록 한다.
                <ul>
                  <li><code class="language-plaintext highlighter-rouge">unBridge</code></li>
                </ul>
              </li>
              <li>이미 방문 완료 하여 <code class="language-plaintext highlighter-rouge">MST</code>에 포함되어 있는 섬도 체크 해주어야 한다.
                <ul>
                  <li><code class="language-plaintext highlighter-rouge">visitedIsland</code></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">usedBridge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">numOfVisitedIsland</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">costs[0]</code>은 무조건 선택하기 때문에 미리 체크.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">costs[0]</code> 다리 <code class="language-plaintext highlighter-rouge">usedBridge[0]</code> 체크</li>
  <li><code class="language-plaintext highlighter-rouge">costs[0]</code>가 잇는 두 섬 방문 체크 <code class="language-plaintext highlighter-rouge">visitedIsland[costs[0][0]]</code>, <code class="language-plaintext highlighter-rouge">visitedIsland[costs[0][1]]</code></li>
  <li><code class="language-plaintext highlighter-rouge">costs[0]</code> 비용 <code class="language-plaintext highlighter-rouge">answer</code>에 합</li>
  <li><code class="language-plaintext highlighter-rouge">numOfVisitedIsland</code> 방문한 두 섬 카운트</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">while</span><span class="p">(</span><span class="n">numOfVisitedIsland</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">costs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
</code></pre></div></div>

<p>다리 연결한 정점이 <code class="language-plaintext highlighter-rouge">n</code>개에 도달했는지를 검사하는 큰 while 반복문과, 차례대로 놓아도 되는 다리를 검사하기 위해 <code class="language-plaintext highlighter-rouge">costs</code>를 두 번째 for 반복문 이렇게 이중 for문을 사용한다. 즉, 섬 하나 연결할 때마다 새롭게 for문을 돌려 처음부터 <code class="language-plaintext highlighter-rouge">costs</code>를 검사한다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">while</span><span class="p">(</span><span class="n">numOfVisitedIsland</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">costs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&amp;&amp;</span> <span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">continue</span><span class="p">;</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">usedBridge</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">continue</span><span class="p">;</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">||</span> <span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
            <span class="p">{</span>
                <span class="n">usedBridge</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">visitedIsland</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">numOfVisitedIsland</span><span class="o">++</span><span class="p">;</span>
                <span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>          
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>해당 다리가 잇는 두 섬이 이미 방문 되었으면 무시하고 지나가고, 이미 연결 완료된 다리라면 무시하고 지나간다.</li>
  <li>방문 체크, 비용 합산
    <ul>
      <li>그리고 해당 반복문을 빠져나온다.</li>
      <li>다시 새롭게 <code class="language-plaintext highlighter-rouge">costs</code>를 처음부터 검사한다. <code class="language-plaintext highlighter-rouge">numOfVisitedIsland</code>가 <code class="language-plaintext highlighter-rouge">n</code>에 도달할 때 까지.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="2️⃣-mst-만들기---크루스칼-알고리즘-사용">2️⃣ MST 만들기 - 크루스칼 알고리즘 사용</h3>

<blockquote>
  <p><strong>간선</strong>을 선택해나감.</p>
</blockquote>

<p>✨ <u>무조건 가장 비용이 작은 간선부터 선택</u>해 나간다는 점에서 <code class="language-plaintext highlighter-rouge">Greedy</code>한 알고리즘이다. 단, 선택한 간선의 <u>두 정점이 연결되 있지 않는 경우에만 해당 간선을 선택한다. 즉, 사이클을 이루지 않도록.</u></p>

<p><code class="language-plaintext highlighter-rouge">MST</code> 집합은 공백에서 시작한다.</p>

<ol>
  <li>가중치 순서대로 간선들을 오름차순 정렬한다.</li>
  <li>오름 차순 정렬된 간선들을 차례대로 살펴보며 <u>두 정점이 아직 연결되 있지 않는, 즉 사이클을 형성하지 않는</u> 간선이면 선택한다. 형성한다면 그 간선은 무시하고 다음 차례로 넘어 간다.
    <ul>
      <li>정점들의 부모가 같다면(즉, 같은 그룹이라 서로 통행이 가능하다면) 사이클이 형성되는 것이고, 부모가 같지 않다면(즉, 서로 통행이 불가능 하다면) 사이클이 형성되지 않는것이다.</li>
      <li>Kruskal 알고리즘이 Union-Find 알고리즘과도 연관이 있는 이유.</li>
    </ul>
  </li>
  <li>선택한 간선을 <code class="language-plaintext highlighter-rouge">MST</code> 집합에 Union 시킨다.
    <ul>
      <li>2~3 과정을 선택한 간선의 수가 <code class="language-plaintext highlighter-rouge">n-1</code>개가 될 때까지 반복한다.</li>
    </ul>
  </li>
</ol>

<p>적은 숫자의 간선을 가지는 그래프라면 크루스칼 알고리즘으로 <code class="language-plaintext highlighter-rouge">MST</code>를 만드는게 적합하다. 크루스칼 알고리즘은 간선을 정렬하는 시간에 좌우되기 때문이다.</p>

<p><img src="https://user-images.githubusercontent.com/42318591/96864077-d5410e00-14a2-11eb-8abe-62adabc3d43e.png" alt="image" /></p>

<p>정점 <code class="language-plaintext highlighter-rouge">2</code>와 <code class="language-plaintext highlighter-rouge">0</code>은 현재 통행이 가능하도록 연결 되어 있는 같은 그룹이다.(트리 개념으로 치면 부모 정점이 같은 셈이다.) 그런 상태에서 <code class="language-plaintext highlighter-rouge">0 - 2</code> 간선을 추가하려고 하면 사이클이 발생하므로 선택하지 않는다.</p>

<p>✨<u>모든 정점의 부모 정점이 같아진다면, 즉 모든 정점이 하나의 그룹에 속하면서 통행이 가능해진다면! 즉, 하나의 트리로 합쳐져 완성된다면!</u> 작업을 종료한다.</p>

<blockquote>
  <p>크루스칼 알고리즘 코드 참고 나동빈님 블로그 <a href="https://blog.naver.com/ndb796/221230994142">https://blog.naver.com/ndb796/221230994142</a></p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">getRoot</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span>  <span class="c1">// 인수로 넘긴 정점의 부모 정점을 알려줌</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">getRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unionParent</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>  <span class="c1">// 두 정점을 병합함. 부모가 같은, 같은 그룹으로.</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">par_a</span> <span class="o">=</span> <span class="n">getRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">par_b</span> <span class="o">=</span> <span class="n">getRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">par_a</span> <span class="o">&lt;</span> <span class="n">par_b</span><span class="p">)</span> <span class="n">parent</span><span class="p">[</span><span class="n">par_b</span><span class="p">]</span> <span class="o">=</span> <span class="n">par_a</span><span class="p">;</span>
    <span class="k">else</span> <span class="n">parent</span><span class="p">[</span><span class="n">par_a</span><span class="p">]</span> <span class="o">=</span> <span class="n">par_b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">find</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>  <span class="c1">// 두 정점이 같은 부모를 가졌는지 확인</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">par_a</span> <span class="o">=</span> <span class="n">getRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">par_b</span> <span class="o">=</span> <span class="n">getRoot</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">par_a</span> <span class="o">==</span> <span class="n">par_b</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">compare</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">costs</span><span class="p">)</span> <span class="p">{</span>	
    <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
	<span class="n">sort</span><span class="p">(</span><span class="n">costs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">costs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">compare</span><span class="p">);</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parents</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">parents</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">parents</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">costs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">find</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
        <span class="p">{</span>
            <span class="n">unionParent</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
            <span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

	<span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">parents</code>에서 각 인덱스는 정점을 뜻하며 원소는 해당 정점의 부모 정점을 가리킨다. 정점이 4 개라면 초기값은 [0, 1, 2, 3]으로 자기 자신이 부모다. 최종적으로 [0, 0, 0, 0]이 되어 모든 정점의 부모 정점이 같아진다면, 즉 하나의 트리로 완성되었다면 종료한다. 0 과 2 정점이 이어진다면 [0, 1, 0, 3]이 될 것이도 1 과 3 이 이어진다면 [0, 1, 0, 1]이 될 것이고 1 과 0 이 이어진다면 최종적으로 [0, 0, 0, 0]이 될 것이다.</p>

<ol>
  <li><em>int getRoot(vector&lt;int&gt;&amp; parent, int x)</em>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">x</code> 정점의 부모 정점을 리턴한다.</li>
    </ul>
  </li>
  <li><em>void unionParent(vector&lt;int&gt;&amp; parent, int a, int b)</em>
    <ul>
      <li>두 정점 <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>를 같은 부모를 가진 하나의 트리로 병합한다.</li>
      <li>더 작은 값의 부모로 통합한다.</li>
    </ul>
  </li>
  <li><em>bool find(vector&lt;int&gt;&amp; parent, int a, int b)</em>
    <ul>
      <li>두 정점 <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>가 같은 부모를 가졌는지를 확인한다.</li>
      <li>True 라면 또 똑같은 <code class="language-plaintext highlighter-rouge">a - b</code>를 잇는 간선을 추가한다면 사이클이 형성되므로 해당 간선은 선택하면 안된다.</li>
    </ul>
  </li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sort</span><span class="p">(</span><span class="n">costs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">costs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">compare</span><span class="p">);</span>
</code></pre></div></div>

<p>비용순서대로 가장 최소비용을 가진 간선이 앞에 오게 오름차순 정렬.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parents</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">parents</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">parents</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">parents</code>의 초기화는 자기 자신이 부모이게끔.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">costs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">find</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
        <span class="p">{</span>
            <span class="n">unionParent</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
            <span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>부모가 같지 않을 때만 (같다면 이 두 정점을 추가하면 사이클이 형성되게 되므로 추가하면 안된다.)
    <ul>
      <li>두 정점을 합치기
        <ul>
          <li>기존에 이미 다른 트리에 속해 있다면 이제 그 트리와 합쳐질 것이고</li>
          <li>그런적 없었다면 자기 자신이 부모인 지금 상태에서 해당 트리로 연결될 것이다.</li>
        </ul>
      </li>
      <li>비용 더해주기</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="3️⃣-mst-만들기---프림-알고리즘-사용">3️⃣ MST 만들기 - 프림 알고리즘 사용</h3>

<blockquote>
  <p>시작 정점에서 출발하여 <strong>정점</strong>을 선택해나감.</p>
</blockquote>

<p>✨ 프림 또한 <code class="language-plaintext highlighter-rouge">Greedy</code>하다. 시작 할 때 시작 정점만 <code class="language-plaintext highlighter-rouge">MST</code> 집합에 포함시키고 현재까지의 <code class="language-plaintext highlighter-rouge">MST</code> 집합에 포함된 정점들 중에서 인접한 정점들 中 가중치 최소 간선으로 연결된 정점을 선택하여 <u>트리를 확장</u>한다. 크루스칼 알고리즘은 이미 선택 완료되어 <code class="language-plaintext highlighter-rouge">MST</code> 집합에 들어가 있는 ‘간선’들은 다시 고려하지 않았던 반면, 프림 알고리즘은 이미 선택 완료되어 <code class="language-plaintext highlighter-rouge">MST</code> 집합에 들어가 있는 ‘정점’들의 인접 정점들 중에서 최소 간선을 가지는 <u>정점을 선택</u>하게 된다.</p>

<p><strong>프림 알고리즘은 시작점을 정해놓고 시작점에서 가까운 정점들을 선택하면서 MST 를 만들어가기 때문에, 크루스칼 알고리즘과 다르게 사이클을 이루지 않는다.</strong> 정점을 선택하는 식이기 때문에 트리 하나를 처음부터 끝까지 유지하게 된다. 크루스칼 알고리즘은 최소 비용 간선을 선택하기 때문에 서브 트리가 여러개 생길 수 있고 이를 합치는 과정이 필요한데 프림 알고리즘은 <u>인접한 정점을 선택하기 때문에 트리가 여러개 생기지 않고 단 하나의 트리를 유지하고 확장</u>하는 식이다. 따라서 <u>프림 알고리즘 과정에선 사이클이 생기지 않는다.</u> 👉 사이클 검사 및 합치는 과정인 Union-Find 과정이 필요 없음.</p>

<ol>
  <li>시작 정점 아무거나 선택하여 <code class="language-plaintext highlighter-rouge">MST</code>에 포함시킨다.</li>
  <li>현재까지의 <code class="language-plaintext highlighter-rouge">MST</code> 집합에 포함되어 있는 이전에 선택 완료 되었던 정점들의 인접 정점(<code class="language-plaintext highlighter-rouge">MST</code>에 포함되어 있지 않은)들 中 최소 가중치 간선을 가진 정점을 선택하여 <code class="language-plaintext highlighter-rouge">MST</code>에 포함한다.
    <ul>
      <li>2 번의 과정을 <code class="language-plaintext highlighter-rouge">n-1</code>개 간선을 가질 때까지 반복. 혹은 2 번의 과정을 <code class="language-plaintext highlighter-rouge">MST</code>가 <code class="language-plaintext highlighter-rouge">n</code>개의 정점을 모두 포함할 때가지 반복.</li>
    </ul>
  </li>
</ol>

<p><img src="https://user-images.githubusercontent.com/42318591/96866354-28689000-14a6-11eb-8664-b27718c3494d.png" alt="image" /></p>

<blockquote>
  <p>코드 참고 min:D’s님 블로그 <a href="https://mind-devlog.tistory.com/89">https://mind-devlog.tistory.com/89</a> <em>이 분의 풀이 코드 덕분에 프림 알고리즘을 이해할 수 있었다.</em></p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">costs</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">costs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">graph</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]][</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">graph</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]][</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">unvisited</span><span class="p">;</span>

	<span class="n">visited</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">unvisited</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">min_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">unvisited</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">min</span> <span class="o">&gt;</span> <span class="n">graph</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">unvisited</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
				<span class="p">{</span>
					<span class="n">min</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">unvisited</span><span class="p">[</span><span class="n">k</span><span class="p">]];</span>
					<span class="n">min_index</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">visited</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">unvisited</span><span class="p">[</span><span class="n">min_index</span><span class="p">]);</span>
		<span class="n">unvisited</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">unvisited</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">min_index</span><span class="p">);</span>
		<span class="n">answer</span> <span class="o">+=</span> <span class="n">min</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>시작 정점을 미리 정하고 시작한다.</li>
  <li>정점을 선택해가며 하나의 트리를 확장하는 방식이므로
    <ul>
      <li>방문한 정점들을 담는 <code class="language-plaintext highlighter-rouge">visited</code>, 아직 방문하지 않은 정점들을 담는 <code class="language-plaintext highlighter-rouge">unvisited</code> 벡터를 따로 둔다.
        <ul>
          <li>최종적으론 <code class="language-plaintext highlighter-rouge">unvisited</code>이 비워지고 모든 정점이 <code class="language-plaintext highlighter-rouge">visited</code>에 속하게 된다.</li>
          <li>시작은 <code class="language-plaintext highlighter-rouge">visited</code>에 시작 정점만 속하고 <code class="language-plaintext highlighter-rouge">unvisited</code>엔 나머지 정점들</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">costs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">graph</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]][</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">graph</span><span class="p">[</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]][</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
	<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">graph[i][j]</code> 값은 <code class="language-plaintext highlighter-rouge">i</code> 정점과 <code class="language-plaintext highlighter-rouge">j</code> 정점 사이의 가중치(비용) 값을 담는다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">unvisited</span><span class="p">;</span>

	<span class="n">visited</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">unvisited</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">visited</code>의 초기 상태는 [0]. 시작 정점을 <code class="language-plaintext highlighter-rouge">0</code> 정점으로 정해놓고 시작했다.</li>
  <li><code class="language-plaintext highlighter-rouge">unvisited</code>의 초기 상태는 [1, 2, 3]이 된다. <code class="language-plaintext highlighter-rouge">0</code>을 제외한 나머지 정점들.
    <ul>
      <li>따라서 <code class="language-plaintext highlighter-rouge">i = 1</code>부터 돌렸다.</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">min_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">unvisited</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">min</span> <span class="o">&gt;</span> <span class="n">graph</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">unvisited</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
				<span class="p">{</span>
					<span class="n">min</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="n">unvisited</span><span class="p">[</span><span class="n">k</span><span class="p">]];</span>
					<span class="n">min_index</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">visited</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">unvisited</span><span class="p">[</span><span class="n">min_index</span><span class="p">]);</span>
		<span class="n">unvisited</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">unvisited</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">min_index</span><span class="p">);</span>
		<span class="n">answer</span> <span class="o">+=</span> <span class="n">min</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>첫 번째 for 문 👉 <code class="language-plaintext highlighter-rouge">n - 1</code> 번 돈다. 시작 정점 제외한 나머지 <code class="language-plaintext highlighter-rouge">n - 1</code> 개의 정점 선택 과정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">i</code>는 곧 현재까지 방문한 정점의 개수가 되기도 한다.</li>
    </ul>
  </li>
  <li>두 번째 for 문 👉 <code class="language-plaintext highlighter-rouge">visited</code> 순회
    <ul>
      <li><code class="language-plaintext highlighter-rouge">visited</code>엔 <code class="language-plaintext highlighter-rouge">i</code>개의 방문 정점이 들어있기 때문에 <code class="language-plaintext highlighter-rouge">i</code>까지만 검사하면 된다.</li>
    </ul>
  </li>
  <li>세 번째 for 문 👉 <code class="language-plaintext highlighter-rouge">unvisited</code> 순회
    <ul>
      <li>아직 방문하지 않은 나머지 <code class="language-plaintext highlighter-rouge">n - i</code>개의 정점이 들어 있다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">visited</code>와 <code class="language-plaintext highlighter-rouge">unvisited</code> 사이에서 인접해 있는 정점들 중 가중치가 가장 작은 간선을 가진 정점을 선택해야 한다.
    <ul>
      <li>인접해 있는 정점 👉 <em>(graph[visited[j]][unvisited[k]] &gt; 0</em></li>
      <li>더 작은걸 찾았다면 업데이트 👉 <em>min &gt; graph[visited[j]][unvisited[k]]</em>
        <ul>
          <li>최종적으로 결정된 <code class="language-plaintext highlighter-rouge">min</code>을 가진 <code class="language-plaintext highlighter-rouge">unvisited</code> 정점을 삭제하고 <code class="language-plaintext highlighter-rouge">visited</code>에 추가해야 하므로 <code class="language-plaintext highlighter-rouge">min</code> 업뎃할 때 <code class="language-plaintext highlighter-rouge">min_index</code>에 해당 <code class="language-plaintext highlighter-rouge">unvisited</code> 정점을 보관해두어 같이 업데이트</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>결정되면
    <ul>
      <li><code class="language-plaintext highlighter-rouge">visited</code>에 <code class="language-plaintext highlighter-rouge">unvisited[min_index]</code>을 추가한다.</li>
      <li><code class="language-plaintext highlighter-rouge">unvisited[min_index]</code>는 삭제한다.</li>
      <li>비용 합산</li>
    </ul>
  </li>
</ul>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET