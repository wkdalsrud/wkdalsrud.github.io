I"<h1 id="-길-찾기-게임">📌 길 찾기 게임</h1>

<blockquote>
  <p>난이도 ⭐⭐⭐</p>
</blockquote>

<h2 id="-문제">🚀 문제</h2>

<p><img src="https://user-images.githubusercontent.com/42318591/108027728-fc34d880-706d-11eb-8bf3-99817eed534e.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/42318591/108027743-02c35000-706e-11eb-9f1c-8d7abdd82cb1.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/42318591/108027763-09ea5e00-706e-11eb-88c7-f6d7a0d94e2d.png" alt="image" /></p>

<ul>
  <li>순서대로 [5, 3], [11, 5] 가 각각 1, 2번 노드가 된다.</li>
  <li>이 문제의 경우 이진 탐색 트리의 크기 비교 기준은 <code class="language-plaintext highlighter-rouge">x</code> 좌표값이 된다. (<code class="language-plaintext highlighter-rouge">data</code> 인 몇 번 노드인지가 비교 기준이 아니다!)</li>
</ul>

<p><br /></p>

<h2 id="-내-풀이-">🚀 내 풀이 ⭕</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>같은 레벨에 있는 노드는 같은 y 좌표를 가진다.
자식 노드의 y값은 항상 부모 노드보다 작다.

임의의 노드 V의 왼쪽 서브 트리에 있는 모든 노드의 x 값은 V의 x값보다 작다.
임의의 노드 V의 오른쪽 서브 트리에 있는 모든 노드의 x 값은 V의 x값보다 크다.
모든 노드는 서로 다른 x값을 가진다.
</code></pre></div></div>

<blockquote>
  <p><strong>“이진 탐색 트리”</strong> 문제!</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">y</code> 값 👉 레벨을 구분한다. <code class="language-plaintext highlighter-rouge">y</code>값이 높을 수록 높은 레벨. 루트 노드가 가장 <code class="language-plaintext highlighter-rouge">y</code>값이 크겠다.</li>
  <li><code class="language-plaintext highlighter-rouge">x</code> 값 👉 <u>이진 탐색 트리의 비교 기준</u>이 된다.
    <ul>
      <li>예제의 경우 <code class="language-plaintext highlighter-rouge">9</code> 노드는 <em>[2,2] 좌표</em>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">7</code> 보다 <code class="language-plaintext highlighter-rouge">x</code> 값이 작다. 따라서 <code class="language-plaintext highlighter-rouge">7</code>의 “왼쪽” 서브트리에 속한다. <em>[8,6] 좌표</em></li>
          <li><code class="language-plaintext highlighter-rouge">4</code> 보다 <code class="language-plaintext highlighter-rouge">x</code> 값이 작다. 따라서 <code class="language-plaintext highlighter-rouge">4</code>의 “왼쪽” 서브트리에 속한다. <em>[3,5] 좌표</em></li>
          <li><code class="language-plaintext highlighter-rouge">6</code> 보다 <code class="language-plaintext highlighter-rouge">x</code> 값이 크다. 따라서 <code class="language-plaintext highlighter-rouge">6</code>의 “오른쪽” 서브트리에 속한다. <em>[1,3] 좌표</em></li>
        </ul>
      </li>
      <li><strong>이렇게 직속 부모뿐만 아니라 재귀적으로 조상들과의 관계에서도 만족되는 자리에 속해야 한다.</strong>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">x</code>값이 더 작을시 왼쪽으로</li>
          <li><code class="language-plaintext highlighter-rouge">x</code>값이 더 클시 오른쪽으로</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">N</code>이라는 노드의 왼쪽 서브트리의 모든 노드들은 <code class="language-plaintext highlighter-rouge">N</code> 보다 작다. 반면 <code class="language-plaintext highlighter-rouge">N</code>의 오른쪽 서브트리의 모든 노드들은 <code class="language-plaintext highlighter-rouge">N</code>보다 크다. <u>이진 탐색 트리의 모든 노드들은 이 관계를 재귀적으로 만족해야 한다.</u></p>

<blockquote>
  <p>풀이 순서</p>
</blockquote>

<ul>
  <li>1️⃣ <code class="language-plaintext highlighter-rouge">Node</code>로 묶기 (좌표와 번호와 왼쪽 자식이 누군지, 오른쪽 자식이 누군지를 함께 묶어 관리할 수 있도록)</li>
  <li>2️⃣ 이진 탐색 트리로 <code class="language-plaintext highlighter-rouge">Node</code> 를 관리. <u>모든 노드의 왼쪽 자식, 오른쪽 자식 세팅!!!</u>
    <ul>
      <li>추가가 될 때 <strong>모든 조상, 부모 노드들과 비교를 하여 왼쪽 자식으로 들어갈지 오른쪽 자식으로 들어갈지 각각 비교하여 어느 자리에 추가할지 결정해야 한다.</strong>
        <ul>
          <li>루트 노드부터 비교하면서 왼쪽 서브트리로 갈지 오른쪽 서브트리로 갈지 결정하면서 내려오다가 자식이 없는 위치에 도달하면 그 때 그 노드의 자식으로 추가하면 된다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>3️⃣ 이진 탐색 트리로 전위 순회</li>
  <li>4️⃣ 이진 탐색 트리로 후위 순회</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Node</span> 
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">leftChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">rightChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">_data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_y</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">_leftChild</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">_rightChild</span><span class="p">)</span>
        <span class="o">:</span><span class="n">data</span><span class="p">(</span><span class="n">_data</span><span class="p">),</span> <span class="n">x</span><span class="p">(</span><span class="n">_x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">_y</span><span class="p">),</span> <span class="n">leftChild</span><span class="p">(</span><span class="n">_leftChild</span><span class="p">),</span> <span class="n">rightChild</span><span class="p">(</span><span class="n">_rightChild</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">BST_InsertNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">tree</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="n">BST_InsertNode</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="n">BST_InsertNode</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">BST_PreOrder</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">tree</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">pre</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="n">pre</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="n">BST_PreOrder</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">pre</span><span class="p">);</span>
    <span class="n">BST_PreOrder</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">pre</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">BST_PostOrder</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">tree</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="n">BST_PostOrder</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
    <span class="n">BST_PostOrder</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
    <span class="n">pos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">Node</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">Node</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">nodeinfo</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">answer</span><span class="p">;</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nodeinfo</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">nodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nodeinfo</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">nodeinfo</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">nodes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nodes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cmp</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">BST_InsertNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pre</span><span class="p">;</span>
    <span class="n">BST_PreOrder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pre</span><span class="p">);</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">BST_PostOrder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">);</span>

    <span class="n">answer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pre</span><span class="p">);</span>
    <span class="n">answer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="1️⃣-node-로-묶어서-관리">1️⃣ Node 로 묶어서 관리</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span> 
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">leftChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">rightChild</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">_data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_y</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">_leftChild</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">_rightChild</span><span class="p">)</span>
        <span class="o">:</span><span class="n">data</span><span class="p">(</span><span class="n">_data</span><span class="p">),</span> <span class="n">x</span><span class="p">(</span><span class="n">_x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">_y</span><span class="p">),</span> <span class="n">leftChild</span><span class="p">(</span><span class="n">_leftChild</span><span class="p">),</span> <span class="n">rightChild</span><span class="p">(</span><span class="n">_rightChild</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>정렬 하면 정렬 전 몇번째 노드였었는지 <code class="language-plaintext highlighter-rouge">data</code>를 기억해야 하고, 또한 해당 노드의 왼쪽 자식, 오른쪽 자식에 대한 정보도 알아야하기 때문에 <code class="language-plaintext highlighter-rouge">Node</code> 클래스 (또는 구조체)를 만들어 함께 관리하는게 좋겠다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">Node</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">Node</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">nodeinfo</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">answer</span><span class="p">;</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nodeinfo</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">nodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nodeinfo</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">nodeinfo</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">nodes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nodes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cmp</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">nodes</code> 벡터에 <code class="language-plaintext highlighter-rouge">nodeinfo</code> 원소들을 바탕으로 <code class="language-plaintext highlighter-rouge">Node</code> 객체를 만들어 넣는다. (왼쪽 자식, 오른쪽 자식은 “이진 탐색 트리”로서 추가될 때 알 수 있다.)</li>
  <li>추후 높은 레벨(조상, 부모들)부터 차례대로 미리 왼쪽 자식, 오른쪽 자식을 설정해줘야 하기 때문에 <strong>정렬 한다.</strong> 이진 탐색 트리에 추가할 때 조상부터 내려오며 크기를 비교하면서 내려올건데 자식이 없는 곳에 도달할 때 그 위치에 추가할 것이기 때문에 이 작업은 높은 레벨의 노드부터 진행되야 하기 때문에 정렬하는 것이다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">y</code> 값이 큰게 앞에 오도록 함. 즉, 조상일 수록 앞에 오게! (정렬 후 <code class="language-plaintext highlighter-rouge">nodes[0]</code>는 루트 노드가 될 것)</li>
      <li><code class="language-plaintext highlighter-rouge">y</code> 값이 같다면 <code class="language-plaintext highlighter-rouge">x</code> 값이 작은게 앞에 오도록 함. (왼쪽이 오른쪽보단 먼저)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="2️⃣-이진-탐색-트리에-추가-알맞는-자리에-추가되기--왼쪽-오른쪽-자식-세팅">2️⃣ 이진 탐색 트리에 추가 (=알맞는 자리에 추가되기 = 왼쪽, 오른쪽 자식 세팅)</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">void</span> <span class="nf">BST_InsertNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">tree</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 현재 재귀 단계에서의 트리의 루트와 크기 비교 (서브트리의 루트)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 루트보다 작은데 마침 루트에게 왼쪽 자식이 없다면 루트의 왼쪽 자식으로 세팅 후 종료</span>
            <span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="n">BST_InsertNode</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span> <span class="c1">// 루트보다 작은데 루트에게 왼쪽 자식이 있다면 거기에 추가될 수 없으므로 더 내려가야 함. 왼쪽 서브트리로 내려가기.</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 루트보다 큰데 마침 루트에게 오른쪽 자식이 없다면 루트의 오른쪽 자식으로 세팅 후 종료</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="n">BST_InsertNode</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span> <span class="c1">// 루트보다 큰데 루트에게 오른쪽 자식이 있다면 거기에 추가될 수 없으므로 더 내려가야 함. 오른쪽 서브트리로 내려가기.</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">BST_InsertNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</code></pre></div></div>

<blockquote>
  <p>이진 탐색 트리에 <u>추가</u> 된다는 것은 곧 조상부터 크기를 비교며 내려오면서 누군가의 <strong>왼쪽, 오른쪽 자식으로 세팅</strong>된다는 것이다.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">nodes</code>는 Node 들을 높은 레벨의 노드들이 먼저오게끔 정렬이 되어 있는 상태다.(<code class="language-plaintext highlighter-rouge">nodes[0]</code>은 루트 노드가 됨) 모든 노드들에 대해 <u>루트 노드부터 시작하여 내려오면서 조상들과 크기를 비교하면서 내려온다. 쭉 내려오다가 자식이 없는 노드의 자식으로 세팅 되고 빠져나오면 된다.</u></p>

<p>루트 노드 제외하고 그 이후 노드부터 진행한다. (i = 1)</p>

<ul>
  <li><strong>BST_InsertNode(Node* tree, Node* node)</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">tree</code> 를 루트로 하는 서브트리로 재귀호출 하면서 내려온다.
        <ul>
          <li>왼쪽 서브 트리의 루트로 호출하면 왼쪽으로 내려가는 것이고</li>
          <li>오른쪽 서브 트리의 루트로 호출하면 오른쪽으로 내려가는 것이 된다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/42318591/108437491-d1769a00-7290-11eb-82d9-d31cbecf12f6.png" alt="image" /></p>

<blockquote>
  <p>크기 비교 기준 : <code class="language-plaintext highlighter-rouge">x</code></p>
</blockquote>

<ul>
  <li>“3” 노드의 경우
    <ul>
      <li>“7” 노드의 <code class="language-plaintext highlighter-rouge">x</code> 보다 크다. 👉 오른쪽 자식 “2”를 루트로 한 서브트리 재귀 호출</li>
      <li>“2” 노드의 <code class="language-plaintext highlighter-rouge">x</code> 보다 크다. 👉 “2”의 오른쪽 자식은 없으므로 “2”의 오른쪽 자식으로 세팅하고 종료. “2” 노드의 오른쪽 자식이 누군지가 세팅된다.</li>
    </ul>
  </li>
  <li>“8” 노드의 경우
    <ul>
      <li>“7” 노드의 <code class="language-plaintext highlighter-rouge">x</code> 보다 작다. 👉 왼쪽 자식 “4”를 루트로 한 서브트리 재귀 호출</li>
      <li>“4” 노드의 <code class="language-plaintext highlighter-rouge">x</code> 보다 크다. 👉 오른쪽 자식 “1”를 루트로 한 서브트리 재귀 호출</li>
      <li>“1” 노드의 <code class="language-plaintext highlighter-rouge">x</code> 보다 크다. 👉 “1”의 오른쪽 자식은 없으므로 “1”의 오른쪽 자식으로 세팅하고 종료. “1” 노드의 오른쪽 자식이 누군지가 세팅된다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="3️⃣-순회">3️⃣ 순회</h3>

<p><img src="https://user-images.githubusercontent.com/42318591/108437491-d1769a00-7290-11eb-82d9-d31cbecf12f6.png" alt="image" /></p>

<ul>
  <li>전위 순회 순서 👉  7 4 6 9 1 8 5 2 3</li>
  <li>후위 순회 순서 👉  9 6 5 8 1 4 3 2 7</li>
</ul>

<h4 id="-전위-순회">🔥 전위 순회</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">BST_PreOrder</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">tree</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">pre</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="n">pre</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="n">BST_PreOrder</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">pre</span><span class="p">);</span>
    <span class="n">BST_PreOrder</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">pre</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pre</span><span class="p">;</span>
    <span class="n">BST_PreOrder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pre</span><span class="p">);</span>

    <span class="n">answer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pre</span><span class="p">);</span>
</code></pre></div></div>

<p>나의 왼쪽 서브트리의 노드들과 오른쪽 서브트리의 노드들을 순회하기 전에 나를 먼저 출력한다. (<code class="language-plaintext highlighter-rouge">pre</code>에 출력 순서대로 원소 들어가게 됨)</p>

<p><br /></p>

<h4 id="-후위-순회">🔥 후위 순회</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">BST_PostOrder</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">tree</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="n">BST_PostOrder</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
    <span class="n">BST_PostOrder</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
    <span class="n">pos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pos</span><span class="p">;</span>
    <span class="n">BST_PostOrder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">);</span>

    <span class="n">answer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
</code></pre></div></div>

<p>나의 왼쪽 서브트리의 노드들과 오른쪽 서브트리의 노드들을 순회를 모두 마친 후에 나를 먼저 출력한다. (<code class="language-plaintext highlighter-rouge">pre</code>에 출력 순서대로 원소 들어가게 됨)</p>

<p><br /></p>

<h2>💡</h2>

<p><a href="https://ansohxxn.github.io/algorithm/bst/">이진 탐색 트리</a> 에 대한 더 자세한 설명은 이 포스트를 참고해주세요.</p>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET