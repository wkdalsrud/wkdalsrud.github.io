I"	^<h1 id="이분탐색-입국심사">[이분탐색] 입국심사</h1>

<blockquote>
  <p>난이도 ⭐⭐⭐</p>
</blockquote>

<h2 id="-문제">💛 문제</h2>

<p><img src="https://user-images.githubusercontent.com/42318591/99346359-c9950b80-28d7-11eb-95bd-b10182eca85f.png" alt="image" /></p>

<p><br /></p>

<h2 id="-이분-탐색-문제-풀이시-생각해봐야할-것">🎀 ‘이분 탐색’ 문제 풀이시 생각해봐야할 것</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">이분 탐색</code>을 사용하면 모든 경우의 수를 일일이 전부 다 탐색할 필요 없이, <strong>스무고개, 업 다운 게임과 같은 방식으로 답을 찾을 수 있다.</strong></p>
</blockquote>

<p>1~100의 범위 中 <code class="language-plaintext highlighter-rouge">64</code>를 찾으려 한다면 처음부터 차례 차례 하나씩 검사해가며 찾아야 했을 것이다. 그러나 업 다운 게임 방식으로 생각해본다면 1~100의 중간인 50보다 큰지, 50~100의 중간인 75보다 큰지, 작다면 50~75의 중간인 62보다 큰지 등등 이런식으로 찾아나가면 된다. 범위의 중간 값을 기준으로 비교해 가며 <u>탐색 범위를 절반씩 좁혀나가는 방식</u>을 <code class="language-plaintext highlighter-rouge">이진 탐색</code> 알고리즘이라고 한다. <u>이진 탐색을 사용하여 답을 찾기 위해선 답이 속해있는 범위가 정렬이 되어 있어야 한다!</u> 1~100에서 <code class="language-plaintext highlighter-rouge">64</code>를 찾는 일은, 1~100은 그 자체로 순서가 있는, 정렬이 되어 있는 범위이기 때문에 이분 탐색으로 찾는 것이 가능한 것이다. <strong>입력 크기가 굉장히 커서 모든 경우를 순차 탐색하기엔 부담스럽다면, 1️⃣ 구하고자 하는 답이 명확하게 정해져 있고 2️⃣ 구하고자 하는 답의 범위가 정렬이 되어 있다면 이분 탐색으로 답을 찾는 것을 고려해보자!</strong> 시간 복잡도는, 즉 <code class="language-plaintext highlighter-rouge">mid</code>와 찾고자 하는 답을 비교하는 횟수는 \(O(logN)\) 을 넘지 않는다. 1 ~ 100 에서 <code class="language-plaintext highlighter-rouge">64</code>를 찾는 일은 못해도 log100 = 6.xx 6번을 넘지 않는다. 순차 탐색으로 찾으려 했다면 64번을 비교했어야 했을 것이다.</p>

<ol>
  <li><strong><em>고정 되어 정해져 있는 것은 무엇인지</em></strong> (비교할 대상이 된다.)</li>
  <li><strong><em>무엇을 이분 탐색으로 찾을 것인가</em></strong> (<code class="language-plaintext highlighter-rouge">mid</code>로 업뎃 해 나갈 것)</li>
  <li><strong><em>찾으려고 하는 것이 속한 범위가 정렬이 되어 있는가</em></strong></li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span> <span class="c1">// 찾으려고 하는 답</span>

<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="k">while</span><span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">)</span>  
        <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// start &gt; end 가 되어 빠져나온 경우. 답이 범위에 없는 것임! </span>
</code></pre></div></div>

<p><br /></p>

<h2 id="-풀이">💛 풀이</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">solution</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">times</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">n</span> <span class="o">*</span> <span class="o">*</span><span class="n">max_element</span><span class="p">(</span><span class="n">times</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">times</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">mid</span><span class="p">;</span>
    
    <span class="k">while</span><span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">man</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">time</span> <span class="o">:</span> <span class="n">times</span><span class="p">)</span>
            <span class="n">man</span> <span class="o">+=</span> <span class="n">mid</span> <span class="o">/</span> <span class="n">time</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">man</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="이분-탐색">이분 탐색</h3>

<ol>
  <li><strong><em>고정 되어 정해져 있는 것은 무엇인지</em></strong> (비교할 대상이 된다.)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">n</code> 입국 심사를 기다리는 모든 사람의 수</li>
    </ul>
  </li>
  <li><strong><em>무엇을 이분 탐색으로 찾을 것인가</em></strong> (<code class="language-plaintext highlighter-rouge">mid</code>로 업뎃 해 나갈 것)
    <ul>
      <li>모든 사람이 심사를 받는데 걸리는 시간의 최솟값</li>
    </ul>
  </li>
  <li><strong><em>찾으려고 하는 것이 속한 범위가 정렬이 되어 있는가</em></strong>
    <ul>
      <li>모든 사람이 심사를 받는데 걸리는 시간의 범위의 최소값은 대충 <code class="language-plaintext highlighter-rouge">1</code> 로 상정하고 최대값은 가장 심사가 오래 걸리는 심사관 한명이 모든 사람의 심사를 담당했을 경우의 시간으로 생각해볼 수 있다.</li>
      <li>예제에서 가장 심사가 오래걸리는 심사관의 심사 시간은 10분이므로, 예제로 따져본다면 모든 사람이 심사를 받는데 걸리는 시간의 범위는 <code class="language-plaintext highlighter-rouge">1 ~ 60</code> (10 * 6) 이 된다. 우리가 찾고자 하는 답인 ‘모든 사람이 심사를 받는데 걸리는 시간’은 이 범위 내에 있다.</li>
      <li><u>1 ~ 60 범위는 그 자체로 정렬이 되어 있다.</u> 우리가 찾고자 하는 답인 ‘모든 사람이 심사를 받는데 걸리는 시간’은 이 정렬된 범위 내에 있으므로 이분 탐색을 사용하여 답을 찾을 수 있다.
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">long</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="kt">long</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">n</span> <span class="o">*</span> <span class="o">*</span><span class="nf">max_element</span><span class="p">(</span><span class="n">times</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">times</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<p><br /></p>

<blockquote>
  <p>모든 경우의 수를 검사하지 않는다. 우리가 찾고자 하는 답인 ‘모든 사람이 심사를 받는데 걸리는 시간’을 업다운 형식으로 범위를 좁혀 나가 찾을 뿐이다. 업 다운의 기준은 정해져 있는 <code class="language-plaintext highlighter-rouge">n</code>명을 현재의 시간으로 충분히 커버가 가능한지가 된다. 커버할 수 있는 최소한의 시간을 찾아나가면 된다.</p>
</blockquote>

<ul>
  <li>문제에서 명확히 정해져 있는 것은 <code class="language-plaintext highlighter-rouge">n</code> 입국 심사를 기다리는 모든 사람의 수.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">n</code>과 비교하여 범위를 업데이트 및 좁혀 나간다.
        <ul>
          <li>‘모든 사람이 심사를 받는데 걸리는 시간’을 각각의 입국 심사관의 소요 시간(<code class="language-plaintext highlighter-rouge">times</code> 원소들)으로 나눈 값을 다 더하면 👉 현재 범위에서의 <code class="language-plaintext highlighter-rouge">mid</code>가 되는 ‘모든 사람이 심사를 받는데 걸리는 시간’을 기준에서의 심사 가능 사람 수 <code class="language-plaintext highlighter-rouge">man</code>를 구할 수 있게 된다. 예를 들어 30분 동안엔 30/7 + 30/10 = 총 7 명을 검사할 수 있게 된다.
            <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

  <span class="kt">long</span> <span class="kt">long</span> <span class="n">man</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">time</span> <span class="o">:</span> <span class="n">times</span><span class="p">)</span>
      <span class="n">man</span> <span class="o">+=</span> <span class="n">mid</span> <span class="o">/</span> <span class="n">time</span><span class="p">;</span>
</code></pre></div>            </div>
          </li>
          <li>이를 <code class="language-plaintext highlighter-rouge">n</code>과 비교하면 된다.
            <ul>
              <li><code class="language-plaintext highlighter-rouge">man &lt; n</code> : 이 값이 <code class="language-plaintext highlighter-rouge">n</code>보다 <u>작다면</u> 현재의 <code class="language-plaintext highlighter-rouge">mid</code> 시간은 너무 적다는 것이다. 이 시간으로는 <code class="language-plaintext highlighter-rouge">n</code>명을 심사할 수 없다. 따라서 이 시간보다 더 큰 범위로 좁혀야 한다.
                <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">man</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>                </div>
              </li>
              <li><code class="language-plaintext highlighter-rouge">man &gt;= n</code> :
                <ul>
                  <li>이 값이 <code class="language-plaintext highlighter-rouge">n</code>보다 <u>크다면</u> 현재의 <code class="language-plaintext highlighter-rouge">mid</code> 시간은 충분하다는 것이다. 최소 시간을 찾아야하므로 혹여나 답이 될 수 있는 가능성도 있다. <code class="language-plaintext highlighter-rouge">n</code>보다 더 많은 사람을 심사할 수 있다는 것이니까! 이 시간 보다 더 작은 범위로 좁혀야 한다.
                    <ul>
                      <li>답일 수 도 있다! 그 다음의 <code class="language-plaintext highlighter-rouge">mid</code>들이 전부 <code class="language-plaintext highlighter-rouge">n</code>명을 커버하기엔 너무 작다면 절대 답이 될 수 없으므로 이 때의 시간이 답이 되기 때문이다. <code class="language-plaintext highlighter-rouge">n</code>명을 커버할 수 있는 최소한의 충분한 시간을 구하는 것이기 때문에 이 때 <code class="language-plaintext highlighter-rouge">answer</code>에 <code class="language-plaintext highlighter-rouge">mid</code> 시간을 업데이트 해놓아야 한다.</li>
                    </ul>
                  </li>
                  <li>이 값이 <code class="language-plaintext highlighter-rouge">n</code>과 <u>같다면</u> 현재의 <code class="language-plaintext highlighter-rouge">mid</code> 시간은 충분하다는 것이다.
                    <ul>
                      <li>답일 수 도 있다! 그러나 우리가 구하고자 하는 것은 <code class="language-plaintext highlighter-rouge">n</code>명을 커버할 수 있는 시간의 최소값이므로 더 작은 시간으로도 <code class="language-plaintext highlighter-rouge">n</code>과 일치할 수도 있으니 일단 <code class="language-plaintext highlighter-rouge">answer</code>에 <code class="language-plaintext highlighter-rouge">mid</code> 시간을 업뎃 해 놓는다.</li>
                    </ul>
                  </li>
                  <li>예를 들어 28분으로 <code class="language-plaintext highlighter-rouge">6</code>명을 충분히 커버할 수 있었다면 (28분으로 심사할 수 있는 사람의 수가 6 이상이였다면) 27분도 <code class="language-plaintext highlighter-rouge">6</code>명을 커버할 수 있는지 알아봐야 한다. 27분일때는 <code class="language-plaintext highlighter-rouge">6</code>명을 커버할 수 없었다면 28분이 답이 된다. 이게 최소값이 될테니까! 실제로도 28명, 29명 둘 다 <code class="language-plaintext highlighter-rouge">6</code>명을 처리 할 수 있다. <code class="language-plaintext highlighter-rouge">answer</code>는 작거나 같을때마다 업데이트 되므로 최종적으론 최소값인 28이 들어가게 된다.
                    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">else</span>
<span class="p">{</span>
  <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">answer</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>                    </div>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">answer</code>가 while문에서 한번도 업뎃되지 않을 경우를 대비하여 최대값인 <code class="language-plaintext highlighter-rouge">end</code>를 초기값으로 잡는다.
    <ul>
      <li>한번도 업뎃되지 않았다는건 1 ~ 59 범위의 모든 시간이 <code class="language-plaintext highlighter-rouge">n</code> 명을 심사하기엔 전부 부족했다는 것이다.
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="kt">long</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>이 문제는 이분 탐색의 대표 코드에서 <code class="language-plaintext highlighter-rouge">mid == answer</code>가 되면 <code class="language-plaintext highlighter-rouge">return</code> 되어 빠져나오는 것과 다르게, 정확하게 딱 떨어지는 값을 찾는 것이 아닌 최소값을 찾는 것이기 때문에 <code class="language-plaintext highlighter-rouge">answer</code>를 미리 업데이트 해둘 뿐, while을 탈출하는건 <code class="language-plaintext highlighter-rouge">start &gt; end</code> 가 될 때 뿐이다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">mid == answer</code>가 되었다고해서 바로 while문을 빠져나와 <code class="language-plaintext highlighter-rouge">answer</code>를 리턴하면 안된다. 답인 28분 말고도 29분일 때 또한 <code class="language-plaintext highlighter-rouge">6</code>명을 처리할 수 있었는데 이렇게 했다면 답은 28이 아닌 29로 오답을 리턴했을 것이다. 최소값을 리턴해야 하기 때문에 더 작은 시간에서 <code class="language-plaintext highlighter-rouge">6</code>명을 커버할 수는 없는지 또 검사해야 하므로 while문을 빠져나오지 않고 <code class="language-plaintext highlighter-rouge">n</code>보다 작거나 클 때마다 계속해서 <code class="language-plaintext highlighter-rouge">answer</code>를 업뎃해나가야 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="형변환--long-long">형변환 : long long</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">n</span> <span class="o">*</span> <span class="o">*</span><span class="nf">max_element</span><span class="p">(</span><span class="n">times</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">times</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>
</code></pre></div></div>

<p>처음엔 이렇게 코딩을 했었다. 테스트 케이스들이 계속해서 오류가 났었는데 이 문제 때문이였을 줄이야… <code class="language-plaintext highlighter-rouge">n</code>과 <code class="language-plaintext highlighter-rouge">*max_element(times.begin(), times.end())</code>의 결과는 둘 다 <code class="language-plaintext highlighter-rouge">int</code> 자료형이기 때문에 <code class="language-plaintext highlighter-rouge">(n * *max_element(times.begin(), times.end()))</code> 이 연산 결과도 당연히 <code class="language-plaintext highlighter-rouge">int</code>이다. 그러나 이 연산 결과가 <code class="language-plaintext highlighter-rouge">int</code> 형에 담을 수 없을 만큼 큰 값이라면 overflow 가 발생하므로, overflow 되어 부정확해져버린 이 연산 결과로 <code class="language-plaintext highlighter-rouge">long long</code> 형변환 해 봤자다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">n</span> <span class="o">*</span> <span class="o">*</span><span class="nf">max_element</span><span class="p">(</span><span class="n">times</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">times</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</code></pre></div></div>

<p>따라서 피연산자 중 하나인 <code class="language-plaintext highlighter-rouge">n</code>을 미리 <code class="language-plaintext highlighter-rouge">long long</code>으로 형변환 해 두고 <code class="language-plaintext highlighter-rouge">n * *max_element(times.begin(), times.end())</code> 연산을 진행해야 연산 결과가 자동 형변환되어 <code class="language-plaintext highlighter-rouge">long long</code>에 올바르게 바로 담기게 된다.</p>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET