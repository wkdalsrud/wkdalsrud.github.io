I"wk<h2 id="중복-순열이란">중복 순열이란</h2>

<ul>
  <li>순서를 따진다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">abc</code> 와 <code class="language-plaintext highlighter-rouge">acb</code>는 서로 다른 존재이다.</li>
    </ul>
  </li>
  <li><u>중복을 허용한다</u></li>
  <li>길이가 n 인 범위의 r 자리 중복 순열 경우의 수
    <ul>
      <li>👉 <code class="language-plaintext highlighter-rouge">n</code>을 <code class="language-plaintext highlighter-rouge">r</code>번 곱하면 된다.
        <ul>
          <li>길이가 3 인 범위의 4 자리 중복 순열 경우의 수
            <ul>
              <li>👉 \(3 X 3 X 3 X 3 = 3^4 = 81\)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="구현-코드feat-재귀">구현 코드(feat. 재귀)</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">repeatPermutation</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">perm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">perm</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">perm</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">perm</span><span class="p">[</span><span class="n">depth</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">repeatPermutation</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">perm</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    
    <span class="n">repeatPermutation</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// {'a', 'b'}의 길이 3의 중복순열 모두 출력하기</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💎출력💎

a a a
a a b
a b a
a b b
b a a
b a b
b b a
b b b
</code></pre></div></div>

<blockquote>
  <p>예시) <code class="language-plaintext highlighter-rouge">{'a', 'b'}</code>배열에서 <code class="language-plaintext highlighter-rouge">r = 3</code> 자릿수의 <strong>중복 순열</strong>들 출력하기 👉 경우의 수 \(2^3 = 8\)</p>
</blockquote>

<ul>
  <li>중복을 허용하기 때문에 <u>모든 각각의 자리마다 올 수 있는 숫자의 후보는 모든 원소가 된다.</u> 👈 ‘중복’순열 특징.
    <ul>
      <li>반면에 그냥 일반 순열은 중복이 허용되지 않기 때문에 각 자리에 올 수 있는 수는 이전 단계에서 perm 원소로 결정된 적이 없는 원소여야 했음.</li>
    </ul>
  </li>
  <li>재귀 과정 (<code class="language-plaintext highlighter-rouge">r = 3</code>길이의 중복 순열 구하기)
    <ul>
      <li><img src="https://user-images.githubusercontent.com/42318591/90953176-21bc9d00-e4a4-11ea-8ebc-d30f9c526df2.png" alt="image" width="80%" height="80%" class="align-center" /></li>
      <li><code class="language-plaintext highlighter-rouge">vec</code> 벡터(길이 2)로부터 후보 원소들을 뽑아내서 <code class="language-plaintext highlighter-rouge">perm</code> 벡터(길이 <code class="language-plaintext highlighter-rouge">r = 3</code>)을 만들어 나감.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">depth</code>는 <code class="language-plaintext highlighter-rouge">perm</code>을 순회하며 <code class="language-plaintext highlighter-rouge">i</code>는 <code class="language-plaintext highlighter-rouge">vec</code>을 순회한다.</li>
        </ul>
      </li>
      <li>한단계씩 깊숙히 들어갈 때마다(= 즉 <code class="language-plaintext highlighter-rouge">perm</code>의 자릿수를 한칸씩 옮길 때 마다) 각 자릿수에 <code class="language-plaintext highlighter-rouge">vec</code>의 <u>모든 원소를 순회하며 대입한다.</u>
        <ul>
          <li><em>for(int i = 0; i &lt; vec.size(); i++)</em></li>
          <li>중복 순열은 중복을 허용하기 때문에 <code class="language-plaintext highlighter-rouge">perm</code>의 각 자리마다  <code class="language-plaintext highlighter-rouge">vec</code>의 모든 원소가 후보가 되기 때문</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">r</code>길이의 중복 순열을 구하려는것이면 <code class="language-plaintext highlighter-rouge">r</code>단계까지 깊숙히 들어가면 된다!
        <ul>
          <li><code class="language-plaintext highlighter-rouge">depth</code>는 0 부터 시작하여 base case인 <code class="language-plaintext highlighter-rouge">depth == r</code>이 될 때까지 증가하며 깊숙히 들어간다.</li>
          <li>base case인 <code class="language-plaintext highlighter-rouge">depth == r</code>이 되면 그동안 벡터에 저장되어 완성된 한 케이스의 중복 순열을 출력한 후 return 하여 빠져나와 다음 원소를 후보로 삼는다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="일반-순열-구하기">일반 순열 구하기</h3>

<blockquote>
  <p><em>위에 중복 순열 구하는 코드와 비슷한 방식대로</em>  한단계씩 깊숙히 들어가면서 대입하되 <u>이전에 후보가 결정되지 않았었던 원소만 대입할 수 있는 장치</u>를 넣으면 일반 순열을 구현할 수 있다.</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">repeatPermutation</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">check</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">perm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">perm</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>  <span class="c1">// perm.size 👉 r</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">perm</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">check</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="c1">// check.size() 👉 vec.size()와 동일. vec 원소들 순회나 마찬가지!</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>  <span class="c1">// 이전에 perm 원소로 결정된 vec원소라면 그냥 지나가기</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// 이전에 perm 원소로 결정된 vec원소라고 표시해 줌.</span>
            <span class="n">perm</span><span class="p">[</span><span class="n">depth</span><span class="p">]</span> <span class="o">=</span> <span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>   <span class="c1">// 이전에 perm 원소로 결정된 vec원소가 아니라면 perm의 원소로 결정. depth 자리에 대입. </span>
            <span class="n">repeatPermutation</span><span class="p">(</span><span class="n">check</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// perm의 다음 원소 결정하러 가기</span>
            <span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// 결정하고 돌아왔으면 체크 해제</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">,</span> <span class="sc">'d'</span><span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">perm</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">check</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="c1">// check는 vec의 원소들이 이미 perm 원소로 결정된 적이 있는지를 함께 나타내주는 컨테이너가 될 것이다.</span>
        <span class="n">check</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">false</span><span class="p">));</span>  <span class="c1">// false로 초기화</span>
    
    <span class="n">repeatPermutation</span><span class="p">(</span><span class="n">check</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 4P2 {'a', 'b', 'c', 'd'}의 길이 2의 순열 모두 출력하기</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💎출력💎

a b
a c
a d
b a
b c
b d
c a
c b
c d
d a
d b
d c
</code></pre></div></div>

<blockquote>
  <p>예시) <code class="language-plaintext highlighter-rouge">{'a', 'b', 'c', 'd'}</code>배열에서 <code class="language-plaintext highlighter-rouge">r = 2</code> 자릿수의 <strong>일반 순열</strong>들 출력하기 👉 경우의 수 4P2 = 12</p>
</blockquote>

<ul>
  <li>그냥 일반 순열은 중복이 허용되지 않기 때문에 각 자리에 올 수 있는 수는 이전 단계에서 perm 원소로 결정된 적이 없는 원소여야 한다.
    <ul>
      <li>후보가 될 원소들인 <code class="language-plaintext highlighter-rouge">vec</code>의 각 원소마다 <u>bool 타입으로 이전 단계에서 이미 결정된 적이 있는지를 체크 하는 정보가 추가로 필요하다.</u></li>
      <li>그리고 <u>체크 되지 않은 것들만</u> 후보로 삼고 그 중에서 선택해야 한다.</li>
      <li><u>재귀가 끝난 다음에는</u>, 즉 해당 순열이 결정됐으면 돌아가야 하므로 <u>다시 체크를 해제해주어야 한다.</u></li>
    </ul>
  </li>
  <li>재귀 과정 예시 (<code class="language-plaintext highlighter-rouge">r = 2</code>길이의 중복 순열 구하기)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">vec</code> 벡터(길이 4)로부터 후보 원소들을 뽑아내서 <code class="language-plaintext highlighter-rouge">perm</code> 벡터(길이 <code class="language-plaintext highlighter-rouge">r = 2</code>)을 만들어 나감.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">depth</code>는 <code class="language-plaintext highlighter-rouge">perm</code>을 순회하며 <code class="language-plaintext highlighter-rouge">i</code>는 <code class="language-plaintext highlighter-rouge">vec</code>을 순회한다.</li>
        </ul>
      </li>
      <li>한단계씩 깊숙히 들어갈 때마다(= 즉 <code class="language-plaintext highlighter-rouge">perm</code>의 자릿수를 한칸씩 옮길 때 마다) 각 자릿수에 <code class="language-plaintext highlighter-rouge">vec</code>의 <u>방문 하지 않은, 즉 체크되지 않은 원소들만 골라 차례대로 대입한다.</u>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">check</code>는 <code class="language-plaintext highlighter-rouge">pair&lt;char, bool&gt;</code>타입의 원소를 가지는 벡터로 <code class="language-plaintext highlighter-rouge">vec</code>의 char 원소들 각각에 bool 타입의 데이터를 또 붙여 <code class="language-plaintext highlighter-rouge">vec</code>의 각각의 원소들이 이전 단계에서 <code class="language-plaintext highlighter-rouge">perm</code>의 원소가 됐는지 안됐는지를 체크한다.
            <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">check</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">check</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h4 id="cf-vector-에러와-깨달음">cf) vector 에러와 깨달음</h4>

<blockquote>
  <p>공간이 없는 벡터일 때 👉 <code class="language-plaintext highlighter-rouge">push_back</code></p>
</blockquote>

<blockquote>
  <p>내용물은 아직 없지만 공간은 잡혀있는 벡터일 때 👉 <code class="language-plaintext highlighter-rouge">[]</code></p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">,</span> <span class="sc">'d'</span><span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">perm</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">check</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  
        <span class="n">check</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">false</span><span class="p">));</span> <span class="c1">// ❌런타임 에러 발생!</span>
</code></pre></div></div>

<blockquote>
  <p>위와 같이 하면 에러가 발생하거나 공백들이 출력되는 등 정상적으로 출력되지 않는다. 왜 그럴까?</p>
</blockquote>

<ul>
  <li><u>check는 vec.size() 사이즈 만큼의 공간을 이미 갖고 있는 상태다.</u> <code class="language-plaintext highlighter-rouge">vector&lt;pair&lt;char, bool&gt;&gt; check(vec.size());</code> 라고 선언해서!</li>
  <li>그런 상태에서 <code class="language-plaintext highlighter-rouge">push_back</code>을 해버리면 내용물은 텅텅 비었지만 <u>vec.size() 사이즈만큼의 공간을 차지하는 상태에서 뒤에 원소를 추가해주려고 하니 에러가 발생</u>하는 것이다.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">check</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  
    <span class="n">check</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">false</span><span class="p">));</span> 
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vector&lt;pair&lt;char, bool&gt;&gt; check;</code> 그냥 이렇게 사이즈 0 인 아무것도 없는 빈 공간의 컨테이너로 선언한 후 그 이후에 <code class="language-plaintext highlighter-rouge">push_back</code>으로 뒤에 추가해주면 문제가 발생하지 않는다.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>

<span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// ❌런타임 에러 발생!</span>
</code></pre></div></div>

<p>벡터 <code class="language-plaintext highlighter-rouge">vec</code>은 아직 아무런 공간을 차지 하지 않는 벡터다. 그런 상황에서 <code class="language-plaintext highlighter-rouge">vec[0]</code>을 통해 없는 공간을 사용하려고 하면 위와같이 에러가 발생한다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  
</code></pre></div></div>

<p>위와 같이 <code class="language-plaintext highlighter-rouge">vec</code>을 선언시 int 데이터가 3 개 들어갈 만큼 공간을 미리 확보해두면 <code class="language-plaintext highlighter-rouge">vec[0]</code>을 통해 접근해도 문제가 없다. 이미 <code class="language-plaintext highlighter-rouge">vec</code>로서 존재하는 공간에 접근하려고 하는 것이기 때문이다! 그리고 저렇게 미리 공간을 잡아두면 vec[0]~vec[2]는 <code class="language-plaintext highlighter-rouge">0</code>으로 초기화를 해준다. (int 벡터의 경우)</p>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET