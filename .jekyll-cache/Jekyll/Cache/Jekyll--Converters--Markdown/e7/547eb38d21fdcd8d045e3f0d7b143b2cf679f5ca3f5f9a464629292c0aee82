I"=h<h1 id="-게임-맵-최단거리">📌 게임 맵 최단거리</h1>

<blockquote>
  <p>난이도 ⭐⭐</p>
</blockquote>

<h2 id="-문제">🚀 문제</h2>

<p><img src="https://user-images.githubusercontent.com/42318591/109966623-d6792600-7d33-11eb-979d-ed2686765b3a.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/42318591/109966712-ea248c80-7d33-11eb-8a13-083c7352f1f2.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/42318591/109966741-f0b30400-7d33-11eb-9d86-6e6001864483.png" alt="image" /></p>

<p><br /></p>

<h2 id="-내-풀이">🚀 내 풀이</h2>

<h3 id="-첫-번째-풀이-">🔥 첫 번째 풀이 ⭕</h3>

<ul>
  <li>BFS 사용한 이유
    <ul>
      <li>가중치가 없다.</li>
      <li>BFS를 사용하면 출발지로부터 각 노드까지의 방문은 <u>최단 경로</u>로 이루어질 수 밖에 없다.
        <ul>
          <li><strong>큐를 사용하여 “너비 우선 탐색”을 하기 때문에 자연스럽게 출발지로부터 거리 순으로 방문이 되기 때문이다.</strong></li>
          <li>그리고 도착지가 되는 노드의 최단 경로만 답으로 도출하면 된다.
            <ul>
              <li>처음엔 도착지가 되는 노드의 최단 경로 딱 하나만 구하면 되나 싶었는데, 사실 도착지 노드의 최단 경로는 곧 다른 노드들로부터의 최단 경로에서 구해지는거라 어차피 다른 노드들의 최단 경로도 필요 하다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>도착지 노드 하나가 확실해서 처음엔 A* 알고리즘을 생각했었다. 근데 A* 알고리즘을 적용해보기엔 휴리스틱을 어떻게 해야할지 까다로웠다. 그냥 가중치도 없겠다, 모든 노드를 탐색하겠다는 생각으로 BFS 를 선택하였다. 그리고 다행히도 효율성 테스트에도 통과했다. 깊이 우선 탐색이 아닌 <strong>너비 우선 탐색이기에 되돌아 오는 과정이 없어서 모든 노드를 탐색하더라도 O(m * n) 시간 복잡도를 넘지 않을 것 같다.</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;queue&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Pos</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">Pos</span><span class="p">(</span><span class="kt">int</span> <span class="n">_y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_x</span><span class="p">)</span> <span class="p">{</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_y</span><span class="p">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">_x</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">maps</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">maps</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="c1">// n 행</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="c1">// m 열</span>
    <span class="c1">// 방향 (시계방향으로 설정했다. 상우하좌. 방향 순서에 따라 노드의 방문 순서가 달라질 수 있다. 일반 큐라 큐에 들어간 순서대로 나오기 때문)</span>
    <span class="kt">int</span> <span class="n">deltaY</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span> 
    <span class="kt">int</span> <span class="n">deltaX</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">checked</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">));</span> <span class="c1">// 예약 된 적이 있는지. 큐에 삽입된적이 있는 위치일 때 true, 즉 이미 출발지로부터의 최단 거리가 업뎃 되어있는 </span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">));</span> <span class="c1">// 출발지로부터 해당 위치까지의 최단 거리</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">Pos</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span> <span class="c1">// 큐</span>

    <span class="cm">/* 출발지는 예약 작업을 할 수 없고 바로 방문해야 하니 미리 작업 */</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Pos</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>  <span class="c1">// 큐에 넣기</span>
    <span class="n">checked</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 예약</span>
    <span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 출발지의 거리는 1</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="cm">/* 방문 */</span>
        <span class="n">Pos</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">nowY</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nowX</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>

        <span class="cm">/* 예약 */</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 방문한 곳을 기준으로 상우하좌 4가지 방향에 있는 곳들 예약 처리</span>
            <span class="kt">int</span> <span class="n">nextY</span> <span class="o">=</span> <span class="n">nowY</span> <span class="o">+</span> <span class="n">deltaY</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">nextX</span> <span class="o">=</span> <span class="n">nowX</span> <span class="o">+</span> <span class="n">deltaX</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

            <span class="cm">/* 다음에 방문할 수 잇는지, 즉 예약할 수 있는지 체크 */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nextY</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nextY</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">nextX</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nextX</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span> <span class="c1">// 1. 맵을 벗어난다면 예약할 수 없는 방향</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="n">nextY</span><span class="p">][</span><span class="n">nextX</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 2. 벽이라면 예약할 수 없는 방향</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">checked</span><span class="p">[</span><span class="n">nextY</span><span class="p">][</span><span class="n">nextX</span><span class="p">])</span> <span class="c1">// 3. 이미 예약된적이 있다면 예약할 수 없는 방향</span>
                <span class="k">continue</span><span class="p">;</span>
            
            <span class="cm">/* 다음에 방문할 수 있는 곳이니 큐에 넣어 예약하기! -&gt; ⭐그와 동시에 최단거리 업데이트⭐ */</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Pos</span><span class="p">(</span><span class="n">nextY</span><span class="p">,</span> <span class="n">nextX</span><span class="p">));</span>
            <span class="n">checked</span><span class="p">[</span><span class="n">nextY</span><span class="p">][</span><span class="n">nextX</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">nextY</span><span class="p">][</span><span class="n">nextX</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">nowY</span><span class="p">][</span><span class="n">nowX</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 최단 거리 업데이트 (방문 노드에서 +1 하면 최단거리!)</span>
        <span class="p">}</span>
    <span class="p">}</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">checked</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="c1">// 도착지가 한번도 큐에 들어갔던적이 없다면 애초에 갈 수 없었던 곳이니 -1 리턴</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">dist</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// 도착지의 최단경로 리턴</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>BFS를 사용하면 <u>출발지 노드로부터 각각의 모든 노드들까지의 최단 경로로서 이동하게 된다.</u></li>
  <li>각 노드까지의 최단 경로는 각 노드마다 딱 한번만 업데이트 된다. dist[i][j] 는 딱 한번만 업데이트 된다.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="cm">/* 다음에 방문할 수 있는 곳이니 큐에 넣어 예약하기! -&gt; ⭐그와 동시에 최단거리 업데이트⭐ */</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Pos</span><span class="p">(</span><span class="n">nextY</span><span class="p">,</span> <span class="n">nextX</span><span class="p">));</span>
            <span class="n">checked</span><span class="p">[</span><span class="n">nextY</span><span class="p">][</span><span class="n">nextX</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">nextY</span><span class="p">][</span><span class="n">nextX</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">nowY</span><span class="p">][</span><span class="n">nowX</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>각 노드까지의 <strong>최단경로 업데이트는 큐에 넣을 때(예약 시) 이루어져야 한다.</strong>
    <ul>
      <li><u>현재 방문 중인 노드까지의 최단 경로에서 1 만 더해주면 되기 때문에</u> 예약 작업에서 큐에 들어가자마자 최단 경로를 미리 업데이트 해주는 것이다. (큐에서 빠져나와 방문되기 전)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h4 id="-방문-순서">✈ 방문 순서</h4>

<p><img src="https://user-images.githubusercontent.com/42318591/109969605-73898e00-7d37-11eb-86a5-31b4373d8f2d.png" alt="image" /></p>

<p>각각 예제 2, 예제 1의 노드별 BFS 방식으로 <strong>방문한 순서</strong>는 위와 같다.</p>

<p><br /></p>

<h4 id="-최단-거리">✈ 최단 거리</h4>

<p><img src="https://user-images.githubusercontent.com/42318591/109970748-c44db680-7d38-11eb-9fa7-9f5d63424671.png" alt="image" /></p>

<p>BFS 를 모두 끝내면 예제 1 의 모든 노드의 <strong>출발지로부터의 최단 거리</strong>는 위와 같다.</p>

<p><br /></p>

<h3 id="-두-번째-풀이-">🔥 두 번째 풀이 ⭕</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;queue&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Pos</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dist</span><span class="p">;</span> <span class="c1">// 거리</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">maps</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    
    <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">maps</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">deltaY</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="kt">int</span> <span class="n">deltaX</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">checked</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">));</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">Pos</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>

    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">});</span> <span class="c1">// 출발지의 거리는 1</span>
    <span class="n">checked</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">Pos</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        
        <span class="kt">int</span> <span class="n">nowY</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nowX</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">now_dist</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="n">dist</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">nowY</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nowX</span> <span class="o">==</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 목적지 원소(Pos) Pop될시 거리를 answer 에 옮겨주기</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="n">now_dist</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">nextY</span> <span class="o">=</span> <span class="n">nowY</span> <span class="o">+</span> <span class="n">deltaY</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">nextX</span> <span class="o">=</span> <span class="n">nowX</span> <span class="o">+</span> <span class="n">deltaX</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">nextY</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nextY</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">nextX</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nextX</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="n">nextY</span><span class="p">][</span><span class="n">nextX</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">checked</span><span class="p">[</span><span class="n">nextY</span><span class="p">][</span><span class="n">nextX</span><span class="p">])</span>
                <span class="k">continue</span><span class="p">;</span>

            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">nextY</span><span class="p">,</span> <span class="n">nextX</span><span class="p">,</span> <span class="n">now_dist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">});</span> <span class="c1">// 거리 저장</span>
            <span class="n">checked</span><span class="p">[</span><span class="n">nextY</span><span class="p">][</span><span class="n">nextX</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
        
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>첫번째 풀이와 차이점이 있다면 이 풀이는 <code class="language-plaintext highlighter-rouge">dist</code> 배열을 사용하지 않고 거리를 <code class="language-plaintext highlighter-rouge">Pos</code> 구조체 안에 저장했다는 것이다. 대신, 이렇게 하려면 큐에 들어가는 원소(구조체) 내부에 거리가 저장되는 것이기 때문에</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">answer</code>의 초기값은 -1</li>
  <li>큐의 원소인 <code class="language-plaintext highlighter-rouge">Pos</code> 구조체 내부의 <code class="language-plaintext highlighter-rouge">dist</code> 멤버에 거리가 저장되기 떄문에 <code class="language-plaintext highlighter-rouge">Pos</code> 구조체가 목적지일 때를 캐치하여 그 거리를 <code class="language-plaintext highlighter-rouge">answer</code>에 옮겨주는 작업을 추가로 해주어야 한다.
    <ul>
      <li>배열 테이블에 모든 지점별 거리들이 저장되는게 아니기 떄문이다. 원소(Pos 구조체 인스턴스)에 거리가 저장되어 있기 때문에 다음 while 문에서 큐에서 다른 원소를 Pop 함에 따라 이전 원소(Pos)의 거리는 잊혀진다. 따라서 목적지 Pos 에 도달시 따로 거리를 다른 변수에 저장해두는 작업이 필요하다.</li>
    </ul>
  </li>
  <li>목적지에 도달하지 못했다면(즉, while문 안에서 if 에 걸리지 못했다면) <code class="language-plaintext highlighter-rouge">answer</code>는 그대로 -1 인 상태일 것이다.</li>
</ul>

<p><a href="https://ansohxxn.github.io/algorithm/bfsdijkstra/">(C++) BFS 와 다익스트라의 거리 저장 및 업뎃</a></p>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET