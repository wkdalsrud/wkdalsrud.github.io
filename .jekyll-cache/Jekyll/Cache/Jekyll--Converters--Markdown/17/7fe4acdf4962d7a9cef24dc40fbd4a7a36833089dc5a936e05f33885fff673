I"2<p class="notice--warning">인프런에 있는 Rookiss님의 <strong>[C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part2: 자료구조와 알고리즘</strong> 강의를 듣고 정리한 필기입니다. 😀<br />
<a href="(https://www.inflearn.com/course/유니티-MMORPG-유니티-개발-part2#)">🌜 강의 들으러 가기 Click</a></p>

<h1 id="chapter-5-트리">Chapter 5. 트리</h1>

<h2 id="-힙">🚖 힙</h2>

<h3 id="이진-트리">이진 트리</h3>

<p><strong>이진 트리</strong> 👉 모든 노드들이 자식 노드를 최대 2 개까지만 가지는 트리</p>

<ul>
  <li>이진 트리의 종류
    <ol>
      <li>이진 검색 트리 (Binary Search Tree)
        <ul>
          <li>항상 왼쪽 자식은 나보다 작고 오른쪽 자식은 나보다 크다.</li>
        </ul>
      </li>
      <li>힙 트리 (Heap Tree)
        <ul>
          <li>Max Heap Tree : 항상 부모가 자식보다 크다. 따라서 루트는 최대값이다.</li>
          <li>Min Heap Tree : 항상 부모가 자식보다 작다. 따라서 루트는 최소값이다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<p><br /></p>

<h4 id="이진-검색-트리">이진 검색 트리</h4>

<p><img src="https://user-images.githubusercontent.com/42318591/95440560-0e9e5780-0994-11eb-88e4-58dceb73f237.png" alt="image" /></p>

<blockquote>
  <p>다음과 같은 조건이 적용된 이진트리.</p>
</blockquote>

<ol>
  <li>왼쪽을 타고 가면 현재 값보다 작다. 👉 왼쪽 자식 노드는 부모 노드보다 작아야 한다.
    <ul>
      <li>루트를 기준으로 왼쪽 서브트리 노드의 데이터들은 전부 루트보다 작은 값을 가진다.</li>
    </ul>
  </li>
  <li>오른쪽을 타고 가면 현재 값보다 크다. 👉 오른쪽 자식 노드는 부모 노드보다 커야 한다.
    <ul>
      <li>루트를 기준으로 오른쪽 서브 트리 노드의 데이터들은 전부 루트보다 큰 값을 가진다.</li>
    </ul>
  </li>
</ol>

<p><code class="language-plaintext highlighter-rouge">이진 검색 트리</code>는 이러한 구성을 가지기 때문에 해당 데이터를 가진 노드를 검색하는게 빠르다. <u>찾으려는 값보다 작으면 왼쪽으로 내려가고, 찾으려는 값보다 크면 오른쪽으로 내려가면 되기 때문.</u></p>

<ul>
  <li>이진 검색 트리에 값을 추가할 때
    <ul>
      <li>그냥 무식하게 추가하면 한쪽으로 기울어져서 균형이 깨진다.
        <ul>
          <li>예를 들어 트리에 있는 노드들보다 큰 값만 계속해서 추가한다면 트리가 한쪽으로만 쭉 길어질 수 있음. 이러면 리스트 같은 선형 자료구조와 다를게 없어져 이진 검색트리의 빠른 검색 이점이 사라질 수 있다.</li>
        </ul>
      </li>
      <li>👉 <strong>추가, 삭제</strong>시, <u>트리 재배치를 통해 균형을 유지하는 것이 과제</u></li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/42318591/95440599-19f18300-0994-11eb-8975-ad704c809148.png" alt="image" /></p>

<p><br /></p>

<h4 id="힙-트리-">힙 트리 ✨</h4>

<blockquote>
  <p>다음과 같은 조건이 적용된 이진트리.</p>
</blockquote>

<blockquote>
  <p>이진 검색트리보단 제약 수준이 낮다. 이진 검색트리와 달리 양쪽 자식간에는 특별한 조건이 없음.</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/42318591/95440627-2249be00-0994-11eb-99c5-0e1981dcced5.png" alt="image" /></p>

<ul>
  <li>힙 트리
    <ul>
      <li>조건 1️⃣
        <ul>
          <li><em>max heap</em> 부모 노드가 가진 값은 항상 자식 노드가 가진 값보다 크다. 👉 그냥 부모가 자식들보다 크면 된다.
            <ul>
              <li>이 힙 트리의 <u>루트 값은 언제나 최대값</u>이다.</li>
            </ul>
          </li>
          <li><em>min heap</em> 인 경우엔 부모 노드가 가진 값은 항상 자식 노드가 가진 값보다 작다. 👉 그냥 부모가 자식들보다 작으면 된다.
            <ul>
              <li>이 힙 트리의 <u>루트 값은 언제나 최소값</u>이다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><strong>제약 조건</strong>
        <ol>
          <li>마지막 레벨을 제외한 모든 레벨에 노드가 꽉 차있다.</li>
          <li>마지막 레벨에 노드가 있을 때는, 항상 왼쪽부터 순서대로 채워야 한다.</li>
        </ol>
      </li>
      <li>조건 2️⃣
        <ul>
          <li>이 제약 조건 때문에 노드의 개수를 알면, 트리 구조는 무조건 확정할 수 있다.
            <ul>
              <li>만약 데이터 개수가 5 개인 경우, 힙트리 구조는 아래와 같은 구조로 확정 된다.</li>
              <li>따라서 <u>힙 구조는 데이터 개수만 알면 언제나 확정되기 때문에 배열을 이용해서 힙 구조를 바로 표현할 수 있다. </u>
                <ul>
                  <li>인덱스 <code class="language-plaintext highlighter-rouge">i</code> 노드의 왼쪽 자식 노드의 인덱스는 <code class="language-plaintext highlighter-rouge">2 * i + 1</code></li>
                  <li>인덱스 <code class="language-plaintext highlighter-rouge">i</code> 노드의 왼쪽 자식 노드의 인덱스는 <code class="language-plaintext highlighter-rouge">2 * i + 2</code></li>
                  <li>인덱스 <code class="language-plaintext highlighter-rouge">i</code> 노드의 부모 노드의 인덱스는 <code class="language-plaintext highlighter-rouge">(i - 1) / 2</code>  (정수이므로 소수점 버림. 몫만.)</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><u>힙 트리는 배열로 구현할 수 있다.</u></p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/42318591/95440664-2b3a8f80-0994-11eb-92f0-c84570972d97.png" alt="image" /></p>

<h5 id="추가하기">추가하기</h5>

<ol>
  <li>조건 2️⃣ 에 의하여 👉 노드 개수를 알면 트리 구조를 무조건 확정지을 수 있으므로 <u>우선 트리 구조부터 맞춰준다.</u>
    <ul>
      <li>마지막 레벨에 추가하되 왼쪽에서부터 순서대로 채워넣기</li>
    </ul>
  </li>
  <li>조건 1️⃣ 에 의하여 👉 부모 노드는 항상 자식 노드보다 커야 하므로 이 조건이 만족 될 때까지 자리를 서로 뒤 바꿔 <u>올라가게 한다.</u></li>
</ol>

<p><img src="https://user-images.githubusercontent.com/42318591/95440698-32619d80-0994-11eb-9152-c3f782f98923.png" alt="image" /></p>

<h5 id="최대값-꺼내기루트-삭제하기">최대값 꺼내기(루트 삭제하기)</h5>

<ol>
  <li>최대값을 먼저 제거한다. 👉 힙 트리 모양이 망가지므로 다시 재정비 해주어야 한다.</li>
  <li>조건 2️⃣ 에 의하여 <u>제일 마지막에 위치한 데이터를 빈 루트 자리로 옮긴다.</u></li>
  <li>조건 1️⃣ 에 의하여 👉 부모 노드는 항상 자식 노드보다 커야 하므로 이 조건이 만족 될 때까지 <u>자리를 서로 뒤 바꿔 <u>내려가게 한다.</u></u></li>
</ol>

<p><img src="https://user-images.githubusercontent.com/42318591/95440727-3988ab80-0994-11eb-95c7-772256f01211.png" alt="image" /></p>

<p><br /></p>

<h2 id="-우선순위-큐-구현">🚖 우선순위 큐 구현</h2>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Excercise</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">PriorityQueue</span>
    <span class="p">{</span>
        <span class="c1">// 힙 트리는 배열로 관리할 수 있다.</span>
        <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">_heap</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Push</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 힙의 맨 끝에 새로운 데이터를 삽입한다.</span>
            <span class="n">_heap</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

            <span class="kt">int</span> <span class="n">now</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">.</span><span class="n">Count</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>  <span class="c1">// 추가한 노드의 위치. 힙의 맨 끝에서 시작.</span>
            
            <span class="c1">// 위로 도장 깨기 시작</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">now</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">next</span> <span class="p">=</span> <span class="p">(</span><span class="n">now</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>  <span class="c1">// 부모 노드</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">_heap</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">])</span>  <span class="c1">// 부모 노드와 비교</span>
                    <span class="k">break</span><span class="p">;</span>

                <span class="c1">// 두 값을 서로 자리 바꿈</span>
                <span class="kt">int</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="n">now</span><span class="p">];</span>
                <span class="n">_heap</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
                <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="p">=</span> <span class="n">temp</span><span class="p">;</span>

                <span class="c1">// 검사 위치로 이동한다.</span>
                <span class="n">now</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">int</span> <span class="nf">Pop</span><span class="p">()</span>  <span class="c1">// 최대값(루트)을 뽑아낸다.</span>
        <span class="p">{</span>
            <span class="c1">// 반환할 데이터를 따로 저장</span>
            <span class="kt">int</span> <span class="n">ret</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>

            <span class="c1">// 마지막 데이터를 루트로 이동시킨다.</span>
            <span class="kt">int</span> <span class="n">lastIndex</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">.</span><span class="n">Count</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
            <span class="n">_heap</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="n">lastIndex</span><span class="p">];</span>
            <span class="n">_heap</span><span class="p">.</span><span class="nf">RemoveAt</span><span class="p">(</span><span class="n">lastIndex</span><span class="p">);</span>
            <span class="n">lastIndex</span><span class="p">--;</span>

            <span class="c1">// 아래로 도장 깨기 시작</span>
            <span class="kt">int</span> <span class="n">now</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">left</span> <span class="p">=</span> <span class="m">2</span> <span class="p">*</span> <span class="n">now</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">right</span> <span class="p">=</span> <span class="m">2</span> <span class="p">*</span> <span class="n">now</span> <span class="p">+</span> <span class="m">2</span><span class="p">;</span>

                <span class="kt">int</span> <span class="n">next</span> <span class="p">=</span> <span class="n">now</span><span class="p">;</span>
                <span class="c1">// 왼쪽 값이 현재값보다 크면, 왼쪽으로 이동</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="p">&lt;=</span> <span class="n">lastIndex</span> <span class="p">&amp;&amp;</span> <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">_heap</span><span class="p">[</span><span class="n">left</span><span class="p">])</span>
                    <span class="n">next</span> <span class="p">=</span> <span class="n">left</span><span class="p">;</span>
                <span class="c1">// 오른쪽 값이 현재값(왼쪽 이동 포함)보다 크면, 오른쪽으로 이동</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="p">&lt;=</span> <span class="n">lastIndex</span> <span class="p">&amp;&amp;</span> <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">_heap</span><span class="p">[</span><span class="n">right</span><span class="p">])</span>
                    <span class="n">next</span> <span class="p">=</span> <span class="n">right</span><span class="p">;</span>

                <span class="c1">// 왼쪽/오른쪽 모두 현재값보다 작으면 종료</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="p">==</span> <span class="n">now</span><span class="p">)</span>
                    <span class="k">break</span><span class="p">;</span>

                <span class="c1">// 두 값 서로 자리 바꿈</span>
                <span class="kt">int</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="n">now</span><span class="p">];</span>
                <span class="n">_heap</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
                <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="p">=</span> <span class="n">temp</span><span class="p">;</span>

                <span class="c1">// 검사 위치로 이동한다.</span>
                <span class="n">now</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">int</span> <span class="nf">Count</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">_heap</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">PriorityQueue</span> <span class="n">q</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PriorityQueue</span><span class="p">();</span>
            <span class="n">q</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="m">20</span><span class="p">);</span>
            <span class="n">q</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>
            <span class="n">q</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="m">30</span><span class="p">);</span>
            <span class="n">q</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="m">90</span><span class="p">);</span>
            <span class="n">q</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="m">40</span><span class="p">);</span>

            <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="nf">Count</span><span class="p">()</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="c1">// 90 40 30 20 10 출력</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="nf">Pop</span><span class="p">());</span>  
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<blockquote>
  <p>우선순위 큐 자료구조는 힙 트리를 사용한다.</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">우선순위 큐</code>
    <ul>
      <li>들어간지 가장 오래된게 나오는 선입선출 방식인 일반 큐와 달리, 들어간 순서와는 상관없이 가장 큰 값을 가진 데이터가 빠져나오게 된다.
        <ul>
          <li>👉 <code class="language-plaintext highlighter-rouge">Max Heap Tree</code>를 우선순위 큐 자료구조로서 사용하면 된다.
            <ul>
              <li>루트 노드는 언제나 최대값이 오도록 힙 트리 구조 유지.</li>
              <li>데이터를 뽑을 땐 루트 노드 데이터를 뽑으면 됨.</li>
            </ul>
          </li>
          <li>Min Heap 은 <code class="language-plaintext highlighter-rouge">Max Heap Tree</code>로 구현된 우선순위 큐에 원하는 데이터들을 <code class="language-plaintext highlighter-rouge">-</code> 붙여 음수로 넣은 후 꺼내고 나서 다시 <code class="language-plaintext highlighter-rouge">-</code>을 붙여 원래대로 양수로 만들어 사용할 수도 있다.
            <ul>
              <li>음수는 절대값이 작은게 큰 것이라는 점을 이용하여.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>힙 트리는 배열로 나타낼 수 있다.
    <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">_heap</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="push--우선순위-큐에-노드-추가">Push : 우선순위 큐에 노드 추가</h3>

<blockquote>
  <p>힙 트리의 추가 과정 그림 위에서 참고!</p>
</blockquote>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="k">void</span> <span class="nf">Push</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 힙의 맨 끝에 새로운 데이터를 삽입한다.</span>
            <span class="n">_heap</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

            <span class="kt">int</span> <span class="n">now</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">.</span><span class="n">Count</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>  <span class="c1">// 추가한 노드의 위치. 힙의 맨 끝에서 시작.</span>
            
            <span class="c1">// 위로 도장 깨기 시작</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">now</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">next</span> <span class="p">=</span> <span class="p">(</span><span class="n">now</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>  <span class="c1">// 부모 노드</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">_heap</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">])</span>  <span class="c1">// 부모 노드와 비교</span>
                    <span class="k">break</span><span class="p">;</span>

                <span class="c1">// 두 값을 서로 자리 바꿈</span>
                <span class="kt">int</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="n">now</span><span class="p">];</span>
                <span class="n">_heap</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
                <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="p">=</span> <span class="n">temp</span><span class="p">;</span>

                <span class="c1">// 검사 위치로 이동한다.</span>
                <span class="n">now</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>삽입은 아래에서 부터 위로 올라가며 스왑해나간다.</p>
</blockquote>

<ul>
  <li>새로운 데이터는 힙의 맨 끝에 삽입한다.
    <ul>
      <li>힙 트리는 배열로 관리되므로 배열에 추가하면 된다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">now</code>에는 처음에 추가한 데이터의 바뀌어 가는 인덱스
    <ul>
      <li><code class="language-plaintext highlighter-rouge">_heap.Count - 1</code> 에서 시작</li>
    </ul>
  </li>
  <li><em>부모 &gt; 자식</em> 관계가 완성될 때까지 위로 올라가며 추가한 데이터를 스왑해 나간다. 제자리를 찾기 위한 과정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">next</code>는 현재의 <code class="language-plaintext highlighter-rouge">now</code>의 부모</li>
      <li><em>_heap[now] &lt; _heap[next]</em>
        <ul>
          <li>힙 트리 조건(<em>부모 &gt; 자식</em>)을 만족하는 제 자리를 찾았으니 끝냄</li>
        </ul>
      </li>
      <li><em>_heap[now] &gt;= _heap[next]</em>
        <ul>
          <li>자식이 부모보다 더 크므로 안된다. 제 자리를 찾아 올라가야 하므로 둘이 스왑한다.
            <ul>
              <li>스왑한 후</li>
              <li>위로 올라간다. <code class="language-plaintext highlighter-rouge">now = next</code></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="pop--우선순위-큐에서-최대값-뽑기--루트-노드-삭제">Pop : 우선순위 큐에서 최대값 뽑기 👉 루트 노드 삭제</h3>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="kt">int</span> <span class="nf">Pop</span><span class="p">()</span>  <span class="c1">// 최대값(루트)을 뽑아낸다.</span>
        <span class="p">{</span>
            <span class="c1">// 반환할 데이터를 따로 저장</span>
            <span class="kt">int</span> <span class="n">ret</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>

            <span class="c1">// 마지막 데이터를 루트로 이동시킨다.</span>
            <span class="kt">int</span> <span class="n">lastIndex</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">.</span><span class="n">Count</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
            <span class="n">_heap</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="n">lastIndex</span><span class="p">];</span>
            <span class="n">_heap</span><span class="p">.</span><span class="nf">RemoveAt</span><span class="p">(</span><span class="n">lastIndex</span><span class="p">);</span>
            <span class="n">lastIndex</span><span class="p">--;</span>

            <span class="c1">// 아래로 도장 깨기 시작</span>
            <span class="kt">int</span> <span class="n">now</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">left</span> <span class="p">=</span> <span class="m">2</span> <span class="p">*</span> <span class="n">now</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">right</span> <span class="p">=</span> <span class="m">2</span> <span class="p">*</span> <span class="n">now</span> <span class="p">+</span> <span class="m">2</span><span class="p">;</span>

                <span class="kt">int</span> <span class="n">next</span> <span class="p">=</span> <span class="n">now</span><span class="p">;</span>
                <span class="c1">// 왼쪽 값이 현재값보다 크면, 왼쪽으로 이동</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="p">&lt;=</span> <span class="n">lastIndex</span> <span class="p">&amp;&amp;</span> <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">_heap</span><span class="p">[</span><span class="n">left</span><span class="p">])</span>
                    <span class="n">next</span> <span class="p">=</span> <span class="n">left</span><span class="p">;</span>
                <span class="c1">// 오른쪽 값이 현재값(왼쪽 이동 포함)보다 크면, 오른쪽으로 이동</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="p">&lt;=</span> <span class="n">lastIndex</span> <span class="p">&amp;&amp;</span> <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">_heap</span><span class="p">[</span><span class="n">right</span><span class="p">])</span>
                    <span class="n">next</span> <span class="p">=</span> <span class="n">right</span><span class="p">;</span>

                <span class="c1">// 왼쪽/오른쪽 모두 현재값보다 작으면 종료</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="p">==</span> <span class="n">now</span><span class="p">)</span>
                    <span class="k">break</span><span class="p">;</span>

                <span class="c1">// 두 값 서로 자리 바꿈</span>
                <span class="kt">int</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="n">now</span><span class="p">];</span>
                <span class="n">_heap</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
                <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="p">=</span> <span class="n">temp</span><span class="p">;</span>

                <span class="c1">// 검사 위치로 이동한다.</span>
                <span class="n">now</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>힙 트리의 루트 노드는 늘 최대값이다. 모든 부모 노드는 자식 노드들보다 크기 때문이다.</p>
</blockquote>

<blockquote>
  <p>루트 노드 삭제 및 리턴인 Pop 은 아래로 내려가며 스왑해나간다.</p>
</blockquote>

<ul>
  <li>루트 노드 <code class="language-plaintext highlighter-rouge">_heap[0]</code> 를 리턴해야 하니까 삭제 전에 <code class="language-plaintext highlighter-rouge">ret</code>에 보존해두기
    <ul>
      <li>나중에 이를 리턴하고 끝낸다.</li>
    </ul>
  </li>
  <li>마지막 데이터를 빈 루트 노드 자리로 이동시킨다.
    <ul>
      <li>루트 노드에 마지막 노드 복사</li>
      <li>마지막 노드 삭제</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">lastIndex</code>는 힙 트리의 마지막 인덱스</li>
  <li><code class="language-plaintext highlighter-rouge">now</code>는 루트 노드에 올라오게 된 마지막 데이터가 제 자리를 찾아가는 과정마다 위치하게 될 인덱스를 저장
    <ul>
      <li>루트에서 시작하므로 0 에서 시작</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">next</code>에 다음에 내려갈 위치</li>
  <li>현재 <code class="language-plaintext highlighter-rouge">now</code>의 왼쪽 자식 <code class="language-plaintext highlighter-rouge">left</code></li>
  <li>현재 <code class="language-plaintext highlighter-rouge">now</code>의 오른쪽 자식 <code class="language-plaintext highlighter-rouge">right</code></li>
  <li>루트에 올라오게 된 마지막 데이터를 <em>부모 &gt; 자식</em> 관계가 완성될 때까지 아래로 내려가며 스왑해 나간다. 제자리를 찾기 위한 과정
    <ul>
      <li>인덱스를 넘지 않기 위해 <code class="language-plaintext highlighter-rouge">left</code>, <code class="language-plaintext highlighter-rouge">right</code>가 <code class="language-plaintext highlighter-rouge">lastIndex</code> 보다 작은지를 검사</li>
      <li>왼쪽 자식이 더 크다면 <code class="language-plaintext highlighter-rouge">next</code>를 <code class="language-plaintext highlighter-rouge">left</code>로 업데이트</li>
      <li>오른쪽 자식이 더 크다면 <code class="language-plaintext highlighter-rouge">next</code>를 <code class="language-plaintext highlighter-rouge">right</code>로 업데이트
        <ul>
          <li>왼쪽 자식보다 오른쪽 자식이 더 크다면 <code class="language-plaintext highlighter-rouge">next</code>는 오른쪽 자식으로 또 업데이트 된다.</li>
          <li><u>else if 가 아닌 그냥 if 이기 때문에</u></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">next</code>가 업데이트 되지 않아 여전히 <code class="language-plaintext highlighter-rouge">now</code>라면 왼쪽 자식 오른쪽 자식 둘 다 현재 값보다 작다는 의미이므로 제자리를 찾았으니 저장해두었던 예전 루트 노드 <code class="language-plaintext highlighter-rouge">ret</code>을 리턴하고 종료.</li>
  <li>스왑한 후 아래로 내려간다. <code class="language-plaintext highlighter-rouge">now = next</code></li>
</ul>

<p>힙 트리(우선순위 큐)의 추가/삭제 연산은 \(O(logN)\) 시간 복잡도를 가진다. 즉, 트리의 높이에 따라 시간 복잡도가 결정 된다. 타고 내려가고 타고 올라가기 때문에.</p>

<h3 id="count">Count</h3>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="kt">int</span> <span class="nf">Count</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">_heap</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>우선순위 큐의 데이터 노드 개수는 힙 배열의 크기와 같음.</p>

<p><br /></p>

<h2 id="-제네릭한-우선순위-큐-구현">🚖 제네릭한 우선순위 큐 구현</h2>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Excercise</span>
<span class="p">{</span>
    
    <span class="k">class</span> <span class="nc">Knight</span> <span class="p">:</span> <span class="n">IComparable</span><span class="p">&lt;</span><span class="n">Knight</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="kt">int</span> <span class="nf">CompareTo</span><span class="p">(</span><span class="n">Knight</span> <span class="n">other</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// id 멤버를 기준으로 크기를 비교</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="p">==</span> <span class="n">other</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
                <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">id</span> <span class="p">&gt;</span> <span class="n">other</span><span class="p">.</span><span class="n">id</span> <span class="p">?</span> <span class="m">1</span> <span class="p">:</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">class</span> <span class="nc">PriorityQueue</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">IComparable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="c1">// 힙 트리는 배열로 관리할 수 있다.</span>
        <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">_heap</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Push</span><span class="p">(</span><span class="n">T</span> <span class="n">data</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 힙의 맨 끝에 새로운 데이터를 삽입한다.</span>
            <span class="n">_heap</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

            <span class="kt">int</span> <span class="n">now</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">.</span><span class="n">Count</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>  <span class="c1">// 추가한 노드의 위치. 힙의 맨 끝에서 시작.</span>
            
            <span class="c1">// 위로 도장 깨기 시작</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">now</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">next</span> <span class="p">=</span> <span class="p">(</span><span class="n">now</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>  <span class="c1">// 부모 노드</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">_heap</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="nf">CompareTo</span><span class="p">(</span><span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">])</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>  <span class="c1">// 부모 노드와 비교</span>
                    <span class="k">break</span><span class="p">;</span>

                <span class="c1">// 두 값을 서로 자리 바꿈</span>
                <span class="n">T</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="n">now</span><span class="p">];</span>
                <span class="n">_heap</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
                <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="p">=</span> <span class="n">temp</span><span class="p">;</span>

                <span class="c1">// 검사 위치로 이동한다.</span>
                <span class="n">now</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">T</span> <span class="nf">Pop</span><span class="p">()</span>  <span class="c1">// 최대값(루트)을 뽑아낸다.</span>
        <span class="p">{</span>
            <span class="c1">// 반환할 데이터를 따로 저장</span>
            <span class="n">T</span> <span class="n">ret</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>

            <span class="c1">// 마지막 데이터를 루트로 이동시킨다.</span>
            <span class="kt">int</span> <span class="n">lastIndex</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">.</span><span class="n">Count</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
            <span class="n">_heap</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="n">lastIndex</span><span class="p">];</span>
            <span class="n">_heap</span><span class="p">.</span><span class="nf">RemoveAt</span><span class="p">(</span><span class="n">lastIndex</span><span class="p">);</span>
            <span class="n">lastIndex</span><span class="p">--;</span>

            <span class="c1">// 아래로 도장 깨기 시작</span>
            <span class="kt">int</span> <span class="n">now</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">left</span> <span class="p">=</span> <span class="m">2</span> <span class="p">*</span> <span class="n">now</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">right</span> <span class="p">=</span> <span class="m">2</span> <span class="p">*</span> <span class="n">now</span> <span class="p">+</span> <span class="m">2</span><span class="p">;</span>

                <span class="kt">int</span> <span class="n">next</span> <span class="p">=</span> <span class="n">now</span><span class="p">;</span>
                <span class="c1">// 왼쪽 값이 현재값보다 크면, 왼쪽으로 이동</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="p">&lt;=</span> <span class="n">lastIndex</span> <span class="p">&amp;&amp;</span> <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">].</span><span class="nf">CompareTo</span><span class="p">(</span><span class="n">_heap</span><span class="p">[</span><span class="n">left</span><span class="p">])</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
                    <span class="n">next</span> <span class="p">=</span> <span class="n">left</span><span class="p">;</span>
                <span class="c1">// 오른쪽 값이 현재값(왼쪽 이동 포함)보다 크면, 오른쪽으로 이동</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="p">&lt;=</span> <span class="n">lastIndex</span> <span class="p">&amp;&amp;</span> <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">].</span><span class="nf">CompareTo</span><span class="p">(</span><span class="n">_heap</span><span class="p">[</span><span class="n">right</span><span class="p">])</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
                    <span class="n">next</span> <span class="p">=</span> <span class="n">right</span><span class="p">;</span>

                <span class="c1">// 왼쪽/오른쪽 모두 현재값보다 작으면 종료</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="p">==</span> <span class="n">now</span><span class="p">)</span>
                    <span class="k">break</span><span class="p">;</span>

                <span class="c1">// 두 값 서로 자리 바꿈</span>
                <span class="n">T</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="n">now</span><span class="p">];</span>
                <span class="n">_heap</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="p">=</span> <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
                <span class="n">_heap</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="p">=</span> <span class="n">temp</span><span class="p">;</span>

                <span class="c1">// 검사 위치로 이동한다.</span>
                <span class="n">now</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">int</span> <span class="nf">Count</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">_heap</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">PriorityQueue</span><span class="p">&lt;</span><span class="n">Knight</span><span class="p">&gt;</span> <span class="n">q</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="p">&lt;</span><span class="n">Knight</span><span class="p">&gt;();</span>
            <span class="n">q</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="k">new</span> <span class="nf">Knight</span><span class="p">()</span> <span class="p">{</span> <span class="n">id</span> <span class="p">=</span> <span class="m">20</span> <span class="p">});</span>
            <span class="n">q</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="k">new</span> <span class="nf">Knight</span><span class="p">()</span> <span class="p">{</span> <span class="n">id</span> <span class="p">=</span> <span class="m">10</span> <span class="p">});</span>
            <span class="n">q</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="k">new</span> <span class="nf">Knight</span><span class="p">()</span> <span class="p">{</span> <span class="n">id</span> <span class="p">=</span> <span class="m">30</span> <span class="p">});</span>
            <span class="n">q</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="k">new</span> <span class="nf">Knight</span><span class="p">()</span> <span class="p">{</span> <span class="n">id</span> <span class="p">=</span> <span class="m">90</span> <span class="p">});</span>
            <span class="n">q</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="k">new</span> <span class="nf">Knight</span><span class="p">()</span> <span class="p">{</span> <span class="n">id</span> <span class="p">=</span> <span class="m">40</span> <span class="p">});</span>

            <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="nf">Count</span><span class="p">()</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="c1">// 90 40 30 20 10 출력</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="nf">Pop</span><span class="p">());</span>  
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">IComparable&lt;T&gt;</code> 인터페이스를 상속 받으면 <em>CompareTo</em> 비교 함수를 구현해야 한다. int 같은 기본 데이터 타입이 아닌 <u>사용자 정의 객체 타입이라면 비교할 기준을 따로 마련해 주어야 우선순위 큐에 넣을 수 있다.</u> (우선 순위 큐 자체가 비교와 비교를 거듭하여 항상 <em>부모 &gt; 자식</em> 관계를 유지하게 하는 자료구조이므로)</p>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET