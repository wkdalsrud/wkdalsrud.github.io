I"ˉ<p class="notice--warning">권오흠 교수님의 유튜브 강의 <strong>영리한 프로그래밍을 위한 알고리즘 강좌</strong> 를 듣고 정리한 필기입니다. 😀</p>

<h1 id="chapter1-recursion">Chapter1. Recursion</h1>

<h2 id="-recursion">🔔 Recursion</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Recursion</code> : 자기 자신을 호출 하는 함수 = 재귀 함수</p>
</blockquote>

<h3 id="무한-루프에-빠지지-않으려면">무한 루프에 빠지지 않으려면</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">재귀 함수</code>는 자기 자신을 호출하기 때문에 무한 루프에 빠질 수 있다.
    <ul>
      <li>따라서 적어도 하나의 <u>더 이상 자기 자신을 또 호출하지 않는 종료 Case</u>가 존재해야 한다.</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">func</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// 👈</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>위 코드에서의 종료 조건 👉 n == 0
    <ul>
      <li>return n + func(n-1);
        <ul>
          <li>n + 1이였다면 무한 루프.</li>
          <li>종료 조건인 n = 0 에 수렴하도록 n 이 작아지는 방향으로 구조를 짜야 한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>호출 과정은 <a href="https://ansohxxn.github.io/cpp/chapter7-10/">“C++ 재귀적 함수 호출” 포스트 참고</a></li>
</ul>

<p><br /></p>

<h3 id="재귀-함수와-수학적-귀납법">재귀 함수와 수학적 귀납법</h3>

<blockquote>
  <p>정리 :  func(int n)은 음이 아닌 정수 n에 대해서 0에서 n
까지의 합을 올바로 계산한다.</p>
</blockquote>

<ul>
  <li>증명
    <ol>
      <li><code class="language-plaintext highlighter-rouge">n = 0</code>인 경우 👉 n=0인 경우 0을 반환한다 ⭕</li>
      <li><code class="language-plaintext highlighter-rouge">n &lt; k</code>인 경우 👉 임의의 양의 정수 k에 대해서 n &lt; k인 경우 0에서 n 까지의 합을 올바르게 계산하여 반환한다고 <u>가정.</u></li>
      <li><code class="language-plaintext highlighter-rouge">n = k</code>인 경우 👉 func은 먼저 func(k-1) 호출하는데 2번 가정에 의해서 0에서 k-1까지의 합이 올바로 계산되어 반환된다. 메서드 func은 그 값에 n을 더해서 반환하므로 결국 0에서 k까지의 합을 올바로 계산하여 반환한다. ⭕
        <ul>
          <li><code class="language-plaintext highlighter-rouge">func(k) = k + func(k-1)</code> 에서 2 번 가정에 의해 <code class="language-plaintext highlighter-rouge">func(k-1)</code>가 올바르므로 <code class="language-plaintext highlighter-rouge">func(k)</code>도 올바름.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<p><br /></p>

<h3 id="재귀-vs-반복">재귀 Vs. 반복</h3>

<blockquote>
  <p>모든 재귀 호출은 반복문으로 변경 가능하며 그 역으로도 성립한다. 모든 반복문은 재귀 호출로도 변경 가능하다.</p>
</blockquote>

<ul>
  <li>재귀 함수
    <ul>
      <li>장점 : 복잡한 알고리즘을 사람이 보기에 단순하고 알기 쉽게 표현 가능</li>
      <li>단점 : 함수 호출에 따른 <u>오버헤드</u>가 있음</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="재귀-알고리즘-설계">재귀 알고리즘 설계</h3>

<blockquote>
  <p>뒤에서부터 빠져나오면서, 혹은 더 깊이 들어가고 차례로 빠져나오면서 뭘 하고 싶을 때.</p>
</blockquote>

<ul>
  <li>적어도 하나 이상의 순환되지 않는 종료 case가 있어야 한다.</li>
  <li>모든 case는 종료 case로 수렴해야 한다.</li>
  <li><u>암시적 매개변수를 명시적 매개변수로 바꿔라</u>
    <ul>
      <li><u>재귀 호출을 위해 매개변수를 좀 더 일반화 하란 얘기</u></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="-재귀-함수를-사용하는-알고리즘">🔔 재귀 함수를 사용하는 알고리즘</h2>

<h3 id="팩토리얼-n">팩토리얼 n!</h3>

<blockquote>
  <p>시간 복잡도 O(n)</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0! = 1
n! = n X (n-1)!    (n &gt; 0)
</code></pre></div></div>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="err">–</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// 👈</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="xn">\(X^n\)</h3>

<blockquote>
  <p>시간 복잡도 O(n)</p>
</blockquote>

<ul>
  <li>\(X^0 = 1\)</li>
  <li>\(X^n = X * X^{n-1}\)</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">power</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="err">–</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 👈</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="피보나치-수열">피보나치 수열</h3>

<p>\[f_0 = 0\]
\[f_1 = 1\]
\[f_n = f_{n-1} + f{n_2}\]</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 👈</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
  <p>중복 계산이 너무 많아서 <u>재귀로 푸는건 비효율적이다.</u></p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(4) = f(3) + f(2) = f(1) + f(2) + f(1) + f(0) = f(1) + f(1) + f(0) + f(1) + f(0)
</code></pre></div></div>
<ul>
  <li>중복 多</li>
</ul>

<p><br /></p>

<h3 id="최대공약수-구하기-euclid-method">최대공약수 구하기 Euclid Method</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">&lt;</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span><span class="o">=</span><span class="n">m</span><span class="p">;</span> <span class="n">m</span><span class="o">=</span><span class="n">n</span><span class="p">;</span> <span class="n">n</span><span class="o">=</span><span class="n">tmp</span><span class="p">;</span> <span class="c1">// swap m and n</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">%</span> <span class="n">n</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// 👈 </span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>m &gt;= n 인 두 양의 정수 m 과 n 에 대해서
    <ul>
      <li><strong>if (m%n==0)</strong>
        <ul>
          <li>m 이 n 의 배수이면 gcd(m, n) = n 이고,
            <ul>
              <li>리턴하는 이 n 이 최대 공약수가 된다.</li>
              <li>종료 조건</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><strong>else</strong>
        <ul>
          <li>그렇지 않으면 <u>gcd(m, n)= gcd(n, m%n)</u> 이다.
            <ul>
              <li>재귀</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>ex) 15 와 6 의 최대 공약수는
    <ul>
      <li>gcd(15, 6) 👉 gcd(6, 3) 호출 👉 3 리턴.</li>
    </ul>
  </li>
</ul>

<h4 id="더-간단한-버전">더 간단한 버전</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">q</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span> <span class="o">%</span> <span class="n">q</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>ex) 15 와 6 의 최대 공약수는
    <ul>
      <li>gcd(15, 6) 👉 gcd(6, 3) 호출 👉 <u>gcd(3, 0) 호출</u> 👉 3 리턴.</li>
      <li>위 예제와 다르게 gcd(3, 0) 까지 간다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="문자열">문자열</h3>

<h4 id="길이-계산">길이 계산</h4>

<blockquote>
  <p>💡 <u>현재 문자열 길이</u> = <u>첫번째 문자를 제외한 문자열의 길이</u> + 1</p>
</blockquote>

<ul>
  <li>💡 재귀적 아이디어
    <ul>
      <li>“abcde” 라는 문자열의 길이를 잰다면
        <ul>
          <li>“abcde”.length = “bcde”.length + 1</li>
          <li>“bcde”.length = “cde”.length + 1</li>
          <li>“cde”.length = “de”.length + 1</li>
          <li>“de”.length = “e”.length + 1</li>
          <li>“e”.length = “\0”.length + 1</li>
          <li>“\0”.length = 0  👈 <u>종료조건</u></li>
        </ul>
      </li>
      <li>결론적으로 “abcde”.length = 0 + 1 + 1 + 1 + 1 = 5 가 된다.</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">length</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="err">‘\</span><span class="mi">0</span><span class="err">’</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length</span><span class="p">(</span><span class="n">str</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 👈</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>char 포인터 <code class="language-plaintext highlighter-rouge">str</code>가 문자열 배열의 주소를 담게 되면
    <ul>
      <li><code class="language-plaintext highlighter-rouge">str+1</code>은 다음 원소를 가리키므로 다음 원소를 시작점으로 하는 배열을 뜻하게 된다.</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">length</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length</span><span class="p">(</span><span class="n">str</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="프린트">프린트</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printChars</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">str</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="err">‘\</span><span class="mi">0</span><span class="err">’</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">else</span> 
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="o">%</span><span class="n">c</span><span class="err">”</span><span class="p">,</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
        <span class="n">printChars</span><span class="p">(</span><span class="n">str</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="거꾸로-프린트">거꾸로 프린트</h4>

<blockquote>
  <p>💡 <u>문자열 거꾸로 프린트</u> = <u>첫번째 문자를 제외한 문자열 거꾸로 프린트</u> + 이후 첫번째 문자 맨 뒤에 프린트</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printCharsReverse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">str</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="o">==</span><span class="err">‘\</span><span class="mi">0</span><span class="err">’</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">else</span> 
    <span class="p">{</span>
        <span class="n">printCharsReverse</span><span class="p">(</span><span class="n">str</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="o">%</span><span class="n">c</span><span class="err">”</span><span class="p">,</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>  <span class="c1">// %c 로 받으므로 한글자만 출력. *str 즉 첫번째 문자 </span>
    <span class="p">}</span>   
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><u>마지막 끝 문자까지 끝까지 들어간 이후</u>에 빠져 나오는 과정에서 <u>한문자씩 print</u>
    <ul>
      <li>즉 뒷글자부터 한문자씩 출력하게 된다.</li>
      <li>👉 재귀 호출 printCharsReverse(str+1)가 printf 보다 앞에 있어야 한다.</li>
      <li>printCharsReverse(“abcde”)
        <ul>
          <li>printCharsReverse(“bcde”) 호출
            <ul>
              <li>printCharsReverse(“cde”) 호출
                <ul>
                  <li>printCharsReverse(“de”) 호출
                    <ul>
                      <li>printCharsReverse(“e”) 호출
                        <ul>
                          <li>printCharsReverse(“\0”) 호출</li>
                          <li>return 후 <code class="language-plaintext highlighter-rouge">e</code> 출력</li>
                        </ul>
                      </li>
                      <li>return 후 <code class="language-plaintext highlighter-rouge">d</code> 출력</li>
                    </ul>
                  </li>
                  <li>return 후 <code class="language-plaintext highlighter-rouge">c</code> 출력</li>
                </ul>
              </li>
              <li>return 후 <code class="language-plaintext highlighter-rouge">b</code> 출력</li>
            </ul>
          </li>
          <li>return 후 <code class="language-plaintext highlighter-rouge">a</code> 출력</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="순차-탐색">순차 탐색</h3>

<blockquote>
  <p>data[0] ~ data[n-1] 사이에서 <code class="language-plaintext highlighter-rouge">target</code>이 있는지 검색한다. 존재하면 <code class="language-plaintext highlighter-rouge">target</code>과 일치하는 원소의 인덱스를 리턴, 없으면 -1 을 리턴.</p>
</blockquote>

<blockquote>
  <p>못찾으면 재귀. 더 깊숙히 끝으로 들어감.</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">search</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,)</span> 
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1">// 못찾았다면 </span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">==</span><span class="n">items</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1">// 찾았다면 리턴하고 끝내기</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span>  <span class="c1">// 찾은건 아닌데 아직 끝에 도달한게 아니라면</span>
        <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>  <span class="c1">// 👈</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>인덱스 0 부터 시작으로 쳐서 (즉 배열 원소 전체) begin, end 인덱스는 넘길 필요 X</li>
  <li>💡 재귀적 아이디어
    <ul>
      <li>주어진 범위에서 마지막 원소가 target과 동일한지 검사
        <ul>
          <li>원소 하나하나씩 전부 검사하게 됨 👉 <strong>순차 탐색</strong></li>
        </ul>
      </li>
      <li>ex) n = 5 이고 data[1]이 target일 때.
        <ul>
          <li>search(5) 👉 data[4]가 target인지 검사
            <ul>
              <li>search(4) 👉 data[3]가 target인지 검사
                <ul>
                  <li>search(3) 👉 data[2]가 target인지 검사
                    <ul>
                      <li>search(2) 👉 data[1]가 target인지 검사
                        <ul>
                          <li>1 을 리턴한다. (search(2))</li>
                        </ul>
                      </li>
                      <li>1 을 리턴한다. (search(3))</li>
                    </ul>
                  </li>
                  <li>1 을 리턴한다. (search(4))</li>
                </ul>
              </li>
              <li>1 을 리턴한다. (search(5))</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="최대값-찾기">최대값 찾기</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">findMax</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span><span class="p">[])</span> 
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">findMax</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>💡 <u>data[0] ~ data[n-1] 사이에서의 최대값</u> = <u>data[0] ~ data[n-2] 사이에서의 최대값</u> 과 data[n-1] 中 더 큰 값.</p>
</blockquote>

<ul>
  <li>인덱스 0 부터 시작으로 쳐서 (즉 배열 원소 전체) begin, end 인덱스는 넘길 필요 X</li>
  <li>ex)
    <ul>
      <li>findMax(5, data) 👉 findMax(4, data) 과 data[4] 중에 큰 값
        <ul>
          <li>findMax(4, data) 👉 findMax(3, data) 과 data[3] 중에 큰 값
            <ul>
              <li>findMax(3, data) 👉 findMax(2, data) 과 data[2] 중에 큰 값
                <ul>
                  <li>findMax(2, data) 👉 findMax(1, data) 과 data[1] 중에 큰 값
                    <ul>
                      <li>findMax(1, data)</li>
                      <li>data[0] 리턴</li>
                    </ul>
                  </li>
                  <li>data[0] , data[1] 중에 큰 값 리턴</li>
                </ul>
              </li>
              <li>data[0] ,data[1], data[2] 중에 큰 값 리턴</li>
            </ul>
          </li>
          <li>data[0] ,data[1], data[2], data[3] 중에 큰 값 리턴</li>
          <li>data[0] ,data[1], data[2], data[3], data[4] 중에 큰 값 리턴</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">findMax</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">begin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">begin</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">begin</span><span class="p">];</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">begin</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">max_1</span> <span class="o">=</span> <span class="n">findMax</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">middle</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">max_2</span> <span class="o">=</span> <span class="n">findMax</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">max1</span><span class="p">,</span> <span class="n">max2</span><span class="p">);</span>
    <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>전체 배열이 아닌 구체적인 범위가 주어진 경우기 때문에 시작 인덱스와 끝 인덱스를 넘겨주었다.</li>
  <li>💡 재귀 호출이 전부 끝난 최종적인 max_1과 max_2 값끼리 비교한게 진짜 최대값이다.</li>
</ul>

<p><br /></p>

<h3 id="10진수-정수를-2진수로-변환하여-출력">10진수 정수를 2진수로 변환하여 출력</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printInBinary</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// 종료조건</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>  
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printInBinary</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1">// 👈</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>💡 2 로 나눈 <u>나머지가 0 혹은 1이 될 때까지</u> <u>계속 해서 2 로 나눈 몫을 또 2로 나누고 반복</u></li>
  <li>💡 나머지들을 출력하되 <u>출력은 역순으로 해야하므로 재귀호출이 모두 끝난 다음에 printf 출력할 수 있도록 printf를 재귀 호출보다 뒤에 위치하게</u>
    <ul>
      <li>ex) n = 13
        <ul>
          <li>printInBinary(13)
            <ul>
              <li>👉 printInBinary(6)
                <ul>
                  <li>👉 printInBinary(3)
                    <ul>
                      <li>👉 printInBinary(1)
                        <ul>
                          <li>1 출력</li>
                        </ul>
                      </li>
                      <li>1 출력 (3 % 2)</li>
                    </ul>
                  </li>
                  <li>0 출력 (6 % 2)</li>
                </ul>
              </li>
              <li>1 출력 (13 % 2)</li>
            </ul>
          </li>
          <li>최종적으로 1101 출력</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="disjoints-set">Disjoints Set</h3>

<blockquote>
  <p>A, B 두 배열의 교집합, 즉 공통 원소가 하나도 없으면 True, 하나라도 있으면 False</p>
</blockquote>

<blockquote>
  <p>A, B <u>두 배열이 정렬되어 있다고 가정</u></p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">isDisjoint</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">B</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>   <span class="c1">// 종료조건 1️⃣ 공통 원소가 하나도 없음. Disjoint 함.</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">B</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1">// 종료조건 2️⃣ 공통 원소 발견. Disjoint 하지 않음.</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">B</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">isDisjoint</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>  <span class="c1">// 👈</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">isDisjoint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span> <span class="c1">// 👈</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>💡 끝 원소부터 차례대로 검사해나간다.
    <ul>
      <li><strong>A[m-1]&gt;B[n-1]</strong> 라면 A[m-1]은 모든 B[0] ~ B[n-1] 들 보다 크다.
        <ul>
          <li>A, B 두 배열은 정렬되어 있기 때문에.</li>
          <li>따라서 A[m-1]은 B[0] ~ B[n-1] 범위 내엔 없으므로 <u>A 의 다음 안쪽 원소 검사. 재귀로 다음 원소로 들어가기</u>
            <ul>
              <li>👉 재귀 호출 : 이제 A[m-2] 와 B[n-1] 비교
                <ul>
                  <li>isDisjoint(m-1, A, n, B)</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li><strong>A[m-1]&lt;B[n-1]</strong> 라면 B[n-1]은 모든 A[0] ~ A[m-1] 들 보다 크다.
        <ul>
          <li>A, B 두 배열은 정렬되어 있기 때문에.</li>
          <li>따라서 B[n-1]은 A[0] ~ A[m-1] 범위 내엔 없으므로 <u>B 의 다음 안쪽 원소 검사. 재귀로 다음 원소로 들어가기</u>
            <ul>
              <li>👉 재귀 호출 : 이제 B[n-2] 와 A[m-1] 비교
                <ul>
                  <li>isDisjoint(m, A, n-1, B)</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>두 배열 중 하나라도 인덱스가 음수가 되면 종료. 한 배열을 다 뒤졌는데도 공통 원소가 없는 것이니!</li>
    </ul>
  </li>
</ul>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET