I"Jj<h1 id="그리디-큰-수-만들기">[그리디] 큰 수 만들기</h1>

<blockquote>
  <p>난이도 ⭐⭐</p>
</blockquote>

<h2 id="문제">문제</h2>

<p><img src="https://user-images.githubusercontent.com/42318591/91123711-7c3e3f00-e6d8-11ea-8722-b85ee3dea497.png" alt="image" width="80%" height="80%" class="align-center" /></p>

<p><br /></p>

<h2 id="내-풀이">내 풀이</h2>

<h3 id="1차-풀이--시간-초과">1차 풀이 ❌ (시간 초과)</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">compare</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">first</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">string</span> <span class="nf">solution</span><span class="p">(</span><span class="n">string</span> <span class="n">number</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">answer</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">sorted_number</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">number</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">sorted_number</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">number</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">));</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">sorted_number</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sorted_number</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">compare</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">indexOflastNum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sorted_number</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">remainSize</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">;</span>
    
    <span class="k">while</span><span class="p">(</span><span class="n">answer</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sorted_number</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span> <span class="o">+</span> <span class="n">remainSize</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">sorted_number</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span> <span class="o">&gt;</span> <span class="n">indexOflastNum</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">answer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sorted_number</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">);</span>  <span class="c1">// char 타입인 sorted_number[i].first 를 1 번 반복하여 answer 문자열의 뒤에 붙임</span>
            <span class="n">indexOflastNum</span> <span class="o">=</span> <span class="n">sorted_number</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">;</span>
            <span class="n">remainSize</span><span class="o">--</span><span class="p">;</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/42318591/91124303-f91de880-e6d9-11ea-9cbb-12225a9223fc.png" alt="image" width="40%" height="40%" class="align-center" /></p>

<blockquote>
  <p>이 풀이는 테스트 케이스 9, 10번에서 시간 초과⏰가 발생하는 풀이입니다!</p>
</blockquote>

<p>정답을 도출하지만 시간이 너무 많이 걸리는 풀이라 사실상 틀린 풀이다.</p>

<ul>
  <li>큰 수로 만들되 원래의 순서는 지켜야 한다.
    <ul>
      <li>7보다 8이 앞에 위치해 있다면 큰 수로 만들 때 8이 7보다 앞설 수는 없다.</li>
    </ul>
  </li>
  <li>이 풀이의 아이디어
    <ul>
      <li><code class="language-plaintext highlighter-rouge">sorted_number</code>라는 벡터를 선언했다.
        <ul>
          <li>이 벡터에 <code class="language-plaintext highlighter-rouge">number</code> 문자열 각각의 원소인 문자(char)와 함께 정렬 전 인덱스(int)를 함께 pair로 저장한다.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">number</code> 문자열을 내림차순 정렬하되 같은 값이라면 인덱스 오름 차순 정렬을 기준으로 <code class="language-plaintext highlighter-rouge">sorted_number</code>를 정렬시킨다. 같은 값이라면 원래대로 인덱스 빠른게 더 앞에 오도록!
        <ul>
          <li>정렬이 되었더라도 원소(pair)의 <code class="language-plaintext highlighter-rouge">second</code>에 정렬 전 <code class="language-plaintext highlighter-rouge">number</code>상에서의 인덱스(위치)를 기억하고 있는 상태.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">k</code>개를 <code class="language-plaintext highlighter-rouge">number</code>로부터 떼내므로 최종적인 <code class="language-plaintext highlighter-rouge">answer</code>의 길이는 <code class="language-plaintext highlighter-rouge">number.size() - k</code>가 되야 한다.
        <ul>
          <li>편의상 <code class="language-plaintext highlighter-rouge">n</code>을 <code class="language-plaintext highlighter-rouge">number.size()</code>라고 정의했다.</li>
        </ul>
      </li>
      <li>반복문은 <code class="language-plaintext highlighter-rouge">answer</code>가 완성될 때까지 돈다. 즉 <code class="language-plaintext highlighter-rouge">answer</code>의 길이가 <code class="language-plaintext highlighter-rouge">n - k</code>가 될 때까지!
        <ul>
          <li><code class="language-plaintext highlighter-rouge">sorted_number</code>는 내림 차순 정렬이 되어 있으므로 큰 수들이 먼저 검사를 받게 된다.</li>
          <li>정렬된 <code class="language-plaintext highlighter-rouge">sorted_number</code> 원소들을 차례 차례 순회하며 <u>1️⃣정렬 전 원래의 인덱스(second)에서 앞으로 `answer`를 다 채우기 까지 얼만큼 더 채워야 하는지를 더한 값이 `n`을 넘어버리면 안되고</u>, <u>2️⃣정렬 전 원래의 인덱스(second)가 `answer`에 가장 최근에 추가된 문자의 정렬 전 원래의 인덱스보다 같거나 작으면 안된다.(같다는건 완전히 동일한 값이라서 안되는 것이고 작다는건 현재의 `answer`의 가장 마지막에 있는 원소보다 `number`상에서 더 앞에 위치해 있는 원소라는 뜻이므로 삽입이 불가능하다.</u> 위 두 가지 조건이 <code class="language-plaintext highlighter-rouge">answer</code>에 삽입될 조건이다!
            <ul>
              <li><code class="language-plaintext highlighter-rouge">answer</code>가 비어있는 경우</li>
              <li><code class="language-plaintext highlighter-rouge">i</code>은 <code class="language-plaintext highlighter-rouge">sorted_number</code>를 순회할 포인터.</li>
              <li><code class="language-plaintext highlighter-rouge">indexOflastNum</code>은 <code class="language-plaintext highlighter-rouge">answer</code>에 가장 최근에 추가된 문자의 정렬 전 원래의 인덱스(second). 처음엔 <code class="language-plaintext highlighter-rouge">answer</code>이 빈 문자열로 시작되므로 초기값은 <code class="language-plaintext highlighter-rouge">-1</code>로 해준다.</li>
              <li><code class="language-plaintext highlighter-rouge">remainSize</code>는 <code class="language-plaintext highlighter-rouge">answer</code>를 다 채우기 까지 현재 시점에서 얼만큼 더 채워야 하는지를 나타낸다. <code class="language-plaintext highlighter-rouge">answer</code>의 최종 길이가 될 <code class="language-plaintext highlighter-rouge">n - k</code>값에서 시작하되 <code class="language-plaintext highlighter-rouge">answer</code>에 적합한 원소를 삽입할 때마다 1 씩 감소한다.</li>
              <li><code class="language-plaintext highlighter-rouge">sorted_number[i]</code>가 1️⃣2️⃣ 후보를 만족하는 원소라면
                <ul>
                  <li><code class="language-plaintext highlighter-rouge">answer</code>의 뒤에 원소를(first) 붙이고</li>
                  <li><code class="language-plaintext highlighter-rouge">indexOflastNum</code>을 업데이트 하고</li>
                  <li><code class="language-plaintext highlighter-rouge">remainSize</code>를 1 줄이고</li>
                  <li>다시 <code class="language-plaintext highlighter-rouge">sorted_number</code>의 처음부터 검사하기 위해 <code class="language-plaintext highlighter-rouge">i = 0</code>한다.</li>
                </ul>
              </li>
              <li><code class="language-plaintext highlighter-rouge">sorted_number[i]</code>가 1️⃣2️⃣ 후보를 만족하는 원소가 아니라면
                <ul>
                  <li>다음 원소를 검사하기 위해 <code class="language-plaintext highlighter-rouge">i++</code></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="2차-풀이-">2차 풀이 ⭕</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">string</span> <span class="nf">solution</span><span class="p">(</span><span class="n">string</span> <span class="n">number</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">answer</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">number</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lastMaxIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="n">number</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">max</span> <span class="o">=</span> <span class="n">number</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">lastMaxIndex</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">answer</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">lastMaxIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">end</span><span class="o">++</span><span class="p">;</span>
        <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<blockquote>
  <p>이 풀이는 시간 초과 되지 않고 모든 테스트 케이스를 통과합니다.</p>
</blockquote>

<p>1차 풀이의 시간 초과를 해결하지 못해 1차 풀이는 폐기하고 결국 구글링하여 다른 분들의 풀이를 참고하여 풀이했다.. 이 풀이가 더 <u>그리디 알고리즘</u>에 적합한 풀이다.</p>

<blockquote>
  <p><strong>그리디 알고리즘</strong> 👉 <u>순간 순간마다 최적이라고 생각되는 결정을 하는 방식</u>으로 진행하여 최종 해답에 도달하는 문제 해결 방식</p>
</blockquote>

<ul>
  <li><code class="language-plaintext highlighter-rouge">answer</code>원소를 결정할 때마다 그때 그때 <code class="language-plaintext highlighter-rouge">answer[i]</code>가 될 수 있는 범위 내에서 최대값(최적해)를 찾는다.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/42318591/91139545-5883f480-e6ea-11ea-89c3-283c8917c8f5.png" alt="image" width="80%" height="80%" class="align-center" /></p>

<ul>
  <li>첫 번째 for문
    <ul>
      <li><code class="language-plaintext highlighter-rouge">answer[i]</code> 문자를 결정한다. <code class="language-plaintext highlighter-rouge">answer</code>는 최종적으로 <code class="language-plaintext highlighter-rouge">n - k</code>길이가 되야하므로 <code class="language-plaintext highlighter-rouge">n - k</code>번 돈다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">answer</code>는 빈 문자열로 시작하므로 <code class="language-plaintext highlighter-rouge">answer[i] = 땡땡</code>으로 접근하면 런타임 에러가 발생한다는 것에 주의하기! <code class="language-plaintext highlighter-rouge">append</code>를 사용하여 <code class="language-plaintext highlighter-rouge">answer</code>뒤에 하나씩 붙여주었다. <code class="language-plaintext highlighter-rouge">+=</code>를 사용해도 좋다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>두 번째 for문
    <ul>
      <li><code class="language-plaintext highlighter-rouge">answer[i]</code> 문자는 <code class="language-plaintext highlighter-rouge">start</code> ~ <code class="language-plaintext highlighter-rouge">end</code> 인덱스를 가진 <code class="language-plaintext highlighter-rouge">number</code> 원소들 범위 내에서 <u>최대값</u>이 되야 한다.</li>
      <li>이 최대값을 찾기 위한 역할을 함</li>
      <li>최대값(<code class="language-plaintext highlighter-rouge">max</code>)과 그의 인덱스(<code class="language-plaintext highlighter-rouge">lastMaxIndex</code>)도 저장한다.
        <ul>
          <li>다음 범위의 최대값을 찾기 위해선 <code class="language-plaintext highlighter-rouge">max = 0</code>초기화를 해주어야 한다.</li>
          <li><code class="language-plaintext highlighter-rouge">if(max &lt; number[j])</code>에서 <code class="language-plaintext highlighter-rouge">&lt;</code> 가 아닌 <code class="language-plaintext highlighter-rouge">&lt;=</code>를 사용하면 값이 같을 때 뒤에 있는 원소가 앞으로 올 수 있어서 안된다.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">start</code> 👉 범위 내의 최대값을 찾을 범위 시작 인덱스. 해당 범위내의 최대값을 다 찾고나면 다음 범위의 시작 인덱스는 최대값이 위치했던 인덱스의 다음 인덱스다.</li>
      <li><code class="language-plaintext highlighter-rouge">end</code> 👉 범위 내의 최대값을 찾을 범위 끝 인덱스. 초기값은 <code class="language-plaintext highlighter-rouge">k</code>에서 시작한다. 처음부터 인덱스가 <code class="language-plaintext highlighter-rouge">k</code>를 넘는 곳에 위치한 문자를 <code class="language-plaintext highlighter-rouge">answer[0]</code>에 넣어버리면 <code class="language-plaintext highlighter-rouge">n - k</code>개까지 다 채울 수가 없다. 인덱스가 <code class="language-plaintext highlighter-rouge">k</code>를 넘는 곳에 위치한 문자의 뒤에 위치한 문자들만 앞으로 넣을 수가 있기 때문이다. 그리고 <code class="language-plaintext highlighter-rouge">answer</code>를 하나씩 채워갈 수록 아직 남은 빈 자리들도 1씩 줄어들기 때문에 <code class="language-plaintext highlighter-rouge">end</code>는 1씩 증가하게 된다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="1차-풀이와-2차-풀이의-시간-복잡도-비교">1차 풀이와 2차 풀이의 시간 복잡도 비교</h3>

<ul>
  <li>1차 풀이의 실행시간
    <ul>
      <li><img src="https://user-images.githubusercontent.com/42318591/91124303-f91de880-e6d9-11ea-9cbb-12225a9223fc.png" alt="image" width="60%" height="60%" class="align-center" /></li>
      <li>확인해본 결과 “4177252841” (<code class="language-plaintext highlighter-rouge">answer</code>의 길이는 <code class="language-plaintext highlighter-rouge">n-k</code>이므로 10-4 = 6이 됨)을 <code class="language-plaintext highlighter-rouge">number</code>으로 넣었을시 <u>while 반복문을 총 26번 돌았다.</u>
        <ul>
          <li>매번 연산 횟수 👉 최선일 땐 <code class="language-plaintext highlighter-rouge">1</code>번 (적합한게 맨 앞에 위치할 때), 최악일 땐 <code class="language-plaintext highlighter-rouge">10</code>번 (적합한게 맨 뒤에 위치할 때)
            <ul>
              <li>매번 i = 0 ~ n - 1 번 내에서 돌기 때문에 마치 순차탐색처럼 적합한게 앞에 위치하다면 일찍 찾고 빠져나오지만 계속해서 맨 뒤에 위치한다면 매 반복마다 <code class="language-plaintext highlighter-rouge">O(n)</code>이 되는것이나 마찬가지다.
                <ul>
                  <li>최악의 경우 <code class="language-plaintext highlighter-rouge">(n-k) * n</code> 시간 복잡도가 소요 됨</li>
                </ul>
              </li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">answer[0]</code>을 결정하는데 반복문 돌았던 횟수 👉 2</li>
          <li><code class="language-plaintext highlighter-rouge">answer[1]</code>을 결정하는데 반복문 돌았던 횟수 👉 3</li>
          <li><code class="language-plaintext highlighter-rouge">answer[2]</code>을 결정하는데 반복문 돌았던 횟수 👉 4</li>
          <li><code class="language-plaintext highlighter-rouge">answer[3]</code>을 결정하는데 반복문 돌았던 횟수 👉 1</li>
          <li><code class="language-plaintext highlighter-rouge">answer[4]</code>을 결정하는데 반복문 돌았던 횟수 👉 6</li>
          <li><code class="language-plaintext highlighter-rouge">answer[5]</code>을 결정하는데 반복문 돌았던 횟수 👉 10
            <ul>
              <li>이와 같이 <code class="language-plaintext highlighter-rouge">n</code>만큼 다 돌아야하는 경우가 매번 생긴다면 끔찍쓰</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>2차 풀이의 실행시간
    <ul>
      <li><img src="https://user-images.githubusercontent.com/42318591/91124237-d1c71b80-e6d9-11ea-8a25-89da7d9c8abd.png" alt="image" width="60%" height="60%" class="align-center" /></li>
      <li>확인해본 결과 “4177252841”을 <code class="language-plaintext highlighter-rouge">number</code>으로 넣었을시 <u>이중 for문까지 합하여 총 15번 돌았다.</u>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">start</code> ~ <code class="language-plaintext highlighter-rouge">end</code>까지의 범위만 돈다. 매번 연산 횟수 👉 <code class="language-plaintext highlighter-rouge">end - start + 1</code>
            <ul>
              <li><code class="language-plaintext highlighter-rouge">end</code>는 1 씩 증가하고 <code class="language-plaintext highlighter-rouge">start</code>또한 <code class="language-plaintext highlighter-rouge">answer</code>원소를 결정한 그 다음 위치를 가리키기 때문에 후반부로 갈수록 범위가 줄어드는 경향이 있다.</li>
              <li>시간 복잡도가 <code class="language-plaintext highlighter-rouge">(n - k) * 땡땡</code> 이 되지만 <u>이 땡땡은 절대 `n`을 넘지 않는다. `n`보다 작으며 심지어 줄어드는 경향을 보임</u>
                <ul>
                  <li>따라서 1차 풀이보다 시간복잡도가 좋을 수 밖에 없다.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">answer[0]</code>을 결정하는데 반복문 돌았던 횟수 👉 5</li>
          <li><code class="language-plaintext highlighter-rouge">answer[1]</code>을 결정하는데 반복문 돌았던 횟수 👉 3</li>
          <li><code class="language-plaintext highlighter-rouge">answer[2]</code>을 결정하는데 반복문 돌았던 횟수 👉 3</li>
          <li><code class="language-plaintext highlighter-rouge">answer[3]</code>을 결정하는데 반복문 돌았던 횟수 👉 2</li>
          <li><code class="language-plaintext highlighter-rouge">answer[4]</code>을 결정하는데 반복문 돌았던 횟수 👉 1</li>
          <li><code class="language-plaintext highlighter-rouge">answer[5]</code>을 결정하는데 반복문 돌았던 횟수 👉 1</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET