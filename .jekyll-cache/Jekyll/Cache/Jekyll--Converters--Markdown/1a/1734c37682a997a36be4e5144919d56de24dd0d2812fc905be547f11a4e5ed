I"E2<h1 id="스택큐-주식-가격">[스택/큐] 주식 가격</h1>

<blockquote>
  <p>난이도 ⭐⭐</p>
</blockquote>

<h2 id="문제">문제</h2>

<p><img src="https://user-images.githubusercontent.com/42318591/88566400-e8456d00-d070-11ea-90c7-eaede6e3349d.png" alt="image" width="90%" height="90%" class="align-center" /></p>

<p><br /></p>

<h2 id="내-풀이">내 풀이</h2>

<h3 id="첫-번째-풀이">첫 번째 풀이</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prices</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">answer</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">prices</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">answer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>이 풀이의 시간 복잡도는 최악의 경우 \(O(N^2)\)  이다.</p>
</blockquote>

<ul>
  <li>예시로 설명
    <ul>
      <li>prices[0] = 1 초 (i = 0)와 2 초, 3 초, 2 처, 3 초를 각각 비교해서 가격이 떨어졌는지를 알아봐야 한다.
        <ul>
          <li>비교할 때마다 무조건 count를 1씩 더한다.</li>
          <li>1 &lt;= 2 니까 비교를 계속 이어간다. 1 &lt;= 3 니까 비교를 계속 이어간다. 1 &lt;= 2 니까 비교를 계속 이어간다. 1 &lt;= 3 니까 비교를 계속 이어간다.
            <ul>
              <li>총 count = 4</li>
              <li>answer[0] = 4 가 들어가게 된다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>prices[2] = 3 초 (i = 2)와 3 초, 2 초, 3 초를 각각 비교해서 가격이 떨어졌는지를 알아봐야 한다.
        <ul>
          <li>3 &gt; 2 니까 <u>가격이 떨어진 것을 알게 되었으므로 3 초에 대해서는 더 이상 비교를 하지 않는다.</u></li>
          <li>그러나 바로 3 &gt; 2 가 되었더라도 2 로 떨어지기까지의 0 ~ 1 초 동안은 가격이 떨어지지 않은 것으로 보기 때문에 count = 1 이 된다.
            <ul>
              <li>즉 가격이 떨어지든 아니든 비교할 때마다 count는 계속 1씩 증가시켜 주어야 함</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>마지막 원소는 조건에 안맞아 두번째 <em>j</em> for문을 돌지 않게 되기 때문에 자연스럽게 count = 0 으로 들어간다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="두-번째-풀이-stack-사용">두 번째 풀이 (stack 사용)</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prices</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">prices</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">answer</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// 주식 가격의 인덱스 보관</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">()]){</span>
            <span class="n">answer</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// 한번도 주식 가격이 떨어진적이 없는 가격들 (여전히 스택 안에 존재)</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
        <span class="n">answer</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>이 풀이의 시간 복잡도는 언제나 \(O(N)\)  이다.</p>
</blockquote>

<ul>
  <li>예를 들어 스택에 [1,2,3,4,5] 주식 가격이 들어있는 상태에서 (<code class="language-plaintext highlighter-rouge">top</code>은 5인 상태) 주식가격 2 원의 차례(인덱스)가 된다면! 스택 안에 들어있는 3, 4, 5 원은 가격이 떨어지게 되는 것이다. 차례로 2 원보다 큰 스택 안의 가격들을 <code class="language-plaintext highlighter-rouge">pop</code> 시키고 인덱스의 차이를 <code class="language-plaintext highlighter-rouge">answer</code> 원소로 저장하면 된다.
    <ul>
      <li>스택 안의 <code class="language-plaintext highlighter-rouge">top</code>에 위치한 주식 가격보다 <code class="language-plaintext highlighter-rouge">price[i]</code> 현재 검사 중인 주식 가격이 더 작다면 <code class="language-plaintext highlighter-rouge">top</code> 주식 가격을 <code class="language-plaintext highlighter-rouge">pop</code> 한다.
        <ul>
          <li>스택 안에 저장되어 있는 가격들 중에 <code class="language-plaintext highlighter-rouge">price[i]</code> 가격으로 ‘가격이 떨어졌다.’고 판단될 수 있는 모든 가격들을 <code class="language-plaintext highlighter-rouge">pop</code> 시킨다.</li>
        </ul>
      </li>
      <li>스택 안의 <code class="language-plaintext highlighter-rouge">top</code>에 위치한 주식 가격보다 <code class="language-plaintext highlighter-rouge">price[i]</code> 현재 검사 중인 주식 가격이 더 크거나 같다면 가격이 떨어진 것이 아니기 때문에 나중에 가격이 떨어질 것을 대비해 스택에 <code class="language-plaintext highlighter-rouge">push</code> 해둔다.</li>
    </ul>
  </li>
  <li>모든 주식 가격의 순회를 마친 후에도 스택 안에 <code class="language-plaintext highlighter-rouge">pop</code> 되지 못하고 남아있는 원소들은 한 번도 주식 가격이 떨어진적이 없는 원소들이나 마찬가지다! 따라서 마지막으로 이 원소들에 대한 처리도 해준다.</li>
</ul>

<h4 id="스택으로-풀면-시간복잡도가-on-인-이유">스택으로 풀면 시간복잡도가 O(n) 인 이유</h4>

<blockquote>
  <p><u>스택을 사용하면 선형 시간 O(N) 으로 접근할 수 있다.</u></p>
</blockquote>

<ul>
  <li>시간 복잡도는 O(N) + O(N) = O(2N) = O(N) 이 된다.
    <ul>
      <li>모든 주식 가격은 한 번씩 <code class="language-plaintext highlighter-rouge">push</code> 된다. 👉 O(N)</li>
      <li>모든 주식 가격은 한 번씩 <code class="language-plaintext highlighter-rouge">pop</code> 된다. 👉 O(N)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="여담">여담..</h3>

<ul>
  <li>첫 번째 풀이는 최악의 경우의 시간복잡도는 \(O(N^2)\) 이 된다.</li>
  <li>반면 두 번째 풀이는 시간복잡도가 \(O(N)\) 이 된다.</li>
</ul>

<p>그런데 첫 번째 풀이는 효율성 테스트를 별 문제 없이 통과했으며 두 풀이의 연산 시간도 거의 차이가 없었다.. 왜지..? 😮 십만 개에 달하는 큰 주식가격 입력들이 모두 떨어지는 경우가 단 하나도 없는 테스트 케이스라면 두 풀이의 시간이 확실히 차이날 듯 한데.. 내가 무언갈 놓치고 있는 것인지 테스트 케이스가 빈약한건지 모르겠다. 궁금하다!</p>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET