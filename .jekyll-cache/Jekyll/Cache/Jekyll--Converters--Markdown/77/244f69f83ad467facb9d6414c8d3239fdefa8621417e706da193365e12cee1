I"D<h1 id="-풍선-터트리기">📌 풍선 터트리기</h1>

<blockquote>
  <p>난이도 ⭐⭐⭐</p>
</blockquote>

<h2 id="-문제">🚀 문제</h2>

<p><img src="https://user-images.githubusercontent.com/42318591/108330007-b2382800-7210-11eb-9bd2-f75170564d5e.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/42318591/108330106-b95f3600-7210-11eb-8a18-527d8004170e.png" alt="image" /></p>

<p><br /></p>

<h2 id="-내-풀이">🚀 내 풀이</h2>

<p>역시 시간 복잡도를 생각해야 한다. <code class="language-plaintext highlighter-rouge">a</code>의 길이가 무려 1,000,000 이기 때문이다!</p>

<ul>
  <li>임의의 인접한 두 풍선 중 <strong>더 큰 번호의 풍선</strong>을 터뜨리는 것은 <u>제약이 없다.</u>
    <ul>
      <li>최소값을 가진 풍선의 양옆 인접한 풍선들은 모두 제거될 수 있다.</li>
    </ul>
  </li>
  <li>임의의 인접한 두 풍선 중 <strong>더 작은 번호의 풍선</strong>을 터뜨리는 것은 <u>딱 한번만 가능하다.</u>
    <ul>
      <li>따라서 최소값을 가진 풍선은 더 작은 번호의 풍선을 터뜨리는 한번의 찬스를 사용할 필요 없이 무조건 최후까지 살아 남는 것이 가능하다.</li>
      <li>그러나 <strong>최소값이 아닌 풍선들</strong>이 자신이 최후까지 살아남을 수 있는 풍선인지를 알기 위해선
        <ul>
          <li>👉 더 작은 번호의 풍선을 제거할 수 있는 한번의 찬스는 “자기 자신과 최소값 풍선 사이에서 최소값 풍선을 제거할 때” 사용되어야 한다.</li>
          <li>👉 따라서 자신이 최후까지 살아남기 위해선, <u>최소값 풍선이 제거시켜줄 수 없는 곳에 자신보다 작은 풍선이 인접해있으면 안된다.</u></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>여담으로 주의할 사항은 <code class="language-plaintext highlighter-rouge">a</code>를 “정렬”시키면 절대 안된다. 저 순서대로 풍선이 놓여져있다는 것이기 때문에 이 풍선들의 순서를 문제에서 주어진대로 유지해야 하며 정렬 시키면 안된다!! (내가 처음에 그랬었다..😅 정렬시키면 당연히 모든 풍선이 최후까지 남는게 가능해진다.)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[-16, 27, 65, 2, 58, -92, -71, -68, -61, -33]
</code></pre></div></div>

<ul>
  <li>예를 들어 두 번째 예제에서 (두번째 예제의 <code class="language-plaintext highlighter-rouge">a</code> 최소값은 <strong>-92</strong> 이다.)</li>
  <li><code class="language-plaintext highlighter-rouge">65</code>가 최후까지 살아남는 것이 가능한지를 따져보려면
    <ul>
      <li>밑줄 친 부분들은 최소값인 -92 를 만났을 떄 제거될 수 있다. -92와 65를 제외한 곳에서 밑줄 쳐지지 않은 부분은 -92가 제거할 수 없는 부분이다. 65가 가로막고 있어 인접하지 않은 부분이다. 그리고 65가 -92 를 제거하는데 <strong>더 작은 것을 제거할 수 있는 딱 한번의 찬스</strong>를 쓰게 된다.
        <ul>
          <li>[-16, 27, ✨65, <u>-2, 58</u>, -92, <u>-71, -68, -61, -33</u>]</li>
        </ul>
      </li>
      <li>[-16, 26, ✨65] 그러나 -92로 제거할 수 없는 범위에 65보다 작은 -16, 27 이 존재한다. 65는 이미 최소값 -92를 제거할 때 찬스를 썼으므로 이들을 제거할 수 없다. 👉 따라서 <code class="language-plaintext highlighter-rouge">65</code>는 최후까지 살아남을 수 없다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">-61</code>이 최후까지 살아남는 것이 가능한지를 따져보려면
    <ul>
      <li>밑줄 친 부분들은 최소값인 -92 를 만났을 떄 제거될 수 있다. -92와 -61를 제외한 곳에서 밑줄 쳐지지 않은 부분은 -92가 제거할 수 없는 부분이다. -61가 가로막고 있어 인접하지 않은 부분이다. 그리고 -61가 -92 를 제거하는데 <strong>더 작은 것을 제거할 수 있는 딱 한번의 찬스</strong>를 쓰게 된다.
        <ul>
          <li>[<u>-16, 27, 65, -2, 58</u>, -92, <u>-71, -68</u>, ✨-61, -33]</li>
        </ul>
      </li>
      <li>[✨-61, -33] -33은 -61보다 더 크므로 찬스없이 제거될 수 있다. 👉 따라서 <code class="language-plaintext highlighter-rouge">-61</code>은 최후까지 살아남을 수 있다.</li>
    </ul>
  </li>
</ul>

<h3 id="-1-차-풀이-시간-초과">✈ 1 차 풀이 (⏰시간 초과)</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">minIndex</span> <span class="o">=</span> <span class="n">min_element</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="c1">// 최소값 인덱스</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">// 모든 풍선들 순회하면서 최후까지 살아남을 수 있는 풍선인지 검사 후 카운팅해야 함</span>
        <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">minIndex</span><span class="p">){</span>  <span class="c1">// 현재 풍선이 최소값 보다 왼쪽에 있는 풍선일 때</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span> <span class="c1">// 현재 풍선보다 왼쪽 (최소값이 제거해줄 수 없는 공간)에 </span>
                <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span> <span class="c1">// 현재 풍선보다 작은 풍선이 있다면 👉 현재 풍선은 최후까지 살아남을 수 없는 풍선!</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">minIndex</span><span class="p">){</span>  <span class="c1">// 현재 풍선이 최소값 보다 오른쪽에 있는 풍선일 때</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span> <span class="c1">// 현재 풍선보다 오른쪽 (최소값이 제거해줄 수 없는 공간)에 </span>
                <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>  <span class="c1">// 현재 풍선보다 작은 풍선이 있다면 👉 현재 풍선은 최후까지 살아남을 수 없는 풍선!</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="n">answer</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 위 검사에 모두 걸리지 않은 경우에만 카운팅.</span>
        <span class="c1">// i == minIndex 최소값 풍선의 경우는 무조건 이 경우에 걸려서 카운팅 됨.</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/42318591/108330412-e875a780-7210-11eb-8e36-bff769209d8e.png" alt="image" /></p>

<p><em>for(int j = 0; j &lt; i; j++)</em> 이 정도만 이중 for문 돌리는 것도 시간초과가 나는구나! ㅠㅠ</p>

<ul>
  <li>현재 풍선이 최소값 풍선보다 왼쪽에 있다면 👉 현재 풍선의 <strong>왼쪽 범위</strong>에 더 작은 값이 있다면 살아남기 불가능한 풍선</li>
  <li>현재 풍선이 최소값 풍선보다 오른쪽에 있다면 👉 현재 풍선의 <strong>오른쪽 범위</strong>에 더 작은 값이 있다면 살아남기 불가능한 풍선</li>
</ul>

<p>그러니 각각 왼쪽 범위, 오른쪽 범위를 굳이 순회하며 더 작은 값 있는지 찾을 필요 없이! <u>왼쪽 범위와 오른쪽 범위 각각의 "최소값"과의 비교만 해보면 된다.</u> 이걸 바탕으로 고친 풀이가 아래 풀이이다.</p>

<p><br /></p>

<h3 id="-2-차-풀이-">✈ 2 차 풀이 ⭕</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 👉 최소값 풍선은 무조건 살아남을 수 있다! 최소값 포함하기 위해 answer을 1 로 초기화</span>
    <span class="kt">int</span> <span class="n">minIndex</span> <span class="o">=</span> <span class="n">min_element</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">tempMin</span> <span class="o">=</span> <span class="mi">1000000000</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">minIndex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>  <span class="c1">// 최소값 풍선보다 왼쪽 범위</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tempMin</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span> <span class="c1">// 왼쪽부터 쭉 업뎃해온 최소값이 현재의 풍선이 더 크다면 👉 현재의 풍선은 자신의 왼쪽에 있는 풍선들보다 작다는 것이므로 문제 없다. </span>
            <span class="n">tempMin</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// 최소값 업뎃</span>
            <span class="n">answer</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 최후까지 살아남을 수 있는 풍선입니다~</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">tempMin</span> <span class="o">=</span> <span class="mi">1000000000</span><span class="p">;</span> 
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">minIndex</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span> <span class="c1">// 최소값 풍선보다 오른쪽 범위</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tempMin</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span> <span class="c1">// 오른쪽부터 쭉 업뎃해온 최소값이 현재의 풍선이 더 크다면 👉 현재의 풍선은 자신의 오른쪽에 있는 풍선들보다 작다는 것이므로 문제 없다. </span>
            <span class="n">tempMin</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// 최소값 업뎃</span>
            <span class="n">answer</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 최후까지 살아남을 수 있는 풍선입니다~</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/42318591/108331832-8158f280-7212-11eb-8299-0682e035c613.png" alt="image" /></p>

<p>이렇게 풀면 <strong>O(N)</strong> 시간 복잡도를 보장할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[-16, 27, 65, 2, 58, -92, -71, -68, -61, -33]
</code></pre></div></div>

<ul>
  <li>2가 최후까지 살아남을 수 있는 풍선인지를 검사할 땐 <code class="language-plaintext highlighter-rouge">tempMin</code>은 -16 인 상태일 것이다. 2 &gt; -16 이므로 2번 풍선은 최후까지 살아남을 수 없다.</li>
  <li>-68이 최후까지 살아남을 수 있는 풍선인지를 검사할 땐 <code class="language-plaintext highlighter-rouge">tempMin</code>은 -61 인 상태일 것이다. -68 &lt; -61 이므로 -68번 풍선은 자신의 오른쪽 범위보다 더 작다는 것이므로 최후까지 살아남을 수 있다. <code class="language-plaintext highlighter-rouge">tempMin</code>은 -68 로 업데이트 된다.</li>
</ul>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>
:ET