var store = [{
        "title": "Chapter 1. 재귀(Recursion) : 개념과 기본 예제들",
        "excerpt":"권오흠 교수님의 유튜브 강의 영리한 프로그래밍을 위한 알고리즘 강좌 를 듣고 정리한 필기입니다. 😀 Chapter1. Recursion 🔔 Recursion Recursion : 자기 자신을 호출 하는 함수 = 재귀 함수 무한 루프에 빠지지 않으려면 재귀 함수는 자기 자신을 호출하기 때문에 무한 루프에 빠질 수 있다. 따라서 적어도 하나의 더 이상 자기 자신을...","categories": ["Algorithm Lesson 1"],
        "tags": ["Algorithm","Recursion"],
        "url": "http://localhost:4000/algorithm%20lesson%201/chapter1-1/",
        "teaser": null
      },{
        "title": "Chapter 1-1. Big-O 표기법",
        "excerpt":"인프런에 있는 Rookiss님의 강의 Part2: 자료구조와 알고리즘 를 듣고 정리한 필기입니다. 😀 🔔 Big-O 표기법 사용하는 이유 Big-O 표기법 알고리즘의 성능을 객관적으로 측정하기 위하여 사용. 단순히 실행 속도를 비교하는 것으로 알고리즘 성능을 측정하는건 컴퓨터 실행 환경에 따라 차이가 있기 때문에 별로 좋지 못하다. 입력이 적은 구간과 많은 구간에서 성능이 확연히...","categories": ["Algorithm Lesson 2"],
        "tags": ["Algorithm","Data Structure"],
        "url": "http://localhost:4000/algorithm%20lesson%202/chapter1-1/",
        "teaser": null
      },{
        "title": "Chapter 1-2. C# 준비",
        "excerpt":"인프런에 있는 Rookiss님의 강의 Part2: 자료구조와 알고리즘 를 듣고 정리한 필기입니다. 😀 🔔 게임의 3 단계 입력 유저의 입력 게임 로직 입력에 따른 어떤 실행 렌더링 로직에 따라 게임 화면에 그래픽을 그려 줌 🔔 Console Console.WriteLine 콘솔 창에 문자열 출력하고 자동으로 한 줄 띄워준다. (Line) Console.WriteLine(“문자열) Console.WriteLine(); 단순 개행. std::endl;...","categories": ["Algorithm Lesson 2"],
        "tags": ["Algorithm","Data Structure","C Sharp"],
        "url": "http://localhost:4000/algorithm%20lesson%202/chapter1-2/",
        "teaser": null
      },{
        "title": "No.9 모두의 약수 개수",
        "excerpt":"인프런에 있는 김태원님의 강의 IT 취업을 위한 알고리즘 문제풀이 with C/C++ 를 듣고 문제를 푼 후 정리한 오답노트입니다. 😀 9. 모두의 약수 문제 설명 제한 시간 1초 8 을 입력하면 1 ~ 8 범위의 8 개 정수의 각각 약수의 개수를 순서대로 출력한다. 제한시간은 1초다. 입력 👉 8 출력 👉 1...","categories": ["Coding Test Lesson"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/coding%20test%20lesson/withcpp-no9/",
        "teaser": null
      },{
        "title": "Chater 1. C 언어 개념 : 포인터, 동적 할당, 문자열",
        "excerpt":"권오흠 교수님의 유튜브 강의 영리한 프로그래밍을 위한 알고리즘 강좌 를 듣고 정리한 필기입니다. 😀 Chapter1. 자료구조를 위한 C 언어 지식 🔔 포인터 메모리 데이터를 보관 하는 장소 메모리 1 칸당 8bit = 1 byte의 데이터를 담을 수 있다. 32bit 컴퓨터 환경 주소 0 번지 ~ \\(2^{32}-1\\) 번지까지 있는, 즉 \\(2^{32}\\)...","categories": ["DataStructure"],
        "tags": ["Algorithm","Data Structure","C"],
        "url": "http://localhost:4000/datastructure/chapter1-1/",
        "teaser": null
      },{
        "title": "No.13 가장 많이 사용된 자릿수",
        "excerpt":"인프런에 있는 김태원님의 강의 IT 취업을 위한 알고리즘 문제풀이 with C/C++ 를 듣고 문제를 푼 후 정리한 오답노트입니다. 😀 9. 가장 많이 사용된 자릿수 문제 설명 어떤 자연수가 입력되면 자릿수 중 가장 많이 사용된 숫자를 출력한다. ex) 123056565625 가 입력되면 4번으로 가장 많이 사용된 5가 출력된다. 조건 자연수의 길이는 100을...","categories": ["Coding Test Lesson"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/coding%20test%20lesson/withcpp-no13/",
        "teaser": null
      },{
        "title": "No.15 소수의 개수",
        "excerpt":"인프런에 있는 김태원님의 강의 IT 취업을 위한 알고리즘 문제풀이 with C/C++ 를 듣고 문제를 푼 후 정리한 오답노트입니다. 😀 15. 소수의 개수 문제 설명 자연수 N이 입력되면 1부터 N까지의 소수의 개수를 출력하는 프로그램. 예를 들어 20이 입력되면 8 출력! 20의 소수는 2, 3, 5, 7, 11, 13, 17, 19로 총...","categories": ["Coding Test Lesson"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/coding%20test%20lesson/withcpp-no15/",
        "teaser": null
      },{
        "title": "[고득점Kit][해시] 완주하지 못한 선수 ⭐",
        "excerpt":"[해시] 완주하지 못한 선수 난이도 ⭐ 3 / 3 ⭕ 문제 수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 📢...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Hash"],
        "url": "http://localhost:4000/programmers/kit1/",
        "teaser": null
      },{
        "title": "[고득점Kit][해시] 전화번호 목록 (unordered_set, 테케 추가 후 다시 풀이) ⭐⭐",
        "excerpt":"[해시] 전화번호 목록 난이도 ⭐⭐ ⭕ 문제 내 풀이 이전 풀이 (예전엔 정답이었지만 이젠 ⏰시간초과 나는 풀이) #include &lt;string&gt; #include &lt;vector&gt; #include &lt;map&gt; using namespace std; bool solution(vector&lt;string&gt; phone_book) { bool answer = true; map&lt;string, int&gt; strMap; for (auto &amp; elem : phone_book) { if (strMap.find(elem) == strMap.end()) { int...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Hash"],
        "url": "http://localhost:4000/programmers/kit2/",
        "teaser": null
      },{
        "title": "[고득점Kit][해시] 위장 ⭐⭐",
        "excerpt":"[해시] 위장 난이도 ⭐⭐ ❌ 문제 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다. 예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다. 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Hash"],
        "url": "http://localhost:4000/programmers/kit3/",
        "teaser": null
      },{
        "title": "[고득점Kit][해시] 베스트 앨범 ⭐⭐⭐",
        "excerpt":"[해시] 베스트 앨범 난이도 ⭐⭐⭐ 문제 스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다. 1. 속한 노래가 많이 재생된 장르를 먼저 수록합니다. 2. 장르 내에서 많이 재생된 노래를 먼저 수록합니다. 3. 장르 내에서 재생...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Hash"],
        "url": "http://localhost:4000/programmers/kit4/",
        "teaser": null
      },{
        "title": "[고득점Kit][큐] 다리를 지나는 트럭 ⭐⭐",
        "excerpt":"[스택/큐] 다리를 지나는 트럭 난이도 ⭐⭐ ❌ 문제 트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length이고 다리는 무게 weight까지 견딥니다. ※ 트럭이 다리에 완전히 오르지 않은 경우, 이 트럭의...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Queue"],
        "url": "http://localhost:4000/programmers/kit5/",
        "teaser": null
      },{
        "title": "[고득점Kit][스택] 탑 ⭐⭐",
        "excerpt":"[스택/큐] 탑 난이도 ⭐⭐ 문제 수평 직선에 탑 N대를 세웠습니다. 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다. 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다. 또한, 한 번 수신된 신호는 다른 탑으로 송신되지 않습니다. 예를 들어 높이가 6, 9, 5, 7, 4인 다섯 탑이 왼쪽으로 동시에 레이저 신호를 발사합니다. 그러면,...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Stack"],
        "url": "http://localhost:4000/programmers/kit6/",
        "teaser": null
      },{
        "title": "[백준 10953][🤎2] A + B(6) (입출력)",
        "excerpt":"A + B (6) 10953번 문제 👉 https://www.acmicpc.net/problem/10953 난이도 👉 브론즈 2 내 풀이 #include &lt;stdio.h&gt; using namespace std; int main() { int n, a, b; scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) { scanf(\"%d,%d\", &amp;a, &amp;b); printf(\"%d\\n\", a + b); } return 0; } scanf(\"%d,%d\", &amp;a,...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/10953/",
        "teaser": null
      },{
        "title": "[BOJ] C++ 입출력 관련 문제들",
        "excerpt":"⭕ 정답. 배운 점이 있거나 고민이 많았어서 필기하고 싶은 문제 ⏰ 시간 초과 ❌ 오답 &amp; 중도 포기 🔔 10953 : A + B (6) 문제 👉 https://www.acmicpc.net/problem/11021 내 풀이 #include &lt;stdio.h&gt; using namespace std; int main() { int n, a, b; scanf(\"%d\", &amp;n); for(int i = 0; i &lt;...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/iostream/",
        "teaser": null
      },{
        "title": "[백준 10993][💛4] 별찍기(18) (재귀, DFS) ",
        "excerpt":"별찍기 18 10993번 문제 👉 https://www.acmicpc.net/problem/10993 난이도 👉 골드 4 내 풀이 1차 풀이 📢 출력 형식이 잘못 되었습니다 #include &lt;iostream&gt; using namespace std; char arr[1023][2045]; int getPow(int n, int m) { if (m == 0) return 1; return getPow(n, m - 1) * n; } void draw(int len, int...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp","DFS"],
        "url": "http://localhost:4000/boj/10993/",
        "teaser": null
      },{
        "title": "[백준 11718][🤎3] 그대로 출력하기 (입출력)",
        "excerpt":"그대로 출력하기 11718번 문제 👉 https://www.acmicpc.net/problem/11718 난이도 👉 브론즈 3 내 풀이 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { string str; for(int i = 0; i &lt; 100; i++) { getline(cin, str); cout &lt;&lt; str &lt;&lt; endl; } return 0; } string의 getline을 사용했다. 매 반복마다 버퍼로부터...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/11718/",
        "teaser": null
      },{
        "title": "[백준 10818][🤎3] 최소, 최대 ",
        "excerpt":"최소, 최대 10818번 문제 👉 https://www.acmicpc.net/problem/10818 난이도 👉 브론즈 3 1 차 풀이 ❌ #include &lt;iostream&gt; using namespace std; int main() { int n; int temp; int min = 1000000, max = -1000000; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; temp; if (temp...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/10818/",
        "teaser": null
      },{
        "title": "[백준 10994][🤍4] 별 찍기(19) (재귀, DFS) ",
        "excerpt":"별 찍기 19 10994번 문제 👉 https://www.acmicpc.net/problem/10994 난이도 👉 실버 4 1차 풀이 : 반복문 ⭕ #include &lt;iostream&gt; using namespace std; int main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= 2 * n - 1; i++) { for(int j = 1; j &lt;= i...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp","DFS"],
        "url": "http://localhost:4000/boj/10994/",
        "teaser": null
      },{
        "title": "[백준 11720][🤎2] 숫자의 합 (입출력) ",
        "excerpt":"숫자의 합 11720번 문제 👉 https://www.acmicpc.net/problem/11720 난이도 👉 브론즈 2 내 풀이 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { int n, sum = 0; string str; cin &gt;&gt; n; cin &gt;&gt; str; for(int i = 0; i &lt; str.length(); i++) { sum += str[i] - 48; }...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/11720/",
        "teaser": null
      },{
        "title": "[백준 11721][🤎2] 열 개씩 끊어 출력하기 (입출력) ",
        "excerpt":"열 개씩 끊어 출력하기 11721번 문제 👉 https://www.acmicpc.net/problem/11721 난이도 👉 브론즈 2 내 풀이 #include &lt;iostream&gt; using namespace std; int main() { char buf[11]; while(true) { cin.get(buf, 11); if (!cin.gcount()) break; cout &lt;&lt; buf &lt;&lt; endl; } return 0; } gcount()가 0 이면, 즉 입력 버퍼에 이제 읽어들일게 아무것도 없으면...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/11721/",
        "teaser": null
      },{
        "title": "[백준 2447][🤍1] 별 찍기(10) (재귀, DFS)",
        "excerpt":"별 찍기 10 2447번 문제 👉 https://www.acmicpc.net/problem/2447 난이도 👉 실버 1 내 풀이 ⭕ #include &lt;iostream&gt; using namespace std; char arr[6561][6561]; void draw(int row, int col) { for(int i = 0; i &lt; 3; i++) { for(int j = 0; j &lt; 3; j++) { if (!(i == 1 &amp;&amp;...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp","DFS"],
        "url": "http://localhost:4000/boj/2447/",
        "teaser": null
      },{
        "title": "[백준 2448][💛4] 별 찍기(11) (재귀, DFS) ",
        "excerpt":"별 찍기 11 2448번 문제 👉 https://www.acmicpc.net/problem/2448 난이도 👉 골드 4 내 풀이 ⭕ #include &lt;iostream&gt; using namespace std; char arr[3072][6143]; void draw(int row, int col) { // 첫번째 줄 (꼭직점에 * 1개) arr[row][col] = '*'; // 두번째 줄 (* 2개) arr[row + 1][col - 1] = '*'; arr[row +...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp","DFS"],
        "url": "http://localhost:4000/boj/2448/",
        "teaser": null
      },{
        "title": "[백준 2741][🤎3] N 찍기 (입출력) ",
        "excerpt":"N 찍기 2741번 문제 👉 https://www.acmicpc.net/problem/2741 난이도 👉 브론즈 3 1 차 풀이 🕑 만만하게 봤다가 시간 초과 떴던 문제… 😱 #include &lt;iostream&gt; using namespace std; int main() { int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cout &lt;&lt; i &lt;&lt; endl; } return...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/2741/",
        "teaser": null
      },{
        "title": "[고득점Kit][스택] 쇠막대기 ⭐⭐",
        "excerpt":"[스택/큐] 쇠막대기 난이도 ⭐⭐ 문제 내 풀이 정말 오랜만에 고민 길게 안하고 바로 풀었던 문제여서 뿌듯했다. 웬일인지 테스트 케이스들도 전부 한방에 통과하길래 얼떨떨.. 원래 같으면 실패실패실패실패.. 떠줘야 정상인데 ㅎㅎ.. #include &lt;string&gt; #include &lt;stack&gt; #include &lt;vector&gt; using namespace std; int solution(string arrangement) { int answer = 0; int count = 0;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Stack"],
        "url": "http://localhost:4000/programmers/kit7/",
        "teaser": null
      },{
        "title": "[고득점Kit][스택] 주식 가격 ⭐⭐",
        "excerpt":"[스택/큐] 주식 가격 난이도 ⭐⭐ 문제 내 풀이 첫 번째 풀이 #include &lt;string&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; solution(vector&lt;int&gt; prices) { vector&lt;int&gt; answer; for(int i = 0; i &lt; prices.size(); i++) { int count = 0; for(int j = i + 1; j &lt; prices.size(); j++) { count++; if...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Stack"],
        "url": "http://localhost:4000/programmers/kit8/",
        "teaser": null
      },{
        "title": "[고득점Kit][큐] 기능개발 ⭐⭐",
        "excerpt":"[스택/큐] 기능개발 난이도 ⭐⭐ 문제 내 풀이 #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; vector&lt;int&gt; solution(vector&lt;int&gt; progresses, vector&lt;int&gt; speeds) { vector&lt;int&gt; answer; queue&lt;int&gt; q; // 각 작업마다 몇일간 작업 가능한지 계산한 후 큐에 삽입 // 큐에는 작업마다 소요되는 일 수가 원소로 들어간다. for(int i = 0; i &lt;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Queue"],
        "url": "http://localhost:4000/programmers/kit9/",
        "teaser": null
      },{
        "title": "[고득점Kit][큐] 프린터 ⭐⭐",
        "excerpt":"[스택/큐] 프린터 난이도 ⭐⭐ 문제 내 풀이 프로그래머스 고득점 Kit의 스택/큐 마지막 문제.. 어느정도 연습이 잘 됐나보다. 실패 없이 한방에 통과 ^ㅁ^ #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; bool compare(const int &amp; a, const int &amp; b) { return a &gt; b; // 내림차순 정렬...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Queue"],
        "url": "http://localhost:4000/programmers/kit10/",
        "teaser": null
      },{
        "title": "[고득점Kit][힙] 더 맵게 ⭐⭐",
        "excerpt":"[힙] 더 맵게 난이도 ⭐⭐ 문제 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; int solution(vector&lt;int&gt; scoville, int K) { int answer = 0; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; for(auto &amp; elem : scoville) { pq.push(elem); } while(true) { if (pq.size() &gt; 1) { int sum =...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Priority Queue","Heap"],
        "url": "http://localhost:4000/programmers/kit11/",
        "teaser": null
      },{
        "title": "[고득점Kit][힙] 라면 공장 ⭐⭐",
        "excerpt":"[힙] 라면 공장 난이도 ⭐⭐ 문제 풀이 어떻게 풀어야할지 아예 모르겠어서.. 30분만 딱 고민해본 후 다른 분들의 풀이를 참고했던 문제다. 근데 다른 분들의 풀이를 보자마자 생각보다 간단한 풀이였다는 것을 알게 되서 좀 더 고민해볼걸 그랬나 싶었다. 😥 밀가루를 최소한으로 공급받으려면 재고가 0이 될 때까지 최대한 쓰고난 후 최대로 공급되는 양으로...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Priority Queue","Heap"],
        "url": "http://localhost:4000/programmers/kit12/",
        "teaser": null
      },{
        "title": "[고득점Kit][힙] 디스크 컨트롤러 ⭐⭐⭐",
        "excerpt":"[힙] 디스크 컨트롤러 난이도 ⭐⭐⭐ 문제 풀이 틀린 내 풀이 #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; using namespace std; struct compare_queue { bool operator() (vector&lt;int&gt; a, vector&lt;int&gt; b) { return a[1] - a[0] &gt; b[1] - b[0]; } }; bool compare_sort(vector&lt;int&gt; a, vector&lt;int&gt; b) { if...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Priority Queue","Heap"],
        "url": "http://localhost:4000/programmers/kit13/",
        "teaser": null
      },{
        "title": "[고득점Kit][힙] 이중 우선순위 큐 ⭐⭐⭐",
        "excerpt":"[힙] 이중 우선순위 큐 난이도 ⭐⭐⭐ 문제 내 풀이 ⭕ 별 3 개 짜리 문제들 중에선 처음으로 수월하게 빨리 풀었던 문제인 것 같다.. 어리 둥절 🤔 우선 순위 큐 2 개를 두었다. 최대값을 우선으로 pop 하는 maxHeap 우선순위 큐 최대값 삭제하는 연산 때 이 우선순위 큐에서 pop 연산 최소값을 우선으로...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Priority Queue","Heap"],
        "url": "http://localhost:4000/programmers/kit14/",
        "teaser": null
      },{
        "title": "보충 강의) 이진 검색 트리 & 인접 리스트 구현하기",
        "excerpt":"권오흠 교수님의 유튜브 강의 영리한 프로그래밍을 위한 알고리즘 강좌 를 듣고 정리한 필기입니다. 😀 주, 지명, 위도, 경도, 수도로부터의 거리 데이터를 가진 지역 들을 이진 검색 트리에 저장할 것 서로 거리가 10km 이내의 지역들 사이엔 그래프 edge가 있다고 가정. 인접 리스트 📜place.h typedef struct place { int index; char *state;...","categories": ["Algorithm Lesson 1"],
        "tags": ["Algorithm","Binary Search Tree"],
        "url": "http://localhost:4000/algorithm%20lesson%201/etc1/",
        "teaser": null
      },{
        "title": "[고득점Kit][정렬] K 번째 수 ⭐",
        "excerpt":"[정렬] K 번째 수 난이도 ⭐ 문제 내 풀이 ⭕ 제출 한 후 다른 분의 풀이를 봤는데 내 풀이와 너무 똑같아서 놀랐다. #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; vector&lt;int&gt; solution(vector&lt;int&gt; array, vector&lt;vector&lt;int&gt;&gt; commands) { vector&lt;int&gt; answer; vector&lt;int&gt; temp; for (auto &amp; elem : commands) { temp =...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Sorting"],
        "url": "http://localhost:4000/programmers/kit15/",
        "teaser": null
      },{
        "title": "[고득점Kit][정렬] 가장 큰 수 ⭐⭐",
        "excerpt":"[정렬] 가장 큰 수 난이도 ⭐⭐ 문제 배울게 많은 문제였다! 내 풀이 (feat. 삽질 과정) ❌ 정답인 풀이는 아래에 있습니다. 1 ~ 3 차 이 풀이들은 제 틀린 풀이라는 것에 유념해주세요! 모 ~ 든 조합을 다 따져본 후 최대값을 구하는건 엄청나게 비효율적이라는 것은 인지 하고 시작했다. numbers의 길이가 100,000 까지도...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Sorting"],
        "url": "http://localhost:4000/programmers/kit16/",
        "teaser": null
      },{
        "title": "[고득점Kit][정렬] H-Index ⭐⭐",
        "excerpt":"[정렬] H-Index 난이도 ⭐⭐ 문제 내 풀이 ⭕ h-index가 citations의 원소가 아닐 수 있다는 것에 유념해야 한다. 처음엔 당연히 citations의 원소이겠거니 했는데.. 항상 코테에서 ‘당연히’라는건 없고 ㅎㅎ 반례가 되는 케이스가 있는지 먼저 찾아보는 그런 습관을 들이는게 중요한 것 같다. 예를 들어 citations가 [100, 50] h-index는 2 가 될 것이다. 👉...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Sorting"],
        "url": "http://localhost:4000/programmers/kit17/",
        "teaser": null
      },{
        "title": "[고득점Kit][완전 탐색] 모의고사 ⭐",
        "excerpt":"[완전 탐색] 모의고사 난이도 ⭐ 문제 내 풀이 ⭕ 통과된 풀이긴 했지만 좀 아쉽다! 더 간단하게 할 수 있었는데 😢 #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; bool compare(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) { return a.second &gt; b.second; } vector&lt;int&gt; solution(vector&lt;int&gt; answers) { vector&lt;int&gt; answer; vector&lt;pair&lt;int,int&gt;&gt; temp{make_pair(0,...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Brute Force"],
        "url": "http://localhost:4000/programmers/kit18/",
        "teaser": null
      },{
        "title": "[고득점Kit][완전 탐색] 소수 찾기 ⭐⭐",
        "excerpt":"[완전 탐색] 소수 찾기 난이도 ⭐⭐ 문제 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;set&gt; #include &lt;algorithm&gt; #include &lt;math.h&gt; using namespace std; set&lt;int&gt; allComb; void permutation(string str, int depth, int n, int r) { if (depth == r) { string temp = \"\"; for(int i = 0; i &lt;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Brute Force","Recursion"],
        "url": "http://localhost:4000/programmers/kit19/",
        "teaser": null
      },{
        "title": "[고득점Kit][완전 탐색] 카펫 ⭐⭐",
        "excerpt":"[완전 탐색] 카펫 난이도 ⭐⭐ 문제 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; solution(int brown, int yellow) { vector&lt;int&gt; answer; int width, height; for(int i = 1; ; i++) { if (yellow % i != 0) continue; width = yellow / i; height = i; if(width...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Brute Force"],
        "url": "http://localhost:4000/programmers/kit20/",
        "teaser": null
      },{
        "title": "[고득점Kit][그리디] 체육복 ⭐",
        "excerpt":"[그리디] 체육복 난이도 ⭐ 문제 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int solution(int n, vector&lt;int&gt; lost, vector&lt;int&gt; reserve) { int answer = n - lost.size(); for(int i = 0; i &lt; lost.size(); i++) { for(int j = 0; j &lt; reserve.size(); j++) { if (lost[i] ==...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Greedy"],
        "url": "http://localhost:4000/programmers/kit21/",
        "teaser": null
      },{
        "title": "(C++) 순열(Permutation) 구현하기",
        "excerpt":"순열은 완전 탐색(브루트 포스) 문제에서 많이 등장하므로 잘 익혀놓자. 순열이란 선택 순서가 결과에 영향을 미치는 경우! (1,2)와 (2,1)은 달라야 할 때 순서를 따진다. abc 와 acb는 서로 다른 존재이다. 중복을 허용하지 않는다. nPr 5P3 = 5 X 4 X 3 4P1 = 4 4P4 = 4! = 4 X 3...","categories": ["Algorithm"],
        "tags": ["Algorithm","Coding Test","Cpp","Recursion","STL"],
        "url": "http://localhost:4000/algorithm/permutation/",
        "teaser": null
      },{
        "title": "(C++) 중복 순열(Repeated Permutation) 구현하기",
        "excerpt":"중복 순열이란 순서를 따진다. abc 와 acb는 서로 다른 존재이다. 중복을 허용한다 길이가 n 인 범위의 r 자리 중복 순열 경우의 수 👉 n을 r번 곱하면 된다. 길이가 3 인 범위의 4 자리 중복 순열 경우의 수 👉 \\(3 X 3 X 3 X 3 = 3^4 = 81\\) 구현...","categories": ["Algorithm"],
        "tags": ["Algorithm","Coding Test","Cpp","Recursion","STL"],
        "url": "http://localhost:4000/algorithm/repeated-permutation/",
        "teaser": null
      },{
        "title": "(C++) 조합(Combination) 구현하기",
        "excerpt":"조합이란 선택 순서가 결과에 영향을 주지 않는 경우! (1,2)이나 (2,1)이나 결과가 같을 때 순서를 따지지 않는다. abc와 acb는 같은 존재다. 중복을 허용하지 않는다. nCr 5C3 = 5P3 / 3! = (5 X 4 X 3) / (3 X 2 X 1) 순열과 다르게 방문 체크, 복원이 필요 없다. 어떤 원소로...","categories": ["Algorithm"],
        "tags": ["Algorithm","Coding Test","Cpp","Recursion","STL"],
        "url": "http://localhost:4000/algorithm/combination/",
        "teaser": null
      },{
        "title": "(C++) 중복 조합(Repeated Combination) 구현하기",
        "excerpt":"중복 조합이란 순서를 따지지 않는다. abc와 acb는 같은 존재다. 중복을 허용한다. 선택 했던 것을 다시 선택할 수 있다. nHr = n+r-1Cr로 경우의 수를 구할 수 있다. n개에서 r개를 중복을 허용해서 뽑을을 수 있다. 중복을 허용하므로 n보다 r이 더 클 수도 있다. {2, 3}에서 5개 뽑기 가능 위 공식의 원리 {1,...","categories": ["Algorithm"],
        "tags": ["Algorithm","Coding Test","Cpp","Recursion","STL"],
        "url": "http://localhost:4000/algorithm/repeated-combination/",
        "teaser": null
      },{
        "title": "[고득점Kit][그리디] 큰 수 만들기 ⭐⭐",
        "excerpt":"[그리디] 큰 수 만들기 난이도 ⭐⭐ 문제 내 풀이 1차 풀이 ❌ (시간 초과) #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; using namespace std; bool compare(pair&lt;char, int&gt; &amp; a, pair&lt;char, int&gt; &amp; b) { if (a.first == b.first) return a.second &lt; b.second; else return a.first &gt; b.first; } string...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Greedy"],
        "url": "http://localhost:4000/programmers/kit22/",
        "teaser": null
      },{
        "title": "[고득점Kit][그리디] 조이스틱 ⭐⭐",
        "excerpt":"[그리디] 조이스틱 난이도 ⭐⭐ 문제 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;unordered_map&gt; #include &lt;iostream&gt; using namespace std; int solution(string name) { int answer = 0; unordered_map&lt;char, int&gt; alphabet; for(int i = 0; i &lt; 13; i++) alphabet['A' + i] = i; for(int i = 13; i &lt; 26;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Greedy"],
        "url": "http://localhost:4000/programmers/kit23/",
        "teaser": null
      },{
        "title": "Chapter 2. 배열, 동적 배열, 연결 리스트 비교",
        "excerpt":"인프런에 있는 Rookiss님의 [C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part2: 자료구조와 알고리즘 강의를 듣고 정리한 필기입니다. 😀 🌜 강의 들으러 가기 Click 선형 자료 구조 데이터들을 일렬로 나열된 형태로 저장하고 싶을 때 사용하는 자료 구조 선형 자료 구조 👉 자료를 순차적으로 나열 배열 동적 배열 연결 리스트 비선형 자료...","categories": ["Algorithm Lesson 2"],
        "tags": ["Algorithm","Data Structure","C Sharp"],
        "url": "http://localhost:4000/algorithm%20lesson%202/chapter2/",
        "teaser": null
      },{
        "title": "Chapter 3-1. 맵 만들기",
        "excerpt":"인프런에 있는 Rookiss님의 [C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part2: 자료구조와 알고리즘 강의를 듣고 정리한 필기입니다. 😀 🌜 강의 들으러 가기 Click Chapter 3. 미로 준비 🚖 미로 준비 미로는 한 칸 한 칸마다 채워져 있는 원 하나로 그린다. 미로의 크기는 size X size 로 지정. 미로 배열은 이차원...","categories": ["Algorithm Lesson 2"],
        "tags": ["Algorithm","Data Structure","C Sharp"],
        "url": "http://localhost:4000/algorithm%20lesson%202/chapter3-1/",
        "teaser": null
      },{
        "title": "Chapter 3-2. 미로 생성 알고리즘(Binary Tree, Side Winder)",
        "excerpt":"인프런에 있는 Rookiss님의 [C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part2: 자료구조와 알고리즘 강의를 듣고 정리한 필기입니다. 😀 🌜 강의 들으러 가기 Click Chapter 3. 미로 준비 가장 자리만 벽으로 하는 것이 아닌, 진짜 미로처럼 벽을 배치해 보자. 미로 생성 알고리즘 Binary Tree Side Winder 이 두개 말고도 많지만 이...","categories": ["Algorithm Lesson 2"],
        "tags": ["Algorithm","Data Structure","C Sharp"],
        "url": "http://localhost:4000/algorithm%20lesson%202/chapter3-2/",
        "teaser": null
      },{
        "title": "Chapter 3-3. 플레이어 이동",
        "excerpt":"인프런에 있는 Rookiss님의 [C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part2: 자료구조와 알고리즘 강의를 듣고 정리한 필기입니다. 😀 🌜 강의 들으러 가기 Click Chapter 3. 미로 준비 📜Player.cs 플레이어의 위치 결정 및 업데이트 using System; using System.Collections.Generic; using System.Text; namespace Algorithm { class Player { public int PosY { get;...","categories": ["Algorithm Lesson 2"],
        "tags": ["Algorithm","Data Structure","C Sharp"],
        "url": "http://localhost:4000/algorithm%20lesson%202/chapter3-3/",
        "teaser": null
      },{
        "title": "Chapter 3-4. 오른 손 법칙",
        "excerpt":"인프런에 있는 Rookiss님의 [C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part2: 자료구조와 알고리즘 강의를 듣고 정리한 필기입니다. 😀 🌜 강의 들으러 가기 Click Chapter 3. 미로 준비 🚖 목적지 📜Board.cs using System; using System.Collections.Generic; using System.Text; namespace Algorithm { class Board { const char CIRCLE = '\\u25cf'; public TileType[,] Tile...","categories": ["Algorithm Lesson 2"],
        "tags": ["Algorithm","Data Structure","C Sharp"],
        "url": "http://localhost:4000/algorithm%20lesson%202/chapter3-4/",
        "teaser": null
      },{
        "title": "Chapter 4-1. 스택과 큐",
        "excerpt":"인프런에 있는 Rookiss님의 [C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part2: 자료구조와 알고리즘 강의를 듣고 정리한 필기입니다. 😀 🌜 강의 들으러 가기 Click Chapter 4. 그래프 🚖 스택과 큐 using System; using System.Collections.Generic; namespace Excercise { class Program { static void Main(string[] args) { Stack&lt;int&gt; stack = new Stack&lt;int&gt;(); stack.Push(101);...","categories": ["Algorithm Lesson 2"],
        "tags": ["Algorithm","Data Structure","C Sharp","Stack","Queue"],
        "url": "http://localhost:4000/algorithm%20lesson%202/chapter4-1/",
        "teaser": null
      },{
        "title": "Chapter 4-2. 그래프",
        "excerpt":"인프런에 있는 Rookiss님의 [C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part2: 자료구조와 알고리즘 강의를 듣고 정리한 필기입니다. 😀 🌜 강의 들으러 가기 Click Chapter 4. 그래프 🚖 그래프 이론 그래프의 개념 그래프의 개념 👉 현실 세계의 사물이나 추상적인 개념간의 연결 관계를 표현. 정점(Vertex) 👉 데이터를 표현 (사물, 개념 등) 간선(Edge)...","categories": ["Algorithm Lesson 2"],
        "tags": ["Algorithm","Data Structure","C Sharp","Graph"],
        "url": "http://localhost:4000/algorithm%20lesson%202/chapter4-2/",
        "teaser": null
      },{
        "title": "Chapter 4-3. 그래프 순회 방법 1️⃣ - DFS(깊이 우선 탐색)",
        "excerpt":"인프런에 있는 Rookiss님의 [C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part2: 자료구조와 알고리즘 강의를 듣고 정리한 필기입니다. 😀 🌜 강의 들으러 가기 Click Chapter 4. 그래프 🚖 그래프 순회 방법 배열이나 리스트는 선형 자료 구조이므로 원소들을 차례대로 순회하면 되지만 그래프는 선형 자료 구조가 아닌, 한 정점에 연결된 정점들이 여러개일 수...","categories": ["Algorithm Lesson 2"],
        "tags": ["Algorithm","Data Structure","C Sharp","DFS"],
        "url": "http://localhost:4000/algorithm%20lesson%202/chapter4-3/",
        "teaser": null
      },{
        "title": "Chapter 4-4. 그래프 순회 방법 2️⃣ - BFS(너비 우선 탐색)",
        "excerpt":"인프런에 있는 Rookiss님의 [C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part2: 자료구조와 알고리즘 강의를 듣고 정리한 필기입니다. 😀 🌜 강의 들으러 가기 Click Chapter 4. 그래프 🚖 BFS 가까운 순서대로 방문한다. 출발 정점을 기준으로 가까운 순서대로 차례 차례 방문함. 예를 들어 순회을 0 정점에서 시작한다면 0 정점에서 거리 1 (간선...","categories": ["Algorithm Lesson 2"],
        "tags": ["Algorithm","Data Structure","C Sharp","BFS"],
        "url": "http://localhost:4000/algorithm%20lesson%202/chapter4-4/",
        "teaser": null
      },{
        "title": "Chapter 4-5. 다익스트라 최단 경로 알고리즘",
        "excerpt":"인프런에 있는 Rookiss님의 [C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part2: 자료구조와 알고리즘 강의를 듣고 정리한 필기입니다. 😀 🌜 강의 들으러 가기 Click Chapter 4. 그래프 🚖 다익스트라 최단 경로 알고리즘 모든 정점을 방문하되, 최단 경로로. 0 방문 예약 👉 1 (15), 3 (35) 0 을 지나 1 으로 온다면...","categories": ["Algorithm Lesson 2"],
        "tags": ["Algorithm","Data Structure","C Sharp","Graph","BFS"],
        "url": "http://localhost:4000/algorithm%20lesson%202/chapter4-5/",
        "teaser": null
      },{
        "title": "Chapter 5-1. 트리 이론과 구현",
        "excerpt":"인프런에 있는 Rookiss님의 [C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part2: 자료구조와 알고리즘 강의를 듣고 정리한 필기입니다. 😀 🌜 강의 들으러 가기 Click Chapter 5. 트리 🚖 트리 이론 트리 👉 계층적 구조를 갖는 데이터를 위한 자료 구조 ex) 회사 조직도 노드(Node) : 데이터를 표현 루트 노드는 트리를 상징하며, 부모가...","categories": ["Algorithm Lesson 2"],
        "tags": ["Algorithm","Data Structure","C Sharp","Graph"],
        "url": "http://localhost:4000/algorithm%20lesson%202/chapter5-1/",
        "teaser": null
      },{
        "title": "Chapter 5-2. 힙 트리 & 우선순위 큐",
        "excerpt":"인프런에 있는 Rookiss님의 [C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part2: 자료구조와 알고리즘 강의를 듣고 정리한 필기입니다. 😀 🌜 강의 들으러 가기 Click Chapter 5. 트리 🚖 힙 이진 트리 이진 트리 👉 모든 노드들이 자식 노드를 최대 2 개까지만 가지는 트리 이진 트리의 종류 이진 검색 트리 (Binary Search...","categories": ["Algorithm Lesson 2"],
        "tags": ["Algorithm","Data Structure","C Sharp","Queue"],
        "url": "http://localhost:4000/algorithm%20lesson%202/chapter5-2/",
        "teaser": null
      },{
        "title": "Chapter 6. A* 길찾기 알고리즘 구현",
        "excerpt":"인프런에 있는 Rookiss님의 [C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part2: 자료구조와 알고리즘 강의를 듣고 정리한 필기입니다. 😀 🌜 강의 들으러 가기 Click Chapter 6. A* 길찾기 알고리즘 🚖 A* 길찾기 알고리즘 개념 다익스트라와 비교 다익스트라 해당 지점에서 갈 수 있는 모든 경로에 대한 최단 거리를 찾는다. 👉 비효율적 따라서...","categories": ["Algorithm Lesson 2"],
        "tags": ["Algorithm","Data Structure","C Sharp"],
        "url": "http://localhost:4000/algorithm%20lesson%202/chapter6/",
        "teaser": null
      },{
        "title": "[고득점Kit][그리디] 구명 보트 ⭐⭐",
        "excerpt":"[그리디] 구명보트 난이도 ⭐⭐ 문제 내 풀이 ⭕ #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int solution(vector&lt;int&gt; people, int limit) { int answer = 0; sort(people.begin(), people.end()); int i = 0; int j = people.size() - 1; while(true) { if (i == j) { answer++; break; } if (i &gt;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Greedy"],
        "url": "http://localhost:4000/programmers/kit24/",
        "teaser": null
      },{
        "title": "[고득점Kit][그리디] 섬 연결하기 ⭐⭐⭐",
        "excerpt":"[그리디] 섬 연결하기 난이도 ⭐⭐⭐ 문제 내 풀이 ❌ 이 문제는 틀린 풀이 입니다! 참고하지 마세요!ㅠㅠㅠ 틀린 풀이이긴 하지만 나중에 다시 풀기위해 기록하는 차원에서 정리한 것입니다. 이 풀이는 테스트 케이스 7번만 틀린다. 온갖 테스트 케이스 12개 가량을 추가하여 다 테스트 해봤지만 다 통과되었고 오직 프로그래머스에서 제공하는 테스트 케이스 7번만 틀렸다.....","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Greedy","Graph"],
        "url": "http://localhost:4000/programmers/kit25/",
        "teaser": null
      },{
        "title": "(C++) 최소 신장 트리 MST, 크루스칼 알고리즘, 프림 알고리즘",
        "excerpt":"🌜 신장 트리 Spanning Tree 어떤 하나의 그래프 中에서 1️⃣ 모든 정점을 포함하되 2️⃣ 최소로 연결 되도록 일부 간선들을 선택하여 만든 트리. 단, 3️⃣ 사이클이 생성되선 안된다. 어떤 그래프로 신장 트리를 만들 때 사이클을 만드는 간선은 선택하지 않는다. 최소 연결 👉 간선의 수가 가장 적다. 정점의 수가 n개 일 때,...","categories": ["Algorithm"],
        "tags": ["Algorithm","Coding Test","Cpp","Graph"],
        "url": "http://localhost:4000/algorithm/mst/",
        "teaser": null
      },{
        "title": "(C++) Union-Find 알고리즘",
        "excerpt":"🚕 Union-Find 알고리즘 서로소 집합(Disjoing Set) 알고리즘 이라고도 불리우며, 선택한 두 노드가 서로 같은 그래프에 속해있는지, 즉 연결이 되어 있는지를 검사하고(연결이 안되있다면 두 노드는 서로소이며 서로 통행이 불가능한 다른 그래프다.) 두 노드를 같은 그래프에 속하도록 연결시키는 (사이클을 형성하지 않도록 서로소인 두 노드를 연결 합병)알고리즘이다. 집합을 구성하는 비트 벡터, 배열, 연결리스트,...","categories": ["Algorithm"],
        "tags": ["Algorithm","Coding Test","Cpp","Graph"],
        "url": "http://localhost:4000/algorithm/unionfind/",
        "teaser": null
      },{
        "title": "[고득점Kit][그리디] 단속 카메라 ⭐⭐⭐",
        "excerpt":"[그리디] 단속 카메라 난이도 ⭐⭐⭐ 문제 [-13, -14] 지점에 카메라를 설치하면 첫 번째, 두 번째, 세 번째 차량이 카메라를 만난다. [-5, -3] 지점에 카메라를 설치하면 네 번째 차량이 카메라를 만난다. -5 지점이라면 세 번째 카메라도 같이 만남 풀이 풀이는 SoftVanilla 님 블로그를 참고하였다. 이 문제의 내 풀이는 통과하지 못했다. 자꾸...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Greedy"],
        "url": "http://localhost:4000/programmers/kit26/",
        "teaser": null
      },{
        "title": "[고득점Kit][DFS] 타겟 넘버 ⭐⭐",
        "excerpt":"[DFS] 타겟 넘버 난이도 ⭐⭐ 문제 풀이 이 문제는 풀지 못 했다. 더군다나 문제도 잘 못 이해했다. 순열처럼 numbers 원소들의 자리들도 바꿔야 하는건 줄 알았는데 생각해보니 그렇게는 안해도 됐었다.. 그냥 -, + 부호를 어디에 붙일지만 고려하면 될 뿐이었다. 아무튼간에.. 풀이를 구글링해보니 내가 백준에서 풀었던 문제들과 유형이 똑같다는걸 깨달았다. 이런게 DFS구나...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","DFS"],
        "url": "http://localhost:4000/programmers/kit27/",
        "teaser": null
      },{
        "title": "[고득점Kit][DFS] 네트워크 ⭐⭐⭐",
        "excerpt":"[DFS] 네트워크 난이도 ⭐⭐⭐ 문제 각 원소는 아래와 같은 의미를 가진다. 첫 번째 원소인 [1, 1, 0]는 첫 번째 원소의 연결 상태를 나타낸다. 자기 자신인 첫 번째 원소와 연결 두 번째 원소와 연결 세 번째 원소와는 연결 X 내 풀이 ⭕ DFS 초보라 어려웠지만 풀었다. 👏👏 #include &lt;string&gt; #include &lt;vector&gt;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","DFS"],
        "url": "http://localhost:4000/programmers/kit28/",
        "teaser": null
      },{
        "title": "[고득점Kit][DFS][BFS] 단어 변환 ⭐⭐⭐",
        "excerpt":"[DFS][BFS] 단어 변환 난이도 ⭐⭐⭐ 문제 BFS, DFS 두 풀이로 풀어본 문제다. 맞아서 기분 좋다. 🥰 BFS 로 푼 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; int differentCount(string str, string target) { int differentCount = 0; for (int i = 0; i &lt; str.length(); i++) {...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","DFS","BFS"],
        "url": "http://localhost:4000/programmers/kit29/",
        "teaser": null
      },{
        "title": "[고득점Kit][DFS] 여행 경로 ⭐⭐⭐",
        "excerpt":"[DFS] 여행 경로 난이도 ⭐⭐⭐ 문제 내 풀이 ⭕ DFS에 관해 배운게 많았던 문제라고 생각함! 프로그래머스의 질문하기에 올려주신 다른 분들의 테스트 케이스가 도움 많이 되었다. #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; bool compare(vector&lt;string&gt; a, vector&lt;string&gt; b) { if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0]...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","DFS","BFS"],
        "url": "http://localhost:4000/programmers/kit30/",
        "teaser": null
      },{
        "title": "[고득점Kit][DFS][DP] N 으로 표현 ⭐⭐⭐",
        "excerpt":"[DFS][DP] N 으로 표현 난이도 ⭐⭐⭐ 문제 👩🏽 DFS 풀이 #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; void DFS(int&amp; answer, int N, int target, int calc, int depth) { if (calc == target) { answer = min(answer, depth); return; } int operand = 0; for(int i = 1;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","DFS","DP"],
        "url": "http://localhost:4000/programmers/kit31/",
        "teaser": null
      },{
        "title": "(C++) 동적 계획법 Dynamic Programming",
        "excerpt":"나동빈님 블로그 참고함 weeklyps 참고함 👩🏼 동적 계획법이란? (Vs. 분할 정복) 상당수의 분할 정복 기법(큰 문제를 작은 여러개의 문제로 나누어 푸는 기법으로 재귀적 성격을 띔)은 동일한 문제를 추후 다시 푼다는 단점을 가지고 있다. 병합정렬이나 퀵정렬 같은 분할 방식은 [1, 4] [2, 3] 이런식으로 교집합이 없는 두 집합으로서 쪼개서 따로 따로...","categories": ["Algorithm"],
        "tags": ["Algorithm","Coding Test","Cpp","Graph"],
        "url": "http://localhost:4000/algorithm/dp/",
        "teaser": null
      },{
        "title": "[고득점Kit][DP] 정수 삼각형 ⭐⭐⭐",
        "excerpt":"[DP] 정수 삼각형 난이도 ⭐⭐⭐ 문제 꼭대기 꼭짓점부터 트리 타고 내려오듯이 한 줄씩 내려온다. 자신을 기준으로 왼쪽 혹은 오른쪽 대각선을 타고 내려온다. 내 풀이 ⭕ 동적계획법 알고리즘을 공부하고난 후, 이를 사용하여 내 힘으로 풀어낸 첫 DP 문제였다. 정답 받아서 기분이 좋았다. #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","DP"],
        "url": "http://localhost:4000/programmers/kit32/",
        "teaser": null
      },{
        "title": "[고득점Kit][DP] 등굣길 ⭐⭐⭐",
        "excerpt":"[DP] 등굣길 난이도 ⭐⭐⭐ 문제 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int solution(int m, int n, vector&lt;vector&lt;int&gt;&gt; puddles) { int answer = 0; // [n + 1][m + 1] 크기로 선언 vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0)); sort(puddles.begin(), puddles.end()); // 갈 수...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","DP"],
        "url": "http://localhost:4000/programmers/kit33/",
        "teaser": null
      },{
        "title": "[고득점Kit][DP] 도둑질 ⭐⭐⭐⭐",
        "excerpt":"[DP] 도둑질 난이도 ⭐⭐⭐⭐ 문제 이 문제를 DP 적으로 생각하는게 어려웠다. 배울게 많았던 문제이니 반복해서 보자!! 풀이 #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int solution(vector&lt;int&gt; money) { int answer = 0; int tempMax = 0; vector&lt;int&gt; dp(money.size()); // 0 부터 차례대로 해당 원소까지 털었을 때의 돈의 최댓값...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","DP"],
        "url": "http://localhost:4000/programmers/kit34/",
        "teaser": null
      },{
        "title": "[고득점Kit][이분탐색] 입국심사 ⭐⭐⭐",
        "excerpt":"[이분탐색] 입국심사 난이도 ⭐⭐⭐ 💛 문제 🎀 ‘이분 탐색’ 문제 풀이시 생각해봐야할 것 이분 탐색을 사용하면 모든 경우의 수를 일일이 전부 다 탐색할 필요 없이, 스무고개, 업 다운 게임과 같은 방식으로 답을 찾을 수 있다. 1~100의 범위 中 64를 찾으려 한다면 처음부터 차례 차례 하나씩 검사해가며 찾아야 했을 것이다. 그러나...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Binary Search"],
        "url": "http://localhost:4000/programmers/kit35/",
        "teaser": null
      },{
        "title": "[고득점Kit][이분탐색] 징검다리 ⭐⭐⭐⭐",
        "excerpt":"[이분탐색] 징검다리 난이도 ⭐⭐⭐⭐ 💛 문제 💛 풀이 #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int solution(int distance, vector&lt;int&gt; rocks, int n) { int answer = 1; int start = 1; int end = distance; sort(rocks.begin(), rocks.end()); while(start &lt;= end) { int mid = (start + end) /...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Binary Search"],
        "url": "http://localhost:4000/programmers/kit36/",
        "teaser": null
      },{
        "title": "[고득점Kit][그래프][DFS][BFS] 가장 먼 노드 ⭐⭐⭐",
        "excerpt":"[그래프] 가장 먼 노드 난이도 ⭐⭐⭐ 💛 문제 💛 DFS 풀이 출발지는 정점 1로 고정되어 있다. 그래프 순회는 DFS, BFS !! 각 정점마다 출발 정점 (1)로부터의 거리들을 구하고 이 중 가장 큰 거리들을 가진 정점들의 갯수를 세면 된다. BFS가 풀이하기 편하지만 DFS로도 풀이 해보았다. #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Graph","DFS","BFS"],
        "url": "http://localhost:4000/programmers/kit37/",
        "teaser": null
      },{
        "title": "[고득점Kit][그래프][DFS] 순위 ⭐⭐⭐",
        "excerpt":"[그래프] 순위 난이도 ⭐⭐⭐ 문제 풀이 1️⃣ (DFS) (승리 횟수 + 패배 횟수)가 n - 1이면 그 선수는 정확하게 순위를 매길 수 있는 선수다. 자기 자신을 제외한 n - 1명과의 확실한 순위 비교가 가능한 선수라는 뜻이기 때문에 ! A 가 B 를 이겼고, B 가 C 를 이겼다면 A 는...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Graph","DFS"],
        "url": "http://localhost:4000/programmers/kit38/",
        "teaser": null
      },{
        "title": "[고득점Kit][그래프] 방의 개수 ⭐⭐⭐⭐⭐",
        "excerpt":"[그래프] 방의 개수 난이도 ⭐⭐⭐⭐⭐ 문제 풀이 코드, 풀이 참고 : 얍문님 블로그 https://yabmoons.tistory.com/606 Lv.5 난이도에 지레 겁먹고 구글링부터 했었던 문제였다. 나름 생각보다 복잡한 답은 아니길래 좀 더 깊게 고민 해 볼걸 그랬나 싶다. 이 분이 너무 설명을 잘 해주셔서 그렇게 느낀걸까..😂 이 분의 포스트를 통해 명쾌하게 이해가 되었다. #include...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test","Graph"],
        "url": "http://localhost:4000/programmers/kit39/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 두 개 뽑아서 더하기 ⭐",
        "excerpt":"두 개 뽑아서 더하기 난이도 ⭐ 문제 풀이 #include &lt;string&gt; #include &lt;vector&gt; #include &lt;set&gt; using namespace std; vector&lt;int&gt; solution(vector&lt;int&gt; numbers) { vector&lt;int&gt; answer; set&lt;int&gt; temp; for(int i = 0; i &lt; numbers.size(); i++) for(int j = i + 1; j &lt; numbers.size(); j++) temp.insert(numbers[i] + numbers[j]); for(auto sum : temp)...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/40/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 크레인 인형뽑기 게임 ⭐",
        "excerpt":"크레인 인형뽑기 게임 난이도 ⭐ 문제 풀이 #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; int solution(vector&lt;vector&lt;int&gt;&gt; board, vector&lt;int&gt; moves) { int answer = 0; // 계속 업데이트 할 인형들 배치 상태 // 원소들은 Queue : 가장 위에 있는 것이 먼저 빠져나오기 위해 (가장 위에 있는 것이 가장 먼저...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/41/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 2016년 ⭐",
        "excerpt":"2016년 난이도 ⭐ 문제 풀이 #include &lt;string&gt; #include &lt;vector&gt; using namespace std; string solution(int a, int b) { string answer = \"\"; int sum = 0; int month [] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; string day [] = { \"FRI\", \"SAT\",...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/42/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 가운데 글자 가져오기 ⭐",
        "excerpt":"가운데 글자 가져오기 난이도 ⭐ 문제 풀이 #include &lt;string&gt; #include &lt;vector&gt; using namespace std; string solution(string s) { string answer = \"\"; if (s.length() % 2) answer = s.substr(s.length() / 2, 1); else answer = s.substr(s.length() / 2 - 1, 2); return answer; } substr 첫 번째 인수 👉 부분...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/43/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 3진법 뒤집기 ⭐",
        "excerpt":"3진법 뒤집기 난이도 ⭐ 문제 풀이 #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int pow(int n) // 재귀 호출로 3의 n승을 구한다. { if (n == 0) return 1; return 3 * pow(n - 1); } int solution(int n) { int answer = 0; int q = n; vector&lt;int&gt; temp;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/44/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 같은 숫자는 싫어 ⭐",
        "excerpt":"같은 숫자는 싫어 난이도 ⭐ 문제 풀이 #include &lt;vector&gt; #include &lt;iostream&gt; using namespace std; vector&lt;int&gt; solution(vector&lt;int&gt; arr) { vector&lt;int&gt; answer; for(int i = 0; i &lt; arr.size(); i++) { // 중복 방지 // answer에 추가하려는 arr[i]가 answer의 마지막 원소와 같다면 추가하지 않는다. (단 answer가 빈 벡터가 아닐 때만) if(!answer.empty() &amp;&amp;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/45/",
        "teaser": null
      },{
        "title": "(C++) 플로이드 와샬 Floyd Warshall (+ 최단 경로 알고리즘 비교)",
        "excerpt":"👩🏼 플로이드 와샬 알고리즘 다익스트라 알고리즘과 같이 최단 거리를 구할 수 있는 알고리즘이다. 원리 다익스트라 알고리즘 출발지 정점을 하나 정해놓고 그곳에서부터 다른 모든 정점으로의 최단 경로를 구한다. 가장 적은 비용을 하나씩 선택해나간다. (우선순위 큐 사용) 플로이드 와샬 알고리즘 모든 정점에서 모든 정점으로의 최단 경로를 한번에 구한다. 즉 정점과 정점, 모든...","categories": ["Algorithm"],
        "tags": ["Algorithm","Coding Test","Cpp","Graph"],
        "url": "http://localhost:4000/algorithm/floyd/",
        "teaser": null
      },{
        "title": "[Code Up] (1006) '%' 출력하기",
        "excerpt":"C/C++로 풀이했습니다. 출처 : Code Up 문제 풀이. https://codeup.kr/ 문제 출처 https://codeup.kr/problem.php?id=1006 다음 문장을 출력하시오. \"!@#$%^&amp;*()\" #include &lt;stdio.h&gt; int main() { printf(\"\\\"!@#$%%^&amp;*()\\\"\"); } %은 출력 형식 지정자로 사용되므로 %를 그대로 출력하기 위해선 %%로 2 개를 붙여 출력해주어야 한다. 🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 언제든지 댓글...","categories": ["CodeUp"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/codeup/1/",
        "teaser": null
      },{
        "title": "[Code Up] (1008) 특수 문자 출력하기",
        "excerpt":"C/C++로 풀이했습니다. 출처 : Code Up 문제 풀이. https://codeup.kr/ 문제 출처 https://codeup.kr/problem.php?id=1008 ┌┬┐ ├┼┤ └┴┘ 를 출력하시오 이런 유니코드 표를 사용해야 한다. ┌ ┬ ┐ 250C 252C 2510 ├ ┼ ┤ 251C 253C 2524 └ ┴ ┘ 2514 2534 2518 #include &lt;stdio.h&gt; int main() { printf(\"\\u250C\\u252C\\u2510\\n\"); printf(\"\\u251C\\u253C\\u2524\\n\"); printf(\"\\u2514\\u2534\\u2518\\n\"); } 🌜...","categories": ["CodeUp"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/codeup/2/",
        "teaser": null
      },{
        "title": "[Code Up] (1020) 주민 등록 번호 입력받고 '-' 빼고 출력하기",
        "excerpt":"C/C++로 풀이했습니다. 출처 : Code Up 문제 풀이. https://codeup.kr/ 문제 출처 https://codeup.kr/problem.php?id=1020 첫 번째 풀이 #include &lt;stdio.h&gt; int main() { char str[14]; scanf(\"%s\", str); for (int i = 0; i &lt; 14; i++) { if (str[i] == '-') continue; printf(\"%c\", str[i]); } } scanf(\"%s\", ...); 로 입력받게 되면, 마지막에 '\\0'...","categories": ["CodeUp"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/codeup/3/",
        "teaser": null
      },{
        "title": "[Code Up] (1028, 1029, 1030) 자료형 범위",
        "excerpt":"C/C++로 풀이했습니다. 출처 : Code Up 문제 풀이. https://codeup.kr/ 1028 입력되는 정수의 범위는 0 ~ 4294967295 #include &lt;stdio.h&gt; int main() { unsigned int n; scanf(\"%u\", &amp;n); printf(\"%u\", n); } int의 최대값인 약 21억(\\(2^{31} - 1\\))을 넘고 있다. 그래서 바로 long을 생각했는데, 사실 long long까지 갈 필요도 없이 unsigned int를 생각하면...","categories": ["CodeUp"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/codeup/4/",
        "teaser": null
      },{
        "title": "[Code Up] (1064) 삼항 연산자만 사용하여 최소값, 최대값 출력",
        "excerpt":"C/C++로 풀이했습니다. 출처 : Code Up 문제 풀이. https://codeup.kr/ 문제 출처 https://codeup.kr/problem.php?id=1064 삼항 연산자만 사용하여 최대값 출력하기 #include &lt;stdio.h&gt; using namespace std; int main() { int a, b, c; scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); printf(\"%d\", (a &gt; b ? a : b) &gt; c ? (a &gt; b ?...","categories": ["CodeUp"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/codeup/5/",
        "teaser": null
      },{
        "title": "[Code Up] (1079) scanf의 '%c'로 char문자를 받을 때 주의할 사항",
        "excerpt":"C/C++로 풀이했습니다. 출처 : Code Up 문제 풀이. https://codeup.kr/ 문제 출처 https://codeup.kr/problem.php?id=1079 #include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { char c; while(1) { scanf(\" %c\", &amp;c); printf(\"%c\\n\", c); if (c == 'q') break; } } scanf(\"%c\") char 문자 1 개를 받을 경우, 이 %c는 특별하게...","categories": ["CodeUp"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/codeup/6/",
        "teaser": null
      },{
        "title": "[Code Up] (1099) 성실한 개미",
        "excerpt":"C/C++로 풀이했습니다. 출처 : Code Up 문제 풀이. https://codeup.kr/ 문제 출처 https://codeup.kr/problem.php?id=1099 *** #include &lt;stdio.h&gt; using namespace std; int main() { int arr[11][11] = { 0 }; for(int i = 1; i &lt;= 10; i++) for(int j = 1; j &lt;= 10; j++) scanf(\"%d\", &amp;arr[i][j]); int x = 2, y...","categories": ["CodeUp"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/codeup/10/",
        "teaser": null
      },{
        "title": "[Code Up] (1082) 16진수 구구단",
        "excerpt":"C/C++로 풀이했습니다. 출처 : Code Up 문제 풀이. https://codeup.kr/ 문제 출처 https://codeup.kr/problem.php?id=1082 *** #include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { char n; scanf(\"%c\", &amp;n); for(int i = 1; i &lt; 16; i++) printf(\"%X*%X=%X\\n\", n - 55, i, (n - 55) * i); } 입력은 A...","categories": ["CodeUp"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/codeup/7/",
        "teaser": null
      },{
        "title": "[Code Up] (1092) 최소공배수",
        "excerpt":"C/C++로 풀이했습니다. 출처 : Code Up 문제 풀이. https://codeup.kr/ 문제 출처 https://codeup.kr/problem.php?id=1092 *** #include &lt;stdio.h&gt; using namespace std; int main() { int a, b, c; scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); int day = 1; while(day % a != 0 || day % b != 0 || day % c...","categories": ["CodeUp"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/codeup/8/",
        "teaser": null
      },{
        "title": "[Code Up] (1098) 설탕과자 뽑기",
        "excerpt":"C/C++로 풀이했습니다. 출처 : Code Up 문제 풀이. https://codeup.kr/ 문제 출처 https://codeup.kr/problem.php?id=1098 *** #include &lt;stdio.h&gt; using namespace std; int main() { int arr[101][101] = { 0 }; int row, col; scanf(\"%d %d\", &amp;row, &amp;col); int n; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) { int len, dir,...","categories": ["CodeUp"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/codeup/9/",
        "teaser": null
      },{
        "title": "Chater 1. 배열을 사용해 영화 평점 관리 프로그램 만들기",
        "excerpt":"홍정모 교수님의 강의 홍정모의 따라하며 배우는 C언어(부록) 를 듣고 정리한 필기입니다. 😀 Chapter 1. 배열(+동적 할당 배열) 🚀 영화 평점 관리 텍스트 파일 6 Rear Window 4.0 Mank 4.5 Tenet 4.0 Manchester by the Sea 4.0 Only Lovers Left Alive 3.5 Vice 4.5 영화 평점 파일은 이런 포맷으로 저장된다. 맨...","categories": ["DataStructure2"],
        "tags": ["Algorithm","Data Structure","C"],
        "url": "http://localhost:4000/datastructure2/ch1/",
        "teaser": null
      },{
        "title": "Chater 2. 연결리스트를 사용해 영화 평점 관리 프로그램 만들기",
        "excerpt":"홍정모 교수님의 강의 홍정모의 따라하며 배우는 C언어(부록) 를 듣고 정리한 필기입니다. 😀 Chapter 2. 연결리스트 🚀 배열과의 차이 ✈ 배열 장점 👉 원소들이 연속적으로 저장되어 있기 때문에 [] 인덱스로 임의 접근이 가능함. O(1) 단점 👉 추가, 삭제시 효율이 낮다. 추가할 때 추가할 자리 뒤에 있는 원소들은 전부 뒤로 한 칸씩...","categories": ["DataStructure2"],
        "tags": ["Algorithm","Data Structure","C"],
        "url": "http://localhost:4000/datastructure2/ch2/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 문자열 내 마음대로 정렬하기⭐",
        "excerpt":"📌 문자열 내 마음대로 정렬하기 난이도 ⭐ 🚀 문제 🚀 내 풀이 ⭕ 난이도 ⭐ 라서 가볍게 몇 개만 풀자! 하는 마음으로 풀었다가 조금 까다로워서 당황.. #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int global; bool compare(const string&amp; a, const string&amp; b) { if (a[global] == b[global]) return...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/46/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 문자열 내림 차순으로 배치하기⭐",
        "excerpt":"📌 문자열 내림 차순으로 배치하기 난이도 ⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; bool cmp(const char&amp; a, const char&amp; b) { if (a &gt;= 'A' &amp;&amp; b &lt;= 'z') // a는 대문자, b는 소문자 return a &gt; b; return a &lt;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/47/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 소수 찾기 (시간 초과 주의)⭐",
        "excerpt":"📌 소수 찾기 난이도 ⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int solution(int n) { int answer = 0; vector&lt;int&gt; vec(n + 1); for(int i = 2; i &lt;= n; i++) for(int j = i; j &lt;= n; j += i) vec[j]++; for(int...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/48/",
        "teaser": null
      },{
        "title": "[C++로 풀이] (비트 연산) 비밀 지도⭐",
        "excerpt":"📌 비밀 지도 난이도 ⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; vector&lt;string&gt; solution(int n, vector&lt;int&gt; arr1, vector&lt;int&gt; arr2) { vector&lt;string&gt; answer(n, \"\"); for(int i = 0; i &lt; n; i++) { int temp = arr1[i] | arr2[i]; for (int j = n -...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/49/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 실패율⭐",
        "excerpt":"📌 실패율 난이도 ⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; bool compare(pair&lt;int, float&gt; a, pair&lt;int, float&gt; b) { if (a.second == b.second) // 실패율이 같다면 return a.first &lt; b.first; // 이름(int) 기준 오름차순 else return a.second &gt; b.second; // 실패율(float) 기준...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/50/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 다트 게임⭐",
        "excerpt":"📌 다트 게임 난이도 ⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int pow(int base, int n) { if (n == 0) return 1; return base * pow(base, n - 1); } int solution(string dartResult) { int answer = 0; vector&lt;int&gt; vec; int i...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/51/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 키패드 누르기⭐",
        "excerpt":"📌 키패드 누르기 난이도 ⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int abs(int n) { if (n &lt; 0) return -n; else return n; } int distance(int pos, int dest) { int dist = 0; dist += abs((pos - 1) / 3 -...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/52/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 이상한 문자 만들기⭐",
        "excerpt":"📌 이상한 문자 만들기 난이도 ⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; string solution(string s) { string answer = \"\"; answer = s; const int gap = 'a' - 'A'; // 대문자와 소문자의 아스키코드 차이 int count = 1; // 단어 내에서 1부터...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/53/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 정수 내림차순으로 배치하기⭐",
        "excerpt":"📌 정수 내림차순으로 배치하기 난이도 ⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; long long solution(long long n) { long long answer = 0; string number = to_string(n); sort(number.rbegin(), number.rend()); // 내림 차순 정렬 for(int i = 0; i &lt; number.length(); i++)...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/54/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 124 나라의 숫자⭐⭐",
        "excerpt":"📌 124 나라의 숫자 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int pow(int base, int n) { if (n == 0) return 1; return base * pow(base, n - 1); } string solution(int n) { string answer = \"\"; vector&lt;string&gt;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/55/",
        "teaser": null
      },{
        "title": "[C++로 풀이] (자료형의 중요성) 멀쩡한 사각형⭐⭐",
        "excerpt":"📌 멀쩡한 사각형 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;cmath&gt; using namespace std; long long solution(int w, int h) { long long answer = 1; long long cantuse = 0; for (long long i = 1; i &lt;= w; i++) cantuse += (long long)ceil((long double)h * i...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/56/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 스킬트리⭐⭐",
        "excerpt":"📌 스킬트리 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int solution(string skill, vector&lt;string&gt; skill_trees) { int answer = 0; for (int i = 0; i &lt; skill_trees.size(); i++) { int pos = -1; bool impossible = false; char impossibleChar = skill[0]; for...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/57/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 문자열 압축⭐⭐",
        "excerpt":"📌 문자열 압축 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int solution(string s) { vector&lt;int&gt; length(s.length() + 1); for (int i = 1; i &lt;= s.length(); i++) { int next = 0; while (next &lt; s.length()) { string sub =...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/58/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 최솟값 만들기⭐⭐",
        "excerpt":"📌 최솟값 만들기 난이도 ⭐⭐ 🚀 문제 최소값이 되려면 A에서의 최소값과 B에서의 최대값을 곱해야 최소값이 된다. 큰 것과 큰 것을 곱하면 값이 작아질리가 없기에 최대한 작은 것은 큰 것과 곱하도록 하는게 좋다. [1, 2, 3, 4, 5] 와 [10, 9, 8, 7, 6] 을 위 문제식으로 곱하고 누적합한 것의 최소값은...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/59/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 피보나치 수⭐⭐",
        "excerpt":"📌 피보나치 수 난이도 ⭐⭐ 🚀 문제 동적 계획법으로 풀어야 시간 초과 안난다.. ^ _ㅠ⭐ 🚀 내 풀이 ✈ 1차 풀이 ❌ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int solution(int n) { vector&lt;int&gt; fibonacci(n + 1); fibonacci[0] = 0; fibonacci[1] = 1; for(int i = 2; i &lt;= n;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/60/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 최댓값과 최솟값⭐⭐",
        "excerpt":"📌 최댓값과 최솟값 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; string solution(string s) { string answer = \"\"; vector&lt;int&gt; vec; int lastSpaceIndex = -1; for(int i = 0; i &lt; s.length(); i++) { if (s[i] == ' ') { vec.push_back(stoi(s.substr(lastSpaceIndex...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/61/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 숫자의 표현⭐⭐",
        "excerpt":"📌 숫자의 표현 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int solution(int n) { int answer = 0; for(int i = 1; i &lt;= n / 2; i++) { int sum = 0; for(int j = i; j &lt;= n; j++) {...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/62/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 다음 큰 숫자⭐⭐",
        "excerpt":"📌 다음 큰 숫자 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int solution(int n) { int answer = 0; int countOfN = 0; int temp = n; // countOfN -&gt; n의 1의 개수 구하기 while(temp &gt; 0) { if (temp % 2...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/63/",
        "teaser": null
      },{
        "title": "[C++로 풀이] N개의 최소공배수 ⭐⭐",
        "excerpt":"📌 N개의 최소공배수 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ 3개 이상의 수에서 최소공배수를 구할 때, 공약수가 없다면 모든 수에서 서로소가 나올 때까지 일부의 공약수만으로 계속 나눈다! 처음엔 두 수의 최소 공배수를 구하는 것처럼 최대공약수 * 두 수의 서로소 이렇게 구하려고 했었는데 그렇게 하니 오답이 났었다. 3개 이상의 수에선...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/64/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 행렬의 곱셈 ⭐⭐",
        "excerpt":"📌 행렬의 곱셈 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; vector&lt;vector&lt;int&gt;&gt; solution(vector&lt;vector&lt;int&gt;&gt; arr1, vector&lt;vector&lt;int&gt;&gt; arr2) { // arr1은 m*l 크기, arr2은 l*n 크기 int m = arr1.size(); int l = arr2.size(); int n = arr2[0].size(); vector&lt;vector&lt;int&gt;&gt; answer(m, vector&lt;int&gt;(n, 0)); for(int i =...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/65/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 튜플 ⭐⭐",
        "excerpt":"📌 튜플 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;map&gt; using namespace std; bool compare(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) { return a.second &gt; b.second; } vector&lt;int&gt; solution(string s) { vector&lt;int&gt; answer; map&lt;int, int&gt; count; string oneNumStr = \"\"; for(int i =...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/66/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 올바른 괄호 ⭐⭐",
        "excerpt":"📌 올바른 괄호 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; bool solution(string s) { stack&lt;int&gt; st; int openCount = 0; // '('의 개수 int closeCount = 0; // ')'의 개수 // s 문자열 순회 for(int i = 0; i &lt;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/67/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 괄호 변환 ⭐⭐",
        "excerpt":"📌 괄호 변환 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;stack&gt; using namespace std; bool isProper(string s) // \"올바른 괄호 문자열\"인지 판별 { stack&lt;int&gt; st; for(int i = 0; i &lt; s.length(); i++) { if (s[i] == '(') st.push(s[i]); if (s[i] == ')') if...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/68/",
        "teaser": null
      },{
        "title": "[C++로 풀이] JadenCase 문자열 만들기 ⭐⭐",
        "excerpt":"📌 JadenCase 문자열 만들기 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; string solution(string s) { string answer = s; bool newWord = true; for(int i = 0; i &lt; answer.length(); i++) { if (answer[i] == ' ') newWord = true; else if...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/69/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 영어 끝말잇기 ⭐⭐",
        "excerpt":"📌 영어 끝말잇기 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;unordered_set&gt; using namespace std; vector&lt;int&gt; solution(int n, vector&lt;string&gt; words) { vector&lt;int&gt; answer (2, 0); unordered_set&lt;string&gt; record; // 이전 단어들 저장해둘 set. (나중에 중복 단어 있는지 검사해야하니까) for(int i = 0; i &lt; words.size(); i++)...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/70/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 캐시 (std::list, 연결리스트, LRU 알고리즘)⭐⭐",
        "excerpt":"📌 캐시 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ ✈ LRU 캐싱 알고리즘 가장 오랫동안 사용 안한 것이 캐싱 큐의 가장 앞에 있어야 한다. 가장 최근에 사용한 것이 캐싱 큐의 가장 뒤에 있어야 한다. 사용하려는 대상이 💜캐싱 큐에 존재한다면 (즉, 캐시가 있다면) 새롭게 로드할 필요 없이 이 캐싱 큐에...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/71/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 오픈채팅방 ⭐⭐",
        "excerpt":"📌 오픈채팅방 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;unordered_map&gt; using namespace std; string splitStr(string str, int number){ string word = \"\"; for(int i = 0; i &lt; str.length(); i++){ if (str[i] == ' '){ number--; if (number == 0) break; else word =...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/72/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 신규 아이디 추천⭐",
        "excerpt":"📌 신규 아이디 추천 난이도 ⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; string solution(string new_id) { // 1 단계 for(int i = 0; i &lt; new_id.length(); i++) if (new_id[i] &gt;= 'A' &amp;&amp; new_id[i] &lt;= 'Z') new_id[i] = tolower(new_id[i]); // 2 단계 for(int i...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/73/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 짝지어 제거하기⭐⭐",
        "excerpt":"📌 짝지어 제거하기 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;stack&gt; using namespace std; int solution(string s) { stack&lt;char&gt; check; check.push(s[0]); for(int i = 1; i &lt; s.length(); i++){ if (!check.empty() &amp;&amp; s[i] == check.top()) check.pop(); else check.push(s[i]); } if (check.empty()) return 1; else...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/74/",
        "teaser": null
      },{
        "title": "[C++로 풀이] n진수 게임⭐⭐",
        "excerpt":"📌 n진수 게임 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; char IntToChar(int num) { switch (num) { case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: return '0' + num; case...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/75/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 카카오 프렌즈 컬러링북 (BFS/DFS)⭐⭐",
        "excerpt":"📌 카카오 프렌즈 컬러링북 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ✈ 1 차 풀이 ❌ 이 풀이는 틀린 풀이입니다. #include &lt;vector&gt; #include &lt;algorithm&gt; vector&lt;int&gt; solution(int m, int n, vector&lt;vector&lt;int&gt;&gt; picture) { vector&lt;int&gt; answer(2); vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; record(picture.size()); // 모든 칸 마다 (칸, 속한 영역) vector&lt;int&gt; group; // 영역마다 몇 칸...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/76/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 삼각 달팽이 (DFS)⭐⭐",
        "excerpt":"📌 삼각 달팽이 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; void DFS(vector&lt;int&gt;&amp; answer, int&amp; n, int elem, int startIndex, int depth) { int arrSize = n * (n + 1) / 2; // 1. 꼭짓점 answer[startIndex] = elem++; if (elem &gt; arrSize)...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/77/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 이진 변환 반복하기⭐⭐",
        "excerpt":"📌 이진 변환 반복하기 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; solution(string s) { vector&lt;int&gt; answer(2); int count = 0; // 이진 변환의 횟수 int sum = 0; // 제거된 모든 0의 개수 while(s != \"1\"){ int tempCount = 0; //...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/78/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 폰켓몬⭐⭐",
        "excerpt":"📌 폰켓몬 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;vector&gt; #include &lt;unordered_map&gt; using namespace std; int solution(vector&lt;int&gt; nums){ int answer = 0; unordered_map&lt;int, int&gt; m; for(int i = 0; i &lt; nums.size(); i++) m[nums[i]]++; if (nums.size() / 2 &gt;= m.size()) answer = m.size(); else answer = nums.size() /...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/79/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 점프와 순간 이동⭐⭐",
        "excerpt":"📌 점프와 순간 이동 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ using namespace std; int solution(int n) { int ans = 0; while(n &gt; 0){ if (n % 2 == 1) ans++; n /= 2; } return ans; } 2로 계속 나눴을 때 나머지가 1 이 되는 것이 몇...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/80/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 압축⭐⭐",
        "excerpt":"📌 압축 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;unordered_map&gt; using namespace std; vector&lt;int&gt; solution(string msg) { vector&lt;int&gt; answer; // Key를 A~Z, 이에 대한 Value를 각각 1~26으로. unordered_map&lt;string, int&gt; dic; for(int i = 0; i &lt; 26; i++){ char c = 'A' + i;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/81/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 메뉴 리뉴얼 (DFS, 조합)⭐⭐",
        "excerpt":"📌 메뉴 리뉴얼 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ (DFS로 조합 구하기) #include &lt;string&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;algorithm&gt; using namespace std; bool cmp(pair&lt;string, int&gt; a, pair&lt;string, int&gt; b){ return a.second &gt; b.second; } void DFS(map&lt;string, int&gt;&amp; dic, string&amp; order, string comb, int index, int depth) {...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/82/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 소수 만들기(DFS, 조합, next_permutation)⭐⭐",
        "excerpt":"📌 소수 만들기 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ ✈ DFS (nC3 조합) #include &lt;vector&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; bool Prime[3001]; bool isPrime(vector&lt;int&gt; three){ int sum = three[0] + three[1] + three[2]; if (Prime[sum]) return true; else return false; } void DFS(vector&lt;int&gt;&amp; nums, vector&lt;int&gt; three,...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/83/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 땅따먹기 (DP)⭐⭐",
        "excerpt":"📌 땅따먹기 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ✈ 1차 풀이 ❌ #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int solution(vector&lt;vector&lt;int&gt;&gt; land) { int answer = 0; vector&lt;int&gt; fourColRecord(4); int selectedIndex = 0; for (int i = 0; i &lt; fourColRecord.size(); i++) { for (int j =...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/84/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 가장 큰 정사각형 찾기 (DP)⭐⭐",
        "excerpt":"📌 가장 큰 정사각형 찾기 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int solution(vector&lt;vector&lt;int&gt;&gt; board) { int answer = 1; int max = 0; vector&lt;vector&lt;int&gt;&gt; dp(board.size(), vector&lt;int&gt;(board[0].size())); for(int i = 0; i &lt; board.size(); i++){ for(int j = 0; j &lt; board[i].size(); j++){ if...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/85/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 프렌즈 4블록 ⭐⭐",
        "excerpt":"📌 프렌즈 4블록 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ int solution(int m, int n, vector&lt;string&gt; board) { int answer = 0; vector&lt;vector&lt;bool&gt;&gt; isSqaure(m, vector&lt;bool&gt;(n, false)); bool canRemove = false; do { // 초기화 for (int i = 0; i &lt; isSqaure.size(); i++) fill(isSqaure[i].begin(), isSqaure[i].end(), false); canRemove = false;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/86/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 방금그곡 ⭐⭐",
        "excerpt":"📌 방금그곡 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; bool cmp(pair&lt;string, int&gt; a, pair&lt;string, int&gt; b) { return a.second &gt; b.second; } string solution(string m, vector&lt;string&gt; musicinfos) { string answer = \"\"; vector&lt;vector&lt;string&gt;&gt; info(musicinfos.size()); vector&lt;pair&lt;string, int&gt;&gt; included; // tokenizing with...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/87/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 파일명 정렬 (정렬, stable sort) ⭐⭐",
        "excerpt":"📌 파일명 정렬 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; bool cmp(const string&amp; a, const string&amp; b) { /* HEAD */ string a_HEAD = \"\"; int a_index = 0; while (a_index &lt; a.length()) { if (a[a_index] &gt;= '0' &amp;&amp; a[a_index]...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/88/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 후보키 ⭐⭐",
        "excerpt":"📌 후보키 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; using namespace std; int solution(vector&lt;vector&lt;string&gt;&gt; relation) { int answer = 0; int numOfRow = relation.size(); int numOfCol = relation[0].size(); vector&lt;string&gt; candKey; // 후보키 모아 둠 vector&lt;bool&gt; comb(numOfCol); // 조합 구하는데 쓰일 bool...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/89/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 뉴스 클러스터링 ⭐⭐",
        "excerpt":"📌 뉴스 클러스터링 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;unordered_map&gt; using namespace std; string strLower(string str) { for (int i = 0; i &lt; str.length(); ++i) if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') str[i] = tolower(str[i]); return str; } vector&lt;string&gt; makeSet(string str)...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/90/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 단체사진 찍기 (경우의 수, 순열, DFS, next_permutation) ⭐⭐",
        "excerpt":"📌 단체사진 찍기 난이도 ⭐⭐ 🚀 문제 ✈ 예제 1 번의 답이 3648 인 이유 N과 F는 딱 붙어 있어야 하고 R과 T는 간격은 2 초과여야 한다.(간격은 3, 4, 5, 6 이 될 수 있음) 💙은 R과 T를 포함한 R과 T사이 구간 프렌즈들, 💛 은 N도 F도 아니고 R과 T...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/91/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 수식 최대화 ⭐⭐",
        "excerpt":"📌 수식 최대화 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; long long calculate(long long a, long long b, char op) { if (op == '+') return a + b; else if (op == '-') return a - b; else if...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/92/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 쿼드압축 후 개수 세기 (DFS) ⭐⭐",
        "excerpt":"📌 쿼드압축 후 개수 세기 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; arr, int&amp; zero, int&amp; one, int startRow, int startCol, int n){ if (n == 1){ if(arr[startRow][startCol] == 1) one++; else zero++; return; } int sum = 0; for(int...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/93/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 예상 대진표 (DFS) ⭐⭐",
        "excerpt":"📌 예상 대진표 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ using namespace std; void DFS(int&amp; a, int&amp; b, int&amp; count, int start, int end, int n) { if (n == 1){ count++; return; } int middle = (start + end) / 2; if (a &gt;= start &amp;&amp; a &lt;=...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/94/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 순위 검색 (lower_bound, stringstream, 순열, 반복자 종류) ⭐⭐",
        "excerpt":"📌 순위 검색 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;unordered_map&gt; using namespace std; vector&lt;int&gt; solution(vector&lt;string&gt; info, vector&lt;string&gt; query) { vector&lt;int&gt; answer; unordered_map&lt;string, vector&lt;int&gt;&gt; db; for (int i = 0; i &lt; info.size(); ++i) { vector&lt;string&gt; applicant; string temp = \"\"; for...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/95/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 2 X n 타일링 (dp)⭐⭐⭐",
        "excerpt":"📌 2 X n 타일링 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int solution(int n) { int answer = 0; vector&lt;int&gt; arr(2); arr[0] = 1; arr[1] = 1; for(int i = 2; i &lt;= n; ++i) arr.push_back((arr[i - 1] + arr[i -...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/96/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 멀리 뛰기 (dp)⭐⭐⭐",
        "excerpt":"📌 멀리 뛰기 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; long long solution(int n) { long long arr[2001]; arr[0] = 1; arr[1] = 1; for(int i = 2; i &lt;= n; i++) arr[i] = (arr[i - 1] + arr[i - 2]) %...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/97/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 야근 지수 ⭐⭐⭐",
        "excerpt":"📌 야근 지수 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; long long solution(int n, vector&lt;int&gt; works) { long long answer = 0; sort(works.begin(), works.end()); // 오름 차순 정렬 while (n &gt; 0 &amp;&amp; works[0] != 0) { // 최대값 범위...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/98/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 자물쇠와 열쇠 (완전 탐색)⭐⭐⭐",
        "excerpt":"📌 자물쇠와 열쇠 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ ✈ 1 차 풀이 ❌ (DFS) (작성하다 말았던 코드입니다.) // 💚현재 모습에서 시계방향 90도로 회전시키기 (pos에 1의 위치를 기록)💚 void rotate(int m, vector&lt;pair&lt;int, int&gt;&gt;&amp; pos) { for (int i = 0; i &lt; pos.size(); i++) { int temp_row =...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/99/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 가장 긴 팰린드롬⭐⭐⭐",
        "excerpt":"📌 가장 긴 팰린드롬 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ 팰린 드롬의 종류는 두 가지가 있다. 1️⃣ caabaac처럼 가운데 하나가 중심이 되어 이걸 기준으로 양 옆이 동일. 가운데 b를 중점으로 caabaac, caabaac, caabaac 이렇게 좌우가 같다. 2️⃣ baab처럼 가운데 하나가 중심이 되는 것은 아니고, 그냥 양 옆이 동일....","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/100/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 최고의 집합⭐⭐⭐",
        "excerpt":"📌 최고의 집합 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ✈ 1 차 풀이 : DFS로 중복 조합을 구하려 했던 시도 (⏰시간초과) vector&lt;int&gt; DFS(int&amp; n, int&amp; s, int&amp; max, long long mul, vector&lt;bool&gt;&amp; visited, vector&lt;int&gt;&amp; arr, vector&lt;int&gt; comb, int sum, int index, int depth) { vector&lt;int&gt; answer; if (depth ==...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/101/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 길 찾기 게임 (이진 탐색 트리)⭐⭐⭐",
        "excerpt":"📌 길 찾기 게임 난이도 ⭐⭐⭐ 🚀 문제 순서대로 [5, 3], [11, 5] 가 각각 1, 2번 노드가 된다. 이 문제의 경우 이진 탐색 트리의 크기 비교 기준은 x 좌표값이 된다. (data 인 몇 번 노드인지가 비교 기준이 아니다!) 🚀 내 풀이 ⭕ 같은 레벨에 있는 노드는 같은 y 좌표를...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/102/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 불량 사용자 (DFS)⭐⭐⭐",
        "excerpt":"📌 불량 사용자 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;map&gt; #include &lt;set&gt; using namespace std; void DFS(vector&lt;string&gt;&amp; user_id, vector&lt;string&gt;&amp; banned_id, set&lt;string&gt;&amp; selected_list, vector&lt;string&gt; temp, map&lt;string, bool&gt; visited, int index) { if (index == banned_id.size()) { string s = \"\"; sort(temp.begin(), temp.end());...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/103/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 방문 길이 (그래프 간선 방문 체크)⭐⭐⭐",
        "excerpt":"📌 방문 길이 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 방문 체크를 하여 방문했던 곳이면 answer를 증가시키지 않는다. 5 X 5 크기의 좌표를 넘어서는 공간은 무시한다. ✈ 1차 풀이 ❌ (“정점”으로 방문 체크) #include &lt;string&gt; using namespace std; int solution(string dirs) { int answer = 0; bool visited[11][11] = {...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/104/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 줄 서는 방법 (경우의 수 O(n!) 피하기)⭐⭐⭐",
        "excerpt":"📌 줄 서는 방법 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ✈ 1 차 풀이 ❌ (+시간초과⏰) #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; vector&lt;int&gt; solution(int n, long long k) { vector&lt;int&gt; answer(n); vector&lt;string&gt; q(n); for(int i = 0; i &lt; n; ++i) q[i] = to_string(i + 1);...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/105/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 거스름돈 (DP)⭐⭐⭐",
        "excerpt":"📌 거스름돈 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ✈ 1 차 풀이 (DFS) ⏰시간초과 #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; void DFS(vector&lt;int&gt;&amp; money, int&amp; answer, int n, int index) { if (index == money.size()) return; for (int i = index; i &lt; money.size(); ++i) { for...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/106/",
        "teaser": null
      },{
        "title": "[C++로 풀이] N-Queen (백트래킹)⭐⭐⭐",
        "excerpt":"📌 N-Queen 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; void DFS(vector&lt;vector&lt;bool&gt;&gt; queen, int&amp; answer, int row) { if (row == queen.size()) { answer++; return; } for (int col = 0; col &lt; queen[row].size(); ++col) { // 1️⃣ 첫번째 행당 하나만 들어갈 수...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/107/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 하노이의 탑 (재귀호출)⭐⭐⭐",
        "excerpt":"📌 하노이의 탑 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ 스스로 풀어낸 풀이가 아니다. 좀 고민해보다가 옛날에 자료구조 전공 수업에서 하노이 타워 코드를 다뤘던적이 있었던걸 기억하고 전공 책 꺼내 부랴부랴 이해해본 후 작성하는 풀이이다. 어려워!! ㅠㅠ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; void HanoiTower(vector&lt;vector&lt;int&gt;&gt;&amp; answer, int n, int...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/108/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 숫자 게임⭐⭐⭐",
        "excerpt":"📌 숫자 게임 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int solution(vector&lt;int&gt; A, vector&lt;int&gt; B) { int answer = 0; sort(A.begin(), A.end()); sort(B.begin(), B.end()); int index = 0; for(int i = 0; i &lt; B.size(); ++i){ if (B[i] &gt; A[index]){...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/109/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 풍선 터트리기⭐⭐⭐",
        "excerpt":"📌 풍선 터트리기 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 역시 시간 복잡도를 생각해야 한다. a의 길이가 무려 1,000,000 이기 때문이다! 임의의 인접한 두 풍선 중 더 큰 번호의 풍선을 터뜨리는 것은 제약이 없다. 최소값을 가진 풍선의 양옆 인접한 풍선들은 모두 제거될 수 있다. 임의의 인접한 두 풍선 중 더...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/110/",
        "teaser": null
      },{
        "title": "(C++) 이진 탐색 트리 (장단점, 삽입, 삭제, 탐색, 순회)",
        "excerpt":"&lt;뇌를 자극하는 알고리즘&gt; 책을 참고했습니다. 🚀 이진 탐색 트리란? “이진 탐색”을 위한 이진 트리(자식 노드가 최대 2개) 모든 노드의 Key 는 유일하다. (중복이 없다.) 왼쪽 자식 노드는 나보다 작고 ✨ 오른쪽 자식 노드는 나보다 크다. ✨ 모든 노드가 위 규칙을 만족한다. 이런 구조 때문에 “이진 탐색”하기가 쉬움! 각각의 노드들이 중앙...","categories": ["Algorithm"],
        "tags": ["Algorithm","Coding Test","Cpp","Graph"],
        "url": "http://localhost:4000/algorithm/bst/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 배달 (최단 경로, 다익스트라, 우선순위 큐를 써야하는 이유)⭐⭐⭐",
        "excerpt":"📌 배달 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ 최단 경로 알고리즘 👉 다익스트라 알고리즘 사용함 최단 경로 알고리즘 정해놓은 특정 정점 1개에서 출발하여 모든 정점들의 순회하며, 특정 정점에서 해당 정점들까지의 최단 경로를 업데이트한다. 👉 다익스트라가 적합 출발지는 1 번 마을 고정이며 1 번 마을에서 그 외 마을들까지의 최단...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/111/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 기지국 설치⭐⭐⭐",
        "excerpt":"📌 기지국 설치 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 🔥 1 차 풀이 ❌ #include &lt;vector&gt; using namespace std; int solution(int n, vector&lt;int&gt; stations, int w) { int answer = 0; // already 에 추가 증설 전에도 전파를 전달 받을 수 있는 아파트 체크 vector&lt;bool&gt; already(n + 1); int...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/112/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 스타 수열⭐⭐⭐",
        "excerpt":"📌 스타 수열 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ X는 부분수열 (순서는 유지한채 몇몇 원소들을 제거해서 만들 수 있는 부분) ✨X 부분 수열이 \"스타 수열\"이 되려면 만족 해야 하는 조건✨ 조건 1 : X 는 길이가 2 인 집합 n 개로 이루어진다. (이때 X의 길이 = 2n. X는...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/113/",
        "teaser": null
      },{
        "title": "Chater 3-1. 추상 자료형, 캡슐화, 추상화",
        "excerpt":"홍정모 교수님의 강의 홍정모의 따라하며 배우는 C언어(부록) 를 듣고 정리한 필기입니다. 😀 Chapter 3. 추상화 🚀 자료형 자료형은 (데이터)객체의 모음과 그 객체들에 대해 작동하는 연산들이다. A data type is a collection of objects and a set of operations that act on those objects. 메모리를 차지하고 있는, 실존하는 모든 것은 다...","categories": ["DataStructure2"],
        "tags": ["Algorithm","Data Structure","C"],
        "url": "http://localhost:4000/datastructure2/ch3-1/",
        "teaser": null
      },{
        "title": "Chater 3-2. 추상화된 리스트로 구체화한 영화 평점 리스트 (연결리스트 사용)",
        "excerpt":"홍정모 교수님의 강의 홍정모의 따라하며 배우는 C언어(부록) 를 듣고 정리한 필기입니다. 😀 ppt 캡처는 모두 교수님 강의에서 캡처한 것임을 밝힙니다. Chapter 3. 추상화 🚀 인터페이스의 필요성 “어떤 데이터 아이템을 담을 수 있는 리스트”로서 추상화 한다. 👉 일반화!! 영화 평점 뿐만 아니라 어떤 데이터든 담을 수 있는 리스트로서 일반화하기. 모든 아이템...","categories": ["DataStructure2"],
        "tags": ["Algorithm","Data Structure","C"],
        "url": "http://localhost:4000/datastructure2/ch3-2/",
        "teaser": null
      },{
        "title": "Chater 4-1. 스택",
        "excerpt":"홍정모 교수님의 강의 홍정모의 따라하며 배우는 C언어(부록) 를 듣고 정리한 필기입니다. 😀 Chapter 4. 스택 🚀 C언어로 스택 구현하기 (배열 사용) 📜element.h typedef struct { int data; }element; 📜stack.h #include \"element.h\" #include &lt;stdbool.h&gt; #define MAX_STACK_SIZE 5 typedef struct stack { element items[MAX_STACK_SIZE]; int top; }Stack; void Initialize(Stack* stack); bool IsFull(const...","categories": ["DataStructure2"],
        "tags": ["Algorithm","Data Structure","C"],
        "url": "http://localhost:4000/datastructure2/ch4-1/",
        "teaser": null
      },{
        "title": "Chater 4-2. 플러드 필 알고리즘 구현 (스택 사용)",
        "excerpt":"홍정모 교수님의 강의 홍정모의 따라하며 배우는 C언어(부록) 를 듣고 정리한 필기입니다. 😀 ppt 캡처는 모두 교수님 강의에서 캡처한 것임을 밝힙니다. Chapter 4. 스택 🚀 플러드 필 알고리즘이란? (Flood Fill) 플러드 필 위키피디아 하얀 곳은 갈 수 있는 곳, 파란 곳은 벽이라 갈 수 없는 곳이다. BFS과 비슷하게 이동은 스택에서 빼내는(Pop)...","categories": ["DataStructure2"],
        "tags": ["Algorithm","Data Structure","C"],
        "url": "http://localhost:4000/datastructure2/ch4-2/",
        "teaser": null
      },{
        "title": "Chater 5-1 배열로 원형 큐 구현하기",
        "excerpt":"홍정모 교수님의 강의 홍정모의 따라하며 배우는 C언어(부록) 를 듣고 정리한 필기입니다. 😀 ppt 캡처는 모두 교수님 강의에서 캡처한 것임을 밝힙니다. Chapter 5. 큐 🚀 Queue 란? 스택 👉 먼저 들어온게 가장 늦게 나간다. (Last In First Out) 큐 👉 먼저 들어온게 가장 먼저 나간다. (First In First Out) 들어온게 가장...","categories": ["DataStructure2"],
        "tags": ["Algorithm","Data Structure","C"],
        "url": "http://localhost:4000/datastructure2/ch5-1/",
        "teaser": null
      },{
        "title": "Chater 5-2 연결리스트로 큐 구현하기",
        "excerpt":"홍정모 교수님의 강의 홍정모의 따라하며 배우는 C언어(부록) 를 듣고 정리한 필기입니다. 😀 ppt 캡처는 모두 교수님 강의에서 캡처한 것임을 밝힙니다. Chapter 5. 큐 🚀 연결리스트로 큐 구현하기 연결리스트는 삭제 연산시 뒤의 모든 원소들을 앞으로 땡겨올 필요가 없다. 그저 체인만 끊으면 되기 때문에 O(1)의 시작 복잡도를 가진다. 따라서 배열과 달리 연결리스트로...","categories": ["DataStructure2"],
        "tags": ["Algorithm","Data Structure","C"],
        "url": "http://localhost:4000/datastructure2/ch5-2/",
        "teaser": null
      },{
        "title": "Chater 5-3 큐를 이용한 시뮬레이션",
        "excerpt":"홍정모 교수님의 강의 홍정모의 따라하며 배우는 C언어(부록) 를 듣고 정리한 필기입니다. 😀 ppt 캡처는 모두 교수님 강의에서 캡처한 것임을 밝힙니다. Chapter 5. 큐 🚀 큐를 이용한 시뮬레이션 점원이 1 명 뿐인 아이스크림 가게에서 큐의 원소를 “손님”이라고 생각하고 큐가 손님들이 줄서서 대기하고 있는 “줄”이라고 생각해보자. 📜 LinkedQueue.h typedef struct customer {...","categories": ["DataStructure2"],
        "tags": ["Algorithm","Data Structure","C"],
        "url": "http://localhost:4000/datastructure2/ch5-3/",
        "teaser": null
      },{
        "title": "Chater 6-1 이진 탐색(Binary Search)",
        "excerpt":"홍정모 교수님의 강의 홍정모의 따라하며 배우는 C언어(부록) 를 듣고 정리한 필기입니다. 😀 ppt 캡처는 모두 교수님 강의에서 캡처한 것임을 밝힙니다. Chapter 6. Binary Search 🚀 탐색 🔥 순차 탐색 처음부터 끝까지 차례대로 하나씩 다 순회하면서 찾아봐야 함. 🔥 이진 탐색 정렬이 되어 있어야 한다는 전제가 있어야 한다. 정렬 시간 소모가...","categories": ["DataStructure2"],
        "tags": ["Algorithm","Data Structure","C"],
        "url": "http://localhost:4000/datastructure2/ch6-1/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 게임 맵 최단거리 (BFS)⭐⭐",
        "excerpt":"📌 게임 맵 최단거리 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 🔥 첫 번째 풀이 ⭕ BFS 사용한 이유 가중치가 없다. BFS를 사용하면 출발지로부터 각 노드까지의 방문은 최단 경로로 이루어질 수 밖에 없다. 큐를 사용하여 “너비 우선 탐색”을 하기 때문에 자연스럽게 출발지로부터 거리 순으로 방문이 되기 때문이다. 그리고 도착지가 되는...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/114/",
        "teaser": null
      },{
        "title": "Chater 6-2 이진 탐색 트리(Binary Search Tree)",
        "excerpt":"홍정모 교수님의 강의 홍정모의 따라하며 배우는 C언어(부록) 를 듣고 정리한 필기입니다. 😀 ppt 캡처는 모두 교수님 강의에서 캡처한 것임을 밝힙니다. Chapter 6. Binary Search 🚀 이진 탐색 트리란? 이진 검색 트리 &amp; 힙 트리 참고 이진 탐색 트리 (장단점, 삽입, 삭제, 탐색, 순회) 🔥 삭제 삭제의 경우 내가 기존에 알고...","categories": ["DataStructure2"],
        "tags": ["Algorithm","Data Structure","C"],
        "url": "http://localhost:4000/datastructure2/ch6-2/",
        "teaser": null
      },{
        "title": "블록체인(BlockChain)과 블록체인 네트워크, Proof of Work(PoW)",
        "excerpt":"🚀 블록체인이란? Data 들을 블록 단위로 묶어 저장하고 이 블록들을 체인 형태로 연결하여 저장한 기술 연결리스트랑 똑같다! 근데 앞의 노드를 기억하는 방법이 블록체인은 조금 다름 이전 노드의 메모리 주소를 기억하는 연결리스트와 달리 블록체인은 이전 블록을 기억하는 방법에 해시 함수를 씀 👉 앞에 있는 이전 블록의 고유한 해시값을 저장한다. 👉 이런식으로...","categories": ["Bitcoin"],
        "tags": ["BlockChain","BitCoin"],
        "url": "http://localhost:4000/bitcoin/blockchain/",
        "teaser": null
      },{
        "title": "대칭키, 비대칭키, 공개키, 개인키, 전자서명",
        "excerpt":"🚀 대칭키, 비대칭키 대칭키 암호화와 복호화에 사용되는 키가 동일하다. 하나의 키로 암호화와 복호화 둘 다에 사용된다. 따라서 암호화 할 때 사용한 키를 복호화하려는 사람도 그 동일한 키를 알고 있어야 하기 때문에 키를 교환해야한다는 수고로움이 있다. 해킹에도 취약하다. 키만 알면 복호화도 바로 할 수 있기 때문이다. 비대칭키 암호화와 복호화에 사용되는 키가...","categories": ["Bitcoin"],
        "tags": ["BlockChain","BitCoin"],
        "url": "http://localhost:4000/bitcoin/cryptography/",
        "teaser": null
      },{
        "title": "How does 💰bitcoin💰 actually work?",
        "excerpt":"공동 장부 사람들끼리의 거래 내역을 공동 장부에 써놓고 나중에 한번에 정산. 기록만 해두고 실제 돈 거래는 정산 날 모두 모여서 거래 내역을 보고 검증하여 정산. 이 공동 장부는 언제든지 볼 수 있고 기록할 수 있다. 아무나 접속해서 글을 추가할 수 있는 웹사이트 같음. 아무나 기록할 수 있다는게 문제! 진실되게 기록되었다는...","categories": ["Bitcoin"],
        "tags": ["BlockChain","BitCoin"],
        "url": "http://localhost:4000/bitcoin/bitcoin/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 추석 트래픽 (문자열 파싱, 실수 처리)⭐⭐⭐",
        "excerpt":"📌 추석 트래픽 난이도 ⭐⭐⭐ 🚀 문제 “2016-09-15” 는 고정이다. 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;sstream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int solution(vector&lt;string&gt; lines) { int answer = 0; int n = lines.size(); // 로그 개수 vector&lt;int&gt; start(n); // start[i] : i + 1 번째 로그의...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/115/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 스티커 모으기2 (DP)⭐⭐⭐",
        "excerpt":"📌 스티커 모으기(2) 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ✈ 1 차 풀이 ❌ #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int solution(vector&lt;int&gt; sticker) { int answer = 0; int sum = 0; if (sticker.size() == 1) return sticker[0]; if (sticker.size() % 2 == 0){ // 짝수일 때 for(int...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/116/",
        "teaser": null
      },{
        "title": "[백준 2003][🤍3] 수들의 합 2 (투포인터 알고리즘) ",
        "excerpt":"🚀 난이도 🤍 실버 3 🚀 문제 https://www.acmicpc.net/problem/2003 예제 입력 1 4 2 1 1 1 1 예제 출력 1 3 예제 입력 2 10 5 1 2 3 4 2 5 3 1 1 2 예제 출력 2 3 🚀 내 풀이 ⭕ #include &lt;iostream&gt; #include &lt;vector&gt; using namespace...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/2003/",
        "teaser": null
      },{
        "title": "[백준 2470][💛5] 두 용액 (투포인터 알고리즘) ",
        "excerpt":"🚀 난이도 💛 골드 5 🚀 문제 https://www.acmicpc.net/problem/2470 예제 입력 1 5 -2 4 -99 -1 98 예제 출력 1 -99 98 🚀 내 풀이 ⭕ #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #define INF 2000000000 using namespace std; vector&lt;int&gt; answer(2); int main() { int N; cin &gt;&gt; N; vector&lt;int&gt; arr(N);...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/2470/",
        "teaser": null
      },{
        "title": "(C++) 투포인터 알고리즘, 슬라이딩 윈도우 알고리즘, Prefix Sum 구간합",
        "excerpt":"투포인터 알고리즘 👉 구간이 가변적 길이 슬라이딩 윈도우 👉 구간이 고정적 길이 🚀 투포인터 알고리즘 어떤 특정 조건을 만족하는 🔥연속 구간🔥을 구할 때 O(N) 으로 풀 수 있도록 도와주는 알고리즘 2 개의 포인터를 사용하여 구간의 길이를 가변적 적으로잡아가며 특정 조건을 만족하는 구간을 찾는다. 모든 연속 구간을 잡는다면 O(N^2)이 될 것이지만...","categories": ["Algorithm"],
        "tags": ["Algorithm","Coding Test","Cpp","Graph"],
        "url": "http://localhost:4000/algorithm/twopointer/",
        "teaser": null
      },{
        "title": "[백준 11003][💚5] 최소값 찾기 (슬라이딩 윈도우, deque) ",
        "excerpt":"🚀 난이도 💚 플래티넘 5 🚀 문제 https://www.acmicpc.net/problem/11003 예제 입력 1 12 3 1 5 2 3 6 2 3 7 3 5 2 6 예제 출력 1 1 1 1 2 2 2 2 2 3 3 2 2 🚀 내 풀이 deque라는 자료구조에 대해 처음 알게된 문제! O(N)으로...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/11003/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 경주로 건설 (DFS, BFS, 다익스트라)⭐⭐⭐",
        "excerpt":"📌 경주로 건설 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 🔥 1 차 풀이 ❌ (최소의 코너 횟수를 구해야하는걸로 착각한 풀이) #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std; struct Pos { int x; int y; int corner; // (y, x) 를 방문 했을 때 여태까지의 최소 코너 횟수...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/117/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 보석 쇼핑 (투포인터 알고리즘)⭐⭐⭐",
        "excerpt":"📌 보석 쇼핑 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 🔥 1 차 풀이 ⏰(시간 초과) #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;unordered_map&gt; #include &lt;set&gt; using namespace std; // 보석 하나 struct Jewelry { string name; // 보석의 이름 문자열 set&lt;int&gt; positions; // 이 보석이 위치한 인덱스들 모아둔 집합...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/118/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 셔틀버스⭐⭐⭐",
        "excerpt":"📌 셔틀버스 난이도 ⭐⭐⭐ 🚀 문제 🔥 문제 설명 첫 버스는 무조건 09 : 00 에 온다. 같은 시간에 온 사람들이 선 줄에서 콘은 언제나 맨 뒤에 줄선다. 버스 오는 시간에 줄 선 사람도 버스에 탈 수 있다. 콘은 게으르기 때문에 마지막 버스 타고 출근할 수 있는, 최대한 늦게 줄을...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/119/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 합승 택시 요금 (플로이드 와샬, 다익스트라)⭐⭐⭐",
        "excerpt":"📌 합승 택시 요금 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 (i = 1,2,3,..,n) S 에서 출발해서 i 까지 합승하고, 그 이후엔 따로 따로 i 에서 A 까지, i 에서 B 까지 가는 최소 택시비용 구하기 즉, 이 문제는 ⭐최소비용(S 👉 i) + 최소비용(i 👉 A) + 최소비용(i 👉 B)⭐...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/120/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 징검다리 건너기 (이분탐색)⭐⭐⭐",
        "excerpt":"📌 징검다리 건너기 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 (이분탐색) stones의 크기(디딤돌의 개수)는 최대 200,000 개이기 때문에 O((\\N^2\\)) 시간복잡도부턴 시간 초과가 발생하게 될 것이다. 그러니 최대 몇 명까지 징검다리를 건널 수 있을지 일일이 이번엔 몇명 건넜다, 몇명 건넜다 하며 매번 stones를 순회하는 방식으로 풀이한다면 O((\\N^2\\))에 도달하여 시간 초과가 발생할...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/121/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 기둥과 보 설치⭐⭐⭐",
        "excerpt":"📌 기둥과 보 설치 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ 추가 “기둥”을 추가할 때 기둥의 3 가지 조건 중 하나라도 만족하는지 추가하려는 기둥을 검사 하고 기둥을 추가한다. “보”를 추가할 때 보의 2 가지 조건 중 하나라도 만족하는지 추가하려는 보를 검사 하고 기둥을 추가한다. 삭제 이 기둥 혹은 보를...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/122/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 보행자 천국 (DP)⭐⭐⭐",
        "excerpt":"📌 보행자 천국 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 🔥 1 차 풀이 : DP ⭕ 자동차는 오른쪽, 아래쪽 이 2 가지 방향으로만 바라볼 수 있다. (자동차는 오른쪽, 아래 방향으로만 이동이 가능하다고 문제에서 주어졌기 때문이다.) 🟥 빨간색 글씨 통행할 수 없는 곳이므로 오른쪽 바라볼 때 경로 수, 아래쪽 바라볼...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/123/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 광고 삽입 (구간합 Prefix Sum, 투포인터)⭐⭐⭐",
        "excerpt":"📌 광고 삽입 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 숙지해야 할 것 시청 종료 시간은 시청자 수 카운팅에 포함되지 않는다고 생각한다. “동영상 재생시간 = 재생이 종료된 시각 - 재생이 시작된 시각(예를 들어, 00시 00분 01초부터 00시 00분 10초까지 동영상이 재생되었다면, 동영상 재생시간은 9초 입니다.” 라고 문제에서 언급 되었기 때문이다....","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/124/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 매칭 점수⭐⭐⭐",
        "excerpt":"📌 매칭 점수 난이도 ⭐⭐⭐ 🚀 문제 [\"&lt;html lang=\\\"ko\\\" xml:lang=\\\"ko\\\" xmlns=\\\"http://www.w3.org/1999/xhtml\\\"&gt;\\n&lt;head&gt;\\n &lt;meta charset=\\\"utf-8\\\"&gt;\\n &lt;meta property=\\\"og:url\\\" content=\\\"https://a.com\\\"/&gt;\\n&lt;/head&gt; \\n&lt;body&gt;\\nBlind Lorem Blind ipsum dolor Blind test sit amet, consectetur adipiscing elit. \\n&lt;a href=\\\"https://b.com\\\"&gt; Link to b &lt;/a&gt;\\n&lt;/body&gt;\\n&lt;/html&gt;\", \"&lt;html lang=\\\"ko\\\" xml:lang=\\\"ko\\\" xmlns=\\\"http://www.w3.org/1999/xhtml\\\"&gt;\\n&lt;head&gt;\\n &lt;meta charset=\\\"utf-8\\\"&gt;\\n &lt;meta property=\\\"og:url\\\" content=\\\"https://b.com\\\"/&gt;\\n&lt;/head&gt; \\n&lt;body&gt;\\nSuspendisse potenti. Vivamus venenatis tellus non turpis...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/125/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 카드 짝 맞추기 (순열 속 순열, 완전탐색, DFS, BFS, DP)⭐⭐⭐",
        "excerpt":"📌 카드 짝 맞추기 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 💡 어떻게 풀이할 것인가 키 조작 횟수의 최소값 을 구하는 것이기 때문에, 같은 그림의 카드를 바로 바로 한번에 찾는다고 가정하고 문제를 풀이하면 그게 바로 최소의 조작 횟수 “후보”가 된다. 예를 들어 라이언 카드를 뒤집은 상태면 다른 카드를 뒤집어 실패하지...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/126/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 외벽 점검 (완전 탐색, DFS, 비트 연산으로 방문 체크)⭐⭐⭐",
        "excerpt":"📌 외벽 점검 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 🔥 1 차 풀이 (시간초과⏰) #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; bool found = false; int north; // n void DFS(int&amp; num, vector&lt;int&gt;&amp; weak, vector&lt;bool&gt;&amp; weak_visited, vector&lt;int&gt;&amp; friends, int depth) { // num 은 설정한 필요한 친구...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/127/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 블록 이동하기 (BFS, 해시 함수)⭐⭐⭐",
        "excerpt":"📌 블록 이동하기 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 문제는 일반적인 BFS 문제 풀듯이 풀면 된다. 그러나 주의 깊게 생각해야 할 부분은 다음과 같다. 1️⃣ 로봇은 회전이 가능하다는 점! 현재 위치에서 로봇이 회전된 위치들 또한 큐에 삽입하여야 한다. 2️⃣ 로봇은 두 파트로 이루어져 있기 때문에 2 개의 좌표를 차지한다....","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/128/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 리틀 프렌즈 사천성 (BFS, 다익스트라)⭐⭐⭐",
        "excerpt":"📌 리틀 프렌즈 사천성 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 최대한 제거 가능한 선에서 알파벳 순으로 가장 먼저인 것을 제거해야 한다. 따라서 알파벳 순서가 가장 빠른 것 ⭐한 개⭐를 제거하고, 또 제거 가능한 것들을 검사하여 그 중 알파벳 순서가 가장 빠른 것 한개를 제거하고.. 또 제거할 수 있는 것...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/129/",
        "teaser": null
      },{
        "title": "(C++) BFS 와 다익스트라의 거리 저장 및 업데이트 과정 차이",
        "excerpt":"🚀 BFS 와 다익스트라에 대한 자세한 개념 설명 Chapter 4-4. 그래프 순회 방법 2️⃣ - BFS(너비 우선 탐색) Chapter 4-5. 다익스트라 최단 경로 알고리즘 🚀 BFS 의 거리 저장 및 업데이트 1️⃣ “배열” 안에 거리를 저장하는 방법 👉 모든 노드까지의 거리가 전부 필요할 때 2️⃣ “구조체”(큐의 원소가 되는) 안에 거리를...","categories": ["Algorithm"],
        "tags": ["Algorithm","Coding Test","Cpp","Graph"],
        "url": "http://localhost:4000/algorithm/bfsdijkstra/",
        "teaser": null
      },{
        "title": "(C++) 비트와 부분 집합 (+ STL bitset 활용)",
        "excerpt":"C++ Chapter 3.3 : 비트끼리의 연산, 비트 플래그, 비트 마스크 🚀 비트를 이용한 부분 집합 원소가 n개 인 집합이 있다고 할 때, n 자리의 비트를 사용하여 이 집합의 부분 집합을 표현할 수 있다. 👉 1 비트에 해당하는 자리만 활성화 한다고 생각하면 된다. n개의 원소로 이루어진 집합이 있다고 할 때 부분...","categories": ["Algorithm"],
        "tags": ["Algorithm","Coding Test","Cpp","Graph"],
        "url": "http://localhost:4000/algorithm/bitset/",
        "teaser": null
      },{
        "title": "[C++로 풀이] GPS (DP)⭐⭐⭐",
        "excerpt":"📌 GPS 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ 이 문제는.. 한 1시간 고민하다가 전혀 모르겠어요^_^ 하고는 다른 분들의 풀이를 보고 이해해서 겨우 푼 문제다. DP 문제에 너무 약한 것 같다.. DP 문제라고 감도 못 잡았는데 ㅠ ㅠ.. 큰 일이다. DP 문제 많이 풀어봐야겠다 싶다..!!🔥🔥 #include &lt;vector&gt; #include &lt;algorithm&gt;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/130/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 브라이언의 고민⭐⭐⭐",
        "excerpt":"📌 브라이언의 고민 난이도 ⭐⭐⭐ 🚀 문제 Level 3 문제들 중에서 풀은 사람 수가 가장 적은 문제이길래 겁이 나서.. 제일 뒤로 미뤘었던 문제인데ㅋㅋㅋ 드디어 풀어 보게 되었다! 역시 풀은 사람의 수가 적은건 이유가 있다.. 구현이 넘 까다로웠다.. 하..ㅠㅠㅋㅋㅋㅋㅋㅋ 연습장에 구현해야할 조건들을 수기로 쭉 정리해본 후 코드를 짰다. 연습장 두 페이지를...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/131/",
        "teaser": null
      },{
        "title": "[Code Up] (3004) 데이터 재정렬",
        "excerpt":"C/C++로 풀이했습니다. 출처 : Code Up 문제 풀이. https://codeup.kr/ 🚀 문제 https://codeup.kr/problem.php?id=3004 프로그래밍 문제를 풀다 보면 뒤죽박죽인 N개의 데이터를 숫자의 크기 순으로 0 ~ N-1까지의 숫자로 재정렬 해야되는 경우가 종종 있다. 예를 들어 N=5 이고, 50 23 54 24 123 이라는 데이터가 있다면, 2 0 3 1 4 가 된다....","categories": ["CodeUp"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/codeup/11/",
        "teaser": null
      },{
        "title": "[Code Up] (3015) 성적표 출력 (stable_sort)",
        "excerpt":"C/C++로 풀이했습니다. 출처 : Code Up 문제 풀이. https://codeup.kr/ 🚀 문제 https://codeup.kr/problem.php?id=3015 세종이는 정보과학 선생님인 JH를 도와주기 위해 정보과학 성적처리 프로그램을 만들기로 했다. JH 선생님은 학생들의 명단과 점수를 입력하면 상위 m명의 학생 명단을 출력해 주기를 원한다. 다음 조건을 만족하는 프로그램을 작성해 보자. 입력 첫째 줄에 데이터의 개수 n (3&lt;=n&lt;=100)과 출력인원...","categories": ["CodeUp"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/codeup/12/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 무지의 먹방 라이브 ⭐⭐⭐⭐",
        "excerpt":"📌 무지의 먹방 라이브 난이도 ⭐⭐⭐⭐ 🚀 문제 입력 크기가 매우 크고(k의 최대값이 무려 20조..!) 효율성 테스트가 있기 때문에 food_times을 k번 만큼 ‘순환적으로’ 순회하면서 1 씩 감소시켜서 답을 구하면 안된다. (즉, O(k)이면 안됨) 정확성 테스트는 통과할 수 있겠지만 효율성 테스트는 절대 통과할 수 없다. 따라서 k번 순회하지 않고 답을 도출할...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/132/",
        "teaser": null
      },{
        "title": "[백준 14425][🤍2] 문자열 집합 (해시)",
        "excerpt":"🚀 난이도 🤍 실버 2 🚀 문제 https://www.acmicpc.net/problem/14425 🚀 내 풀이 ⭕ “부분 문자열”이 아닌, 정확하게 문자열 전체가 일치하는 것을 찾아야 한다. 즉, 단어 단위로 일치하는 것! 입력 되는 문자열들 중 n 개는 집합 S 의 문자열들이고 뒤 이어 나오는 m개는 검사해야 하는 문자열들이다. #include &lt;bits/stdc++.h&gt; using namespace std; int...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/14425/",
        "teaser": null
      },{
        "title": "[백준 5052][💛4] 전화번호 목록 (해시, 트라이)",
        "excerpt":"🚀 난이도 💛 골드 4 🚀 문제 https://www.acmicpc.net/problem/5052 🚀 내 풀이 프로그래머스의 “전화번호 목록” 문제와 똑같다. 심지어 문제 이름도 똑같네! 입력 크기는 프로그래머스 문제가 더 빡센 편이다. 🔥 해시 사용한 풀이 1️⃣ 현재 검사하는 번호의 접두어들이 해시셋에 있는지 검사. 있다면 “NO” 출력 후 종료 “abcd” 라는 단어가 있다면 “a”, “ab”,...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/5052/",
        "teaser": null
      },{
        "title": "[백준 14725][💛2] 개미굴 (트라이)",
        "excerpt":"🚀 난이도 💛 골드 2 🚀 문제 https://www.acmicpc.net/problem/14725 🚀 내 풀이 ⭕ 트라이에 관한 더 자세한 설명은 이 포스트를 참고해주세요. 👉 (C++) 문자열 집합 : 트라이 자료구조 1️⃣ 트라이 그래프(트리)를 만들어 그 안에 모든 문자열을 저장하면 위와 같은 모양이 된다. 2️⃣ 그리고 이를 DFS 로 탐색하며 출력하면 된다. 노드에 들어갈...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/14725/",
        "teaser": null
      },{
        "title": "[백준 5670][💚4] 휴대폰 자판 (트라이, 원하는만큼 입력 받기)",
        "excerpt":"🚀 난이도 💚 플래티넘 4 🚀 문제 https://www.acmicpc.net/problem/5670 🚀 내 풀이 ⭕ 트라이에 관한 더 자세한 설명은 이 포스트를 참고해주세요. 👉 (C++) 문자열 집합 : 트라이 자료구조 1️⃣ 첫 글자는 자동 입력 할 수 없다. 무조건 사용자가 수동 입력 해야 한다. 2️⃣ 다음 글자가 될 수 있는 후보가 유일하게 하나일...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/5670/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 가사 검색 (트라이 자료구조, 문자열 검색, 이분 탐색) ⭐⭐⭐⭐",
        "excerpt":"📌 가사 검색 난이도 ⭐⭐⭐⭐ 🚀 문제 🚀 내 풀이 🔥 트라이 자료구조를 사용한 풀이 ⭕ 문자열 집합을 트라이 트리에 저장하고 이를 탐색하면 문제를 해결할 수 있다. 우선 입력 크기와 문자열 길이가 상당히 크기 때문에 일일이 비교하는 브루트 포스로는 이 문제의 효율성 테스트를 통과할 수 없을 것이다. 트라이를 사용하면 문자열...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/133/",
        "teaser": null
      },{
        "title": "(C++) 문자열 집합 : 트라이 자료구조",
        "excerpt":"🚀 트라이 자료구조 “접두사”를 검색하거나 “단어 자체”를 검색하는 데에 특화된 문자열 집합 자료구조 여러 문자열들이 모인 집합 내에서 특정 문자열을 탐색(검색) 하고자 할 때 특화된 문자열 집합 자료구조이며 트리 형태이다. 위와 같이 문자열 집합 내에서 중복되는 \"접두사\"들에 대응되는 노드들이 서로 연결된 트리이다. 같은 접두사는 같은 노드로 겹쳐서 저장된다(트리라서)는 특성 때문에...","categories": ["Algorithm"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/algorithm/trie/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 음양 더하기 ⭐",
        "excerpt":"📌 음양 더하기 난이도 ⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int solution(vector&lt;int&gt; absolutes, vector&lt;bool&gt; signs) { int answer = 0; int n = absolutes.size(); for (int i = 0; i &lt; n; ++i) if (signs[i] == false) absolutes[i] *= -1; for (int...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/134/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 괄호 회전하기⭐⭐",
        "excerpt":"📌 괄호 회전하기 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;stack&gt; using namespace std; int solution(string s) { int answer = 0; for (int i = 0; i &lt; s.length(); ++i) { stack&lt;char&gt; st; bool flag = false; for (int i = 0; i...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/135/",
        "teaser": null
      },{
        "title": "[백준 1260][🤍2] DFS와 BFS",
        "excerpt":"🚀 난이도 🤍 실버 2 🚀 문제 https://www.acmicpc.net/problem/1260 🚀 내 풀이 ⭕ #include &lt;bits/stdc++.h&gt; using namespace std; void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;bool&gt;&amp; checked, int now) { cout &lt;&lt; now &lt;&lt; ' '; // 방문 출력 for (int i = 0; i &lt; graph[now].size(); ++i) { int next = graph[now][i]; if (!checked[next])...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/1260/",
        "teaser": null
      },{
        "title": "[백준 2667][🤍1] 단지 번호 붙이기 (DFS, BFS)",
        "excerpt":"🚀 난이도 🤍 실버 1 🚀 문제 https://www.acmicpc.net/problem/2667 🚀 내 풀이 그래프 하나를 “단지”에 대응 시킨다. 즉, 연결된 그래프(= 단지)가 여러개일 수 있기 때문에 하나의 그래프 탐색이 끝나도 아직 방문 안한 집이 보이면 새로운 그래프라는 뜻이므로 또 탐색을 시도한다. DFS, BFS 를 지도의 모든 지점에 대해 방문 안한 집이면 실행하도록...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/2667/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 모두 0 으로 만들기 (DFS, 트리) ⭐⭐⭐",
        "excerpt":"📌 모두 0 으로 만들기 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ 트리를 DFS 로 순회하여 1️⃣ Leaf 노드에 도달할 때까지 깊이 들어간 후 2️⃣ 빠져 나오는 과정에서 가중치를 0 으로 만드는 횟수와 가중치의 합을 더해나가야 한다. Leaf 노드까지 깊이 들어간 후 되돌아가며 트리를 올라가는 과정에서(= 매 단계마다 재귀...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/136/",
        "teaser": null
      },{
        "title": "[백준 1305][💚5] 광고 (KMP)",
        "excerpt":"🚀 난이도 💚 플래티넘 5 🚀 문제 https://www.acmicpc.net/problem/1305 🚀 내 풀이 ⭕ 📌 KMP 알고리즘 에 대한 자세한 설명은 링크로 https://ansohxxn.github.io/algorithm/kmp/ 이 문제는 KMP 알고리즘의 실패 함수로 해결할 수 있다. 위 링크에 실패 함수 코드에 대한 설명도 자세히 기재해두었으니 참고했으면 좋겠다. :) 어느 순간 전광판을 딱 쳐다봤을 때 “그때의 문자열에서...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/1305/",
        "teaser": null
      },{
        "title": "[백준 1786][💛1] 찾기 (KMP)",
        "excerpt":"🚀 난이도 💛 골드 1 🚀 문제 https://www.acmicpc.net/problem/1786 이 문제에서 설명하는 것 자체가 KMP 알고리즘이다. 🚀 내 풀이 📌 KMP 알고리즘 에 대한 자세한 설명은 링크로 https://ansohxxn.github.io/algorithm/kmp/ KMP 알고리즘의 대표적인 두 코드로 제출을 했다. 자세한 설명은 위 링크에 다 기재해두었기 때문에 이 포스트에선 설명을 생략하겠다. 🔥 첫 번째 풀이 ⭕...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/1786/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 자동 완성 (트라이 자료구조) ⭐⭐⭐⭐",
        "excerpt":"📌 자동 완성 난이도 ⭐⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ 트라이에 관한 더 자세한 설명은 이 포스트를 참고해주세요. 👉 (C++) 문자열 집합 : 트라이 자료구조 이 문제는 트라이 자료구조 문제로, 아래 두 문제와 유사하다. 두 문제를 짬뽕해서 푸는 느낌!! [백준 5670][💚4] 휴대폰 자판 (트라이, 원하는만큼 입력 받기) 이 문제도...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/137/",
        "teaser": null
      },{
        "title": "[백준 9250][💚2] 문자열 집합 판별 (아호-코라식, 트라이)",
        "excerpt":"🚀 난이도 💚 플래티넘 2 🚀 문제 https://www.acmicpc.net/problem/9250 🚀 내 풀이 🔥 ‘아호-코라식’ 으로 풀이 ⭕ 아호-코라식 알고리즘에 대해서는 (C++) 문자열 검색 알고리즘 : 아호-코라식(Aho-Corasick) 알고리즘 👈 이 포스트에 자세히 설명해두었으니 참고 :) 제출했던 아래 코드는 아호-코라식 코드 그대로이다. 아호 코라식 알고리즘을 사용하면, 검색어의 개수가 \\(k\\) 개 일 때 하나의...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/9250/",
        "teaser": null
      },{
        "title": "(C++) 문자열 검색 알고리즘 : KMP 알고리즘",
        "excerpt":"🚀 서론 🔥 쓰임새 어떤 글에서 원하는 문자열을 찾을 때 Ctrl + F 를 눌러 검색을 하곤 하는데, 이렇게 어떤 문자열에서 원하는 문자열을 검색할 때 그 검색어의 위치를 찾아주는 알고리즘이다. “알고리즘” 단어를 검색한다면? “KMP 알고리즘에 대해 배워봅시다. 알고리즘 공부 ~.~” A 문자열에서 B 문자열을 검색한다면, A 문자열의 부분 문자열로서 B...","categories": ["Algorithm"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/algorithm/kmp/",
        "teaser": null
      },{
        "title": "(C++) 문자열 검색 알고리즘 : 아호-코라식(Aho-Corasick) 알고리즘",
        "excerpt":"🚀 서론 아호 코라식 알고리즘을 이해하기 위해선 트라이 자료구조와 KMP 알고리즘 개념이 선행되어야 한다.(추가로 BFS 도 알고 있어야 한다.) 아호 코라식은 트라이 자료구조를 사용하며 KMP 알고리즘의 확장판이라고 볼 수 있기 때문이다. 자세한 설명은 아래 링크 참고 :) 문자열 집합 : 트라이 자료구조 문자열 검색 알고리즘 : KMP 알고리즘 그래프 순회...","categories": ["Algorithm"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/algorithm/ahocorasick/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 호텔 방 배정 (Union-Find) ⭐⭐⭐⭐",
        "excerpt":"📌 호텔 방 배정 난이도 ⭐⭐⭐⭐ 🚀 문제 🚀 내 풀이 k 가 매우 크다. 그러므로 방 하나하나를 선형으로 순회하는 \\(O(k)\\) 만으로도 시간 초과가 될 것이다. 🔥 이분 탐색 풀이 ❌ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; vector&lt;long long&gt; solution(long long k, vector&lt;long long&gt; room_number) { vector&lt;long long&gt; answer;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/138/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 올바른 괄호의 갯수 (DFS, 순열) ⭐⭐⭐⭐",
        "excerpt":"📌 올바른 괄호의 갯수 난이도 ⭐⭐⭐⭐ 🚀 문제 🚀 내 풀이 🔥 첫 번째 풀이 ⭕ (DFS) #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int N, Answer; void DFS(int open, int close) { // open : 현재까지 열린 괄호의 개수, close : 현재까지 닫힌 괄호의 개수 if (open &gt; N...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/139/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 블록 게임 ⭐⭐⭐⭐",
        "excerpt":"📌 블록 게임 난이도 ⭐⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ 12 가지 블록들에 각각 번호를 붙여 정의한 상태 검은 블록은 위에서 떨어지기 때문에 검은 블록 2 개를 모두 받아 2 x 3 직사각형이 다 채워져 제거될 수 있는 블록은 3, 4, 6, 7, 9 번 블록이다. 그 외 블록은...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/140/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 로또의 최고 순위와 최저 순위⭐",
        "excerpt":"📌 로또의 최고 순위와 최저 순위 난이도 ⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;set&gt; using namespace std; int Rank(int num){ if(num == 1 || num == 0) return 6; else return 7 - num; } vector&lt;int&gt; solution(vector&lt;int&gt; lottos, vector&lt;int&gt; win_nums) { vector&lt;int&gt; answer; set&lt;int&gt;...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/141/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 행렬 테두리 회전하기 ⭐⭐",
        "excerpt":"📌 행렬 테두리 회전하기 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; solution(int rows, int columns, vector&lt;vector&lt;int&gt;&gt; queries) { vector&lt;int&gt; answer; vector&lt;vector&lt;int&gt;&gt; board(rows + 1, vector&lt;int&gt;(columns + 1)); int num = 0; for (int i = 1; i &lt;= rows; ++i) for...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/142/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 다단계 칫솔 판매 ⭐⭐⭐",
        "excerpt":"📌 다단계 칫솔 판매 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; #include &lt;unordered_map&gt; using namespace std; unordered_map&lt;string, string&gt; parent; // Key 사람, Value : 이 사람의 트리 상 부모(= 이 사람을 다단계에 참여시킨 사람) unordered_map&lt;string, int&gt; profit; // Key 사람, Value : 이 사람의 순이익...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/143/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 동굴 탐험 (DFS, BFS) ⭐⭐⭐⭐",
        "excerpt":"📌 동굴 탐험 난이도 ⭐⭐⭐⭐ 🚀 문제 🚀 내 풀이 어떻게 접근해야할지 모르겠어서 어떻게 풀이하면 되는지를 구글링 해 보았는데 생각보다 풀이가 직관적이였다.. 그냥 DFS 혹은 BFS 로 순회를 하되 그 전에 방문을 마쳐야 할 노드가 있다면 방문 하지 않고 예약만 해둔 후, 전에 방문해야할 그 노드가 방문하면 그제서야 예약해두었던 노드를...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/144/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 쿠키 구입 (투포인터) ⭐⭐⭐⭐",
        "excerpt":"📌 쿠키 구입 난이도 ⭐⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ 모든 경우의 “왼쪽 아들이 가진 과자의 합 = 오른쪽 아들이 가진 과자의 합” 중에서 최대값 찾는 문제 왼쪽 아들과 오른쪽 아들을 가를 수 있는 기준은 m번 바구니 m 번 바구니는 1 번 바구니부터 N - 1 번 바구니까지 될...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/145/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 지형 이동 (MST, BFS) ⭐⭐⭐⭐",
        "excerpt":"📌 지형 이동 난이도 ⭐⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ 1️⃣ BFS 를 통해 연결 되어 있는 그래프(= 사다리 안놓고 갈 수 있는 곳)들로 구분한다. 2️⃣ 각 그래프를 연결 하는 비용(= 사다리 비용)을 구한다. 3️⃣ BFS 로 나눈 그래프들을 하나의 그래프로 통합할 수 있도록 사이클 없고 최소 비용(= 사다리...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/146/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 약수의 개수와 덧셈 ⭐",
        "excerpt":"📌 약수의 개수와 덧셈 난이도 ⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int solution(int left, int right) { int answer = 0; for(int i = left; i &lt;= right; ++i){ int count = 0; for(int j = 1; j &lt;= i; ++j) if...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/147/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 2 개 이하로 다른 비트 ⭐⭐",
        "excerpt":"📌 2 개 이하로 다른 비트 난이도 ⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ #include &lt;string&gt; #include &lt;vector&gt; using namespace std; vector&lt;long long&gt; solution(vector&lt;long long&gt; numbers) { vector&lt;long long&gt; answer; for (int i = 0; i &lt; numbers.size(); ++i) { if (numbers[i] % 2 == 0) answer.push_back(numbers[i] + 1); else...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/148/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 110 옮기기 (스택, 덱) ⭐⭐⭐",
        "excerpt":"📌 110 옮기기 난이도 ⭐⭐⭐ 🚀 문제 🚀 내 풀이 월간 코드 팰린지 시즌2 : 5월 문제 해설 s 원소마다 DFS 로 풀고 제출했다가 온갖 시간 초과 결과를 마주한 후..⭐ (s의 최대 원소는 백 만개이니 너무나 당연한 결과다. 반성해야 돼..!!!) 프로그래머스 공식 해설을 본 후에 다시 풀이하게 되었다. 스택!!!!!을 사용하면...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/149/",
        "teaser": null
      },{
        "title": "[C++로 풀이] 숫자 블록 (소수) ⭐⭐⭐⭐",
        "excerpt":"📌 숫자 블록 난이도 ⭐⭐⭐⭐ 🚀 문제 🚀 내 풀이 ⭕ 자기 자신을 제외하고 10,000,000 을 넘지 않는 선에서의 가장 큰 약수 18 의 약수는 1, 2, 3, 6, 9, 18 이다. 18 번 도로에 설치되는 블록은 9 번 블록이 된다.(n 번 블록은 n * 2 번 도로부터 설치가 되기...","categories": ["Programmers"],
        "tags": ["Algorithm","Coding Test"],
        "url": "http://localhost:4000/programmers/150/",
        "teaser": null
      },{
        "title": "[백준 1774][💛4] 우주신과의 교감 (MST)",
        "excerpt":"🚀 난이도 💛 골드 4 🚀 문제 https://www.acmicpc.net/problem/1774 🚀 내 풀이 ⭕ 문제의 예제로는 이런 상태인 것! 빨간 선은 이미 연결 되어 있는 상태를 뜻하고 파란건 모든 우주신을 연결하기 위해 최소 길이의 연결 통로를 놓은 모습이다. 총합 최소 길이의 연결 통로를 놔서 우주신을 모두 연결할 수 있도록 하는 것! 딱...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/1774/",
        "teaser": null
      },{
        "title": "[백준 14940][💛5] 쉬운 최단거리 (BFS)",
        "excerpt":"🚀 난이도 💛 골드 5 🚀 문제 https://www.acmicpc.net/problem/14940 🚀 내 풀이 ⭕ 정말 기본적인 BFS 문제! 문제에서 목표지점이라고 주어진 부분을 시작점이라고 생각한다. 하나의 시작점으로부터 모든 지점까지의 거리를 구하는 BFS 도달할 수 없는 위치는 -1로 출력을 해야 한다. if (Dist[i][j] == 0 &amp;&amp; Map[i][j] == 1) 갈 수 있는 곳임에도 불구하고...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/14940/",
        "teaser": null
      },{
        "title": "[백준 20164][💛5] 홀수 홀릭 호석",
        "excerpt":"🚀 난이도 💛 골드 5 🚀 문제 https://www.acmicpc.net/problem/20164 홀수에 미친 호석이 🚀 내 풀이 ⭕ 재귀적으로 다음 과정을 수행하면 된다. 현재의 문자열 길이가 3 이상이라면 👉 문자열 길이를 세 부분으로 나누어 홀수 개수를 세고 합친다.(합친건 다음 재귀 문자열이 된다.) 문자열 길이를 S 라고 한다면 S-1 C 2 개의 조합을 구한다....","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/20164/",
        "teaser": null
      },{
        "title": "[백준 20924][💛4] 트리의 기둥과 가지 (DFS, 트리)",
        "excerpt":"🚀 난이도 💛 골드 4 🚀 문제 https://www.acmicpc.net/problem/20924 🚀 내 풀이 기둥의 길이 / 가지의 최대 길이 이렇게 따로 구해야하기 때문에 기둥 길이를 구하는 재귀, 가지 길이를 구하는 재귀 이렇게 구분 하여 DFS 돌리면 편할 것 같다. 1️⃣ 입력시 인접리스트를 만든다. (무방향인 것 고려하기!) 2️⃣ 기둥 길이를 구하는 DFS 수행...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/20924/",
        "teaser": null
      },{
        "title": "[백준 3980][💛4] 선발 명단 (DFS, 백트래킹)",
        "excerpt":"🚀 난이도 💛 골드 4 🚀 문제 https://www.acmicpc.net/problem/3980 🚀 내 풀이 ⭕ N-Queen 문제와 매우 유사한 기본적인 백트래킹 문제였다! 행을 선수로, 열을 포지션으로 생각하고 열이 중복되지 않도록 선택해나가면 되는 문제였다. #include &lt;bits/stdc++.h&gt; using namespace std; int answer = 0; int arr[11][11]; // row : 선수 col : 포지션 bool visited[11];...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/3980/",
        "teaser": null
      },{
        "title": "[백준 1987][💛4] 알파벳 (DFS, 백트래킹)",
        "excerpt":"🚀 난이도 💛 골드 4 🚀 문제 https://www.acmicpc.net/problem/1987 🚀 내 풀이 ⭕ 뭔가 생김새는 BFS 문제 같았지만.. 문제를 읽어보니 백트래킹으로 풀어야 하는 문제였다. 왜냐하면 현재까지 선택해 온 경로에서 한번 방문 했었던 종류의 알파벳은 사용할 수 가 없기 때문이다. 즉, 현재까지 “선택해 온 알파벳”들의 정보가 필요하다. N-Queen 문제와 유사하다. BFS 는...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/1987/",
        "teaser": null
      },{
        "title": "[백준 4358][💛5] 생태학 (map, 소수 출력)",
        "excerpt":"🚀 난이도 💛 골드 5 🚀 문제 https://www.acmicpc.net/problem/4358 🚀 내 풀이 ⭕ 주의해야할 점 공백을 포함하여 문자열 입력 받기. key 는 공백이 포함된 문자열. 👉 getline 소수점 넷째자리 map 은 추가할 때 자동 정렬이 되므로 (이진 탐색 트리라서) 이 map 을 그냥 반복자를 이용해 출력하면 끝! #include &lt;bits/stdc++.h&gt; using namespace...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/4358/",
        "teaser": null
      },{
        "title": "[백준 9489][💛4] 사촌",
        "excerpt":"🚀 난이도 💛 골드 4 🚀 문제 https://www.acmicpc.net/problem/9489 🚀 내 풀이 ⭕ 사촌 사이는 조부모가 같고 부모는 다른 사이이다. (부모끼리는 형제) 나는 그냥.. 정말 직관적이고 단순하게 풀었다! 1️⃣ 우선 arr[i] 모든 노드마다 자신의 부모와 자신의 자식들을 각각 2 가지 map 에 저장하였다.(arr[i] 의 부모를 알 수 있도록 반복자를 두었고 연속된...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/9489/",
        "teaser": null
      },{
        "title": "[백준 1368][💛2] 물대기 (MST, 크루스칼)",
        "excerpt":"🚀 난이도 💛 골드 2 🚀 문제 https://www.acmicpc.net/problem/1368 🚀 내 풀이 ⭕ 풀이 참고 : https://conkjh032.tistory.com/386 우물을 직접 판 논에서 물을 끌어와 쓰는 논들은, 우물을 직접 판 해당 논을 루트로 하는 트리에서 연결된다고 생각할 수 있다. 그러면 트리가 여러개가 될 수 있는 셈인데 어떻게 해야하지..? 라는 고민을 했었다. 고민을 하다가...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/1368/",
        "teaser": null
      },{
        "title": "[백준 20366][💛3] 같이 눈사람 만들래? (조합, 투포인터)",
        "excerpt":"🚀 난이도 💛 골드 3 🚀 문제 https://www.acmicpc.net/problem/20366 🚀 내 풀이 어려웠다.. 결국 다른 분들의 풀이로 공부를 했던 문제였다. 😅 🔥 첫 번째 풀이 (조합) 코드 출처 블로그 https://imnotabear.tistory.com/379 최대 입력 크기가 600 이기 때문에 서로 다른 4 개의 눈 덩이 조합을 뽑는다면 시간 초과가 발생할 것이다.(600 C 4) 우선...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/20366/",
        "teaser": null
      },{
        "title": "[백준 20437][💛5] 문자열 게임 2",
        "excerpt":"🚀 난이도 💛 골드 5 🚀 문제 https://www.acmicpc.net/problem/20437 🚀 내 풀이 푼 지가 꽤 오래되어 가물가물 하지만… 오랜 시간 고민하다가 포기하고 구글링했던 문제로 기억한다..⭐ 내가 크게 간과했던 것은 3 번과 4 번을 별개로 생각했던 것이다. 3 번은 어떤 문자를 정확히 K 개 포함하면서 가장 짧은 연속 문자열의 길이 를 구하는...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/20437/",
        "teaser": null
      },{
        "title": "[백준 9663][💛5] N-Queen (백트래킹)",
        "excerpt":"🚀 난이도 💛 골드 5 🚀 문제 https://www.acmicpc.net/problem/9663 🚀 내 풀이 🔥 첫 번째 풀이 ❌ (시간초과) 프로그래머스의 N-Queen에서 제출했던 풀이와 비슷하지만 이번 백준의 N-Queen 에서는 통과하지 못했다..! 백준이 입력 크기가 더 크다. 프로그래머스는 N = 12, 백준은 N = 15 가 최대이다. 시간복잡도가 O(N!) 에 가깝기 때문에 3 만큼만...","categories": ["BOJ"],
        "tags": ["Algorithm","Coding Test","Cpp"],
        "url": "http://localhost:4000/boj/9663/",
        "teaser": null
      }]
