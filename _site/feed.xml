<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-15T18:53:29+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">기억저장소</title><subtitle>개발공부를 기록하는 공간입니다.</subtitle><author><name>민경</name></author><entry><title type="html">[백준 20366][💛3] 같이 눈사람 만들래? (조합, 투포인터)</title><link href="http://localhost:4000/boj/20366/" rel="alternate" type="text/html" title="[백준 20366][💛3] 같이 눈사람 만들래? (조합, 투포인터)" /><published>2021-07-26T00:00:00+09:00</published><updated>2021-07-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/20366</id><content type="html" xml:base="http://localhost:4000/boj/20366/"><![CDATA[<h2 id="-난이도">🚀 난이도</h2>

<blockquote>
  <p>💛 골드 3</p>
</blockquote>

<p><br /></p>

<h2 id="-문제">🚀 문제</h2>

<blockquote>
  <p><a href="https://www.acmicpc.net/problem/20366">https://www.acmicpc.net/problem/20366</a></p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/42318591/121774357-22522b80-cbbd-11eb-80b5-63953c11b19d.png" alt="image" /></p>

<p><br /></p>

<h2 id="-내-풀이">🚀 내 풀이</h2>

<p>어려웠다.. 결국 다른 분들의 풀이로 공부를 했던 문제였다. 😅</p>

<h3 id="-첫-번째-풀이-조합">🔥 첫 번째 풀이 (조합)</h3>

<blockquote>
  <p>코드 출처 블로그 <a href="https://imnotabear.tistory.com/379">https://imnotabear.tistory.com/379</a></p>
</blockquote>

<p>최대 입력 크기가 600 이기 때문에 서로 다른 4 개의 눈 덩이 조합을 뽑는다면 시간 초과가 발생할 것이다.(<code class="language-plaintext highlighter-rouge">600 C 4</code>) 우선 2 개의 눈덩이끼리의 조합을 구하여 그 눈덩이들을 묶어 나열한다.(이를 <code class="language-plaintext highlighter-rouge">snowman</code> 라고 하겠다.) 눈덩이 2 개로 눈사람 하나를 만드는 것이기 때문에 이 bind 에서 엘사의 눈사람, 안나의 눈사람으로서 2 개를 뽑는다. 즉, 눈덩이 2 개를 뽑아 하나의 원소로서 묶어 나열한 <code class="language-plaintext highlighter-rouge">snowman</code> 에서 또 2 개를 뽑아 눈사람 2 개를 조합으로 뽑는 식이다. 여기까지만 생각해보면 <code class="language-plaintext highlighter-rouge">N C 2 * N C 2</code> 가 되어 엄청나게 큰 입력 크기가 될 것 같지만..</p>

<p>문제에서 구하고자 하는 것은 엘사 눈사람과 안나 눈사람 <strong>“최소 길이 차이”</strong>를 구하는 것이기 때문에 눈덩이 2 개를 조합으로 뽑아 묶아 나열한 <code class="language-plaintext highlighter-rouge">snowman</code> 를 <u>먼저 정렬을 한 후</u>, <u>각 원소마다 자신의 바로 뒤에 있는 것을 선택하여 그것과 키 차이를 구하면 된다.</u> 오름차순으로 정렬을 한 상태인데다가 최소 길이 차이를 구하는 것이기에 자신의 뒤에 있는, 즉 자신 보다 키가 큰 눈사람들 중 전부 다 비교할 필요 없이 그냥 바로 뒤에 있는 눈사람을 선택해주면 되는 것이다. 그게 바로 자신보다 키 큰 눈 사람 중에서 자신과 가장 최소로 차이 나는 눈사람이 되는 것이기 때문이다! (‘자신’을 안나 눈사람, ‘안나 눈사람 보다 큰 눈사람들 중에서 가장 최소로 차이 나는 눈사람’을 엘사 눈사람이라고 하자.)따라서 이때의 시간 복잡도는 <code class="language-plaintext highlighter-rouge">N C 2 * N C 2</code> 이 아닌 대략 <code class="language-plaintext highlighter-rouge">N C 2</code> 가 된다.</p>

<p>다만! 서로 다른 눈덩이를 써야하기 때문에 뽑힌 4 개의 눈덩이는 같은 index 여서는 안된다. 모두 다른 인덱스여야 한다! 두 눈덩이(인덱스)를 뽑아 모아둔 <code class="language-plaintext highlighter-rouge">snowman</code>에서 또 2 개를 뽑는 것이다 보니 뽑은 두 눈사람 중 같은 눈덩이가(즉 인덱스가 동일한) 있을 수 있다.</p>

<p>따라서 <u>정렬된 상태에서 현재 안나의 눈사람으로 설정된 눈사람 중 뒤에 위치한 눈사람들 중에서 넷 다 서로 다른 눈덩이라는 전제가 처음으로 성립하는 눈사람을 엘사 눈사람으로 지정한 후 두 눈사람의 키 차이를 구하면 될 것이다.</u> <code class="language-plaintext highlighter-rouge">N C 2</code> 의 시간 복잡도 동안 차례로 안나의 눈사람으로 설정한 후 두 눈 사람의 키 차이를 구하여 최소값을 업데이트 해 나가면 된다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Elem</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">,</span> <span class="n">sum</span><span class="p">;</span> <span class="p">};</span> <span class="c1">// 이 구조체 하나가 눈사람이나 마찬가지다. index 1,2 로 두 눈덩이 구분(인덱스), sum 은 눈사람 길이가 됨. </span>
<span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="k">const</span> <span class="n">Elem</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Elem</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">sum</span><span class="p">;</span> <span class="c1">// 눈사람 키 별로 정렬</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">freopen</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">N</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span><span class="p">;</span>

	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">snow</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">snow</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="c1">// 1️⃣ 두 눈덩이의 조합, 즉 NC2 개의 조합을 구한다. 이를 snowman 에 저장. 즉, 만들 수 있는 눈사람들 나열!</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">Elem</span><span class="o">&gt;</span> <span class="n">snowman</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
			<span class="n">snowman</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">snow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">snow</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">});</span>
	
	<span class="c1">// 2️⃣ 눈사람들 키 별로 정렬</span>
	<span class="n">sort</span><span class="p">(</span><span class="n">snowman</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">snowman</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cmp</span><span class="p">);</span>

	<span class="c1">// 3️⃣ 정렬된 snowman 을 순회하면서 각 원소를 안나 눈사람으로 설정한 후 그 뒤에 있는 것들 중 (즉, 안나보다 키 큰 눈사람) </span>
	<span class="c1">// 처음으로 서로 다른 4 개의 눈덩이를 사용한 경우가 되는 눈사람을 엘사 눈사람으로 설정한 후 키 차이를 구하고 바~~~로 빠져나오면 된다.  </span>
	<span class="c1">// 이러면 거의 NC2 의 시간복잡도 보장할 것이다.</span>
	<span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">snowman</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Elem</span> <span class="n">anna</span> <span class="o">=</span> <span class="n">snowman</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">snowman</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">Elem</span> <span class="n">elsa</span> <span class="o">=</span> <span class="n">snowman</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">elsa</span><span class="p">.</span><span class="n">index1</span> <span class="o">!=</span> <span class="n">anna</span><span class="p">.</span><span class="n">index1</span> <span class="o">&amp;&amp;</span> <span class="n">elsa</span><span class="p">.</span><span class="n">index1</span> <span class="o">!=</span> <span class="n">anna</span><span class="p">.</span><span class="n">index2</span> <span class="o">&amp;&amp;</span> <span class="n">elsa</span><span class="p">.</span><span class="n">index2</span> <span class="o">!=</span> <span class="n">anna</span><span class="p">.</span><span class="n">index1</span> <span class="o">&amp;&amp;</span> <span class="n">elsa</span><span class="p">.</span><span class="n">index2</span> <span class="o">!=</span> <span class="n">anna</span><span class="p">.</span><span class="n">index2</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">answer</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="n">elsa</span><span class="p">.</span><span class="n">sum</span> <span class="o">-</span> <span class="n">anna</span><span class="p">.</span><span class="n">sum</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="-두-번째-풀이-투포인터">🔥 두 번째 풀이 (투포인터)</h3>

<blockquote>
  <p>코드 출처 블로그 <a href="https://velog.io/@pss407/%EB%B0%B1%EC%A4%8020366-%EA%B0%99%EC%9D%B4-%EB%88%88%EC%82%AC%EB%9E%8C-%EB%A7%8C%EB%93%A4%EB%9E%98">https://velog.io/@pss407/%EB%B0%B1%EC%A4%8020366-%EA%B0%99%EC%9D%B4-%EB%88%88%EC%82%AC%EB%9E%8C-%EB%A7%8C%EB%93%A4%EB%9E%98</a></p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/42318591/126898312-1f6b2d2a-bee9-4605-b511-25f49dcdaf24.png" alt="image" /></p>

<p>안나의 눈사람에 사용될 두 눈덩이를 먼저 고정시켜 놓은 후 (<code class="language-plaintext highlighter-rouge">i</code>와 <code class="language-plaintext highlighter-rouge">j</code>를 사용) <u>이 안나의 눈사람을 기준으로 하여, 안나의 두 눈덩이 사이 내에서 엘사 두 눈덩이를 투포인터 방식으로 결정</u>해나간다. ((<code class="language-plaintext highlighter-rouge">left</code>, <code class="language-plaintext highlighter-rouge">right</code>를 사용) 그렇기 때문에 안나의 눈덩이는 최소 3 칸 이상 차이가 나야한다. 안나의 두 눈덩이를 고정시키는데 대략 N^2 만큼의 시간 복잡도 안에서 엘사의 두 눈덩이를 투포인터로 결정해나가기 때문에 첫번째 풀이보다는 실행 시간이 좀 더 걸릴 것이다. (엘사 안나 둘 중 누구를 투포인터를 적용할지는 중요하지 않다.)</p>

<p>조합을 구하듯 이중 반복문을 돌려 <code class="language-plaintext highlighter-rouge">i</code> 와 <code class="language-plaintext highlighter-rouge">j</code>를 고정하여 안나 눈사람을 정한다.(이 둘은 최소 3 이상 차이가 나야 한다.) 이 <code class="language-plaintext highlighter-rouge">i</code>와 <code class="language-plaintext highlighter-rouge">j</code> 사이의 범위에서 <code class="language-plaintext highlighter-rouge">left</code>, <code class="language-plaintext highlighter-rouge">right</code> 투포인터 알고리즘을 적용하여 엘사 눈사람을 정한다. <code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">j</code>, <code class="language-plaintext highlighter-rouge">left</code>, <code class="language-plaintext highlighter-rouge">right</code> 모두 눈덩이를 가리키는 포인터가 된다.(인덱스)</p>

<p>✨ 투포인터 <code class="language-plaintext highlighter-rouge">left</code>, <code class="language-plaintext highlighter-rouge">right</code> 는 각각 양 끝에서 시작한다. 또한 눈덩이 배열을 오름차순 정렬을 미리 해놓는다.</p>

<ul>
  <li>투포인터 이동 기준 (즉, 고정된 안나의 두 눈덩이를 기준으로 엘사의 눈덩이를 어떻게 변경시켜나갈 것인가)
    <ul>
      <li>현재의 <code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">j</code>, <code class="language-plaintext highlighter-rouge">left</code>, <code class="language-plaintext highlighter-rouge">right</code> 로 두 눈사람이 모두 결정되었다면 키 차이를 구한다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">(snow[left] + snow[right]) - (snow[i] + snow[j])</code></li>
        </ul>
      </li>
      <li>엘사 눈사람이 안나 눈사람보다 키가 크다면 (즉, 위 식의 결과가 양수)
        <ul>
          <li>최소 차이에 도달하기 위해선 앞으로 엘사의 키가 더 작아져야 한다. 따라서 <code class="language-plaintext highlighter-rouge">right</code> 왼쪽으로 한칸 이동! (정렬 되어있으니 가능)</li>
        </ul>
      </li>
      <li>엘사 눈사람이 안나 눈사람보다 키가 작다면 (즉, 위 식의 결과가 음수)
        <ul>
          <li>최소 차이에 도달하기 위해선 앞으로 엘사의 키가 더 커져야 한다. 따라서 <code class="language-plaintext highlighter-rouge">left</code> 오른쪽으로 한칸 이동! (정렬 되어있으니 가능)</li>
        </ul>
      </li>
      <li>“차이” 는 절대값이어야 하는 개념이기 때문.</li>
    </ul>
  </li>
</ul>

<p>무작정 4 개의 눈덩이를 뽑아보는게 아닌, 안나의 두 눈덩이만 뽑아둔 후 그 기준으로 엘사의 눈덩이는 투포인터로 O(N) 으로 결정하는 방식 ! 엘사의 모든 눈덩이 경우의 수를 다 구하지 않는다. 전체적으론 대략 N^3 의 시간 복잡도가 소요될 듯 하다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Elem</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">,</span> <span class="n">sum</span><span class="p">;</span> <span class="p">};</span>
<span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="k">const</span> <span class="n">Elem</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Elem</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//freopen("input.txt", "r", stdin);</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">N</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span><span class="p">;</span>

	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">snow</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">snow</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="n">sort</span><span class="p">(</span><span class="n">snow</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">snow</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// 눈덩이 크기 순으로 정렬 </span>

	<span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// i ~ j 범위의 양끝에서 시작</span>
			<span class="c1">// left 와 right 는 엘사의 눈덩이</span>
			<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">anna</span> <span class="o">=</span> <span class="n">snow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">snow</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="c1">// 안나 눈사람</span>
                <span class="kt">int</span> <span class="n">elsa</span> <span class="o">=</span> <span class="n">snow</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">snow</span><span class="p">[</span><span class="n">right</span><span class="p">];</span> <span class="c1">// 엘사 눈사람</span>
				<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">elsa</span> <span class="o">-</span> <span class="n">anna</span><span class="p">;</span>
				
				<span class="n">answer</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="n">abs</span><span class="p">(</span><span class="n">result</span><span class="p">));</span> 
				
				<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1">// 현재 엘사가 더 크다면 최소 키 차이를 구하기 위해선 앞으로 엘사가 더 작아져야 한다.</span>
					<span class="n">right</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">else</span>  <span class="c1">// 현재 엘사가 더 작다면 최소 키 차이를 구하기 위해선 앞으로 엘사가 더 커져야 한다.</span>
					<span class="n">left</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>민경</name></author><category term="BOJ" /><category term="Algorithm" /><category term="Coding Test" /><category term="Cpp" /><summary type="html"><![CDATA[🚀 난이도]]></summary></entry><entry><title type="html">[백준 1368][💛2] 물대기 (MST, 크루스칼)</title><link href="http://localhost:4000/boj/1368/" rel="alternate" type="text/html" title="[백준 1368][💛2] 물대기 (MST, 크루스칼)" /><published>2021-07-26T00:00:00+09:00</published><updated>2021-07-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/1368</id><content type="html" xml:base="http://localhost:4000/boj/1368/"><![CDATA[<h2 id="-난이도">🚀 난이도</h2>

<blockquote>
  <p>💛 골드 2</p>
</blockquote>

<p><br /></p>

<h2 id="-문제">🚀 문제</h2>

<blockquote>
  <p><a href="https://www.acmicpc.net/problem/1368">https://www.acmicpc.net/problem/1368</a></p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/42318591/125742101-0f4fd81e-b554-4bc7-a9b8-f4399df23cec.png" alt="image" /></p>

<p><br /></p>

<h2 id="-내-풀이-">🚀 내 풀이 ⭕</h2>

<blockquote>
  <p>풀이 참고 : <a href="https://conkjh032.tistory.com/386">https://conkjh032.tistory.com/386</a></p>
</blockquote>

<p>우물을 직접 판 논에서 물을 끌어와 쓰는 논들은, 우물을 직접 판 해당 논을 루트로 하는 트리에서 연결된다고 생각할 수 있다. 그러면 트리가 여러개가 될 수 있는 셈인데 어떻게 해야하지..? 라는 고민을 했었다.</p>

<p>고민을 하다가 구글링을 하여 다른 분의 풀이를 보았는데 생각보다 심플한 풀이였다. <u>가상의 노드를 하나 더 만든 후 이를 루트로 하고 우물을 직접 파는 비용도 추가하는 것이다. 이렇게 생각하면 우물을 직접 파는 비용도, 연결하는 비용도 하나의 그래프로 연결할 수 있다.</u> 위 링크 블로그에서 그림을 보면 쉽게 이해가 될 것이다.</p>

<p>가상의 노드를 루트로 두고, 우물을 직접 파는 비용으로 논들과 이 루트를 연결하는 것으로 그래프를 시작한다면 하나의 그래프로 통합시킬 수 있는 셈이다.</p>

<p>이렇게 하나의 그래프로 만든 후 평범하게! MST 최소신장트리 알고리즘 적용하여 풀이하면 된다. 나는 크루스칼 알고리즘을 사용했다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Edge</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">cost</span><span class="p">;</span> <span class="p">};</span>
<span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">cost</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">cost</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="mi">301</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">get_root</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_root</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">union_graph</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">par_a</span> <span class="o">=</span> <span class="n">get_root</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">par_b</span> <span class="o">=</span> <span class="n">get_root</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">par_a</span> <span class="o">&lt;</span> <span class="n">par_b</span><span class="p">)</span> <span class="n">parent</span><span class="p">[</span><span class="n">par_b</span><span class="p">]</span> <span class="o">=</span> <span class="n">par_a</span><span class="p">;</span>
	<span class="k">else</span> <span class="n">parent</span><span class="p">[</span><span class="n">par_a</span><span class="p">]</span> <span class="o">=</span> <span class="n">par_b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">is_same_graph</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">par_a</span> <span class="o">=</span> <span class="n">get_root</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">par_b</span> <span class="o">=</span> <span class="n">get_root</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">par_a</span> <span class="o">==</span> <span class="n">par_b</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">freopen</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">N</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span><span class="p">;</span>
	
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">edges</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cost</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">cost</span><span class="p">;</span>
		<span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cost</span> <span class="p">});</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">cost</span><span class="p">;</span>
			<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">cost</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">)</span> 
				<span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">cost</span> <span class="p">});</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cmp</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">total_cost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_same_graph</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">union_graph</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">b</span><span class="p">);</span>
			<span class="n">total_cost</span> <span class="o">+=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cost</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">total_cost</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>처음엔 아래와 같이 풀이를 해서 틀렸었다. 자기 자신과 연결되는 비용은 항상 0 이기 때문에 이를 피하기 위해서 저렇게 짰었던건데 이렇게 짜면 입력받는 처리가 되지 못해 뒤로 밀려서 틀린 풀이가 되버렸다. 0 도 cin 을 통해 입력 받은 후에 continue 시켰어야 했다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
			
			<span class="kt">int</span> <span class="n">cost</span><span class="p">;</span>
			<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">cost</span><span class="p">;</span>
			<span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">cost</span> <span class="p">});</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></div></div>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>민경</name></author><category term="BOJ" /><category term="Algorithm" /><category term="Coding Test" /><category term="Cpp" /><summary type="html"><![CDATA[🚀 난이도]]></summary></entry><entry><title type="html">[백준 20437][💛5] 문자열 게임 2</title><link href="http://localhost:4000/boj/20437/" rel="alternate" type="text/html" title="[백준 20437][💛5] 문자열 게임 2" /><published>2021-07-26T00:00:00+09:00</published><updated>2021-07-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/20437</id><content type="html" xml:base="http://localhost:4000/boj/20437/"><![CDATA[<h2 id="-난이도">🚀 난이도</h2>

<blockquote>
  <p>💛 골드 5</p>
</blockquote>

<p><br /></p>

<h2 id="-문제">🚀 문제</h2>

<blockquote>
  <p><a href="https://www.acmicpc.net/problem/20437">https://www.acmicpc.net/problem/20437</a></p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/42318591/121775299-b7572380-cbc1-11eb-90a4-a9619466c5ca.png" alt="image" /></p>

<p><br /></p>

<h2 id="-내-풀이">🚀 내 풀이</h2>

<p>푼 지가 꽤 오래되어 가물가물 하지만… 오랜 시간 고민하다가 포기하고 구글링했던 문제로 기억한다..⭐ 내가 크게 간과했던 것은 3 번과 4 번을 별개로 생각했던 것이다. 3 번은 어떤 문자를 정확히 K 개 포함하면서 <strong>가장 짧은 연속 문자열의 길이</strong> 를 구하는 것이기 때문에 4 번처럼 문자열의 첫 번째와 마지막 글자가 같아야할 수 밖에 없다 ! ! !</p>

<p>그렇기 때문에 3, 4 번 이 둘을 별개로 생각하지 않고, <u>어떤 문자를 정확히 K 개 포함하고 문자열의 첫 번째와 마지막 글자가 해당 문자로 같은 문자열들</u>을 구하고 최소 길이와 최대 길이를 구하면 된다.</p>

<h3 id="-첫-번째-풀이">🔥 첫 번째 풀이</h3>

<blockquote>
  <p>코드 출처 블로그 <a href="https://taxol1203.github.io/codingtest/bj-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%8C%EC%9E%842/">https://taxol1203.github.io/codingtest/bj-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%8C%EC%9E%842/</a></p>
</blockquote>

<p>위 링크의 풀이를 참고하였다.</p>

<ul>
  <li>1️⃣ str 의 알파벳 문자별로 등장 빈도수를 저장한다.</li>
  <li>2️⃣ <code class="language-plaintext highlighter-rouge">K</code> 와 같거나 <code class="language-plaintext highlighter-rouge">K</code> 보다 큰 빈도수를 가진 문자들만을 대상으로(이때 이 문자가 부분 문자열의 시작 문자가 됨), 해당 문자를 만날 때마다, 즉 동일한 문자를 만날 때마다 카운트 하고(이 과정에서 자동으로 시작 문자와 끝 문자가 같게 됨) 그 카운트 수가 <code class="language-plaintext highlighter-rouge">K</code> 가 되었을 때 최소 길이, 최대 길이를 업데이트 하면 된다.
    <ul>
      <li>나는 처음에 <em>count[str[i] - ‘a’] == K</em> 에 해당하는 문자만 해야하지 않을까? 왜지? 하고 생각했었다. 근데 아니다 !!!!! <code class="language-plaintext highlighter-rouge">K</code> 개 미만으로 적은 문자들에 대해서는 조건에 만족하는 부분 문자열을 구할 수 조차 없기에 넘어가야 하는게 맞지만, <code class="language-plaintext highlighter-rouge">K</code> 개 이상인 문자들에 대해서는 충분히 그 안에서도 <code class="language-plaintext highlighter-rouge">K</code> 개의 부분 문자열을 만들 수 있기 때문이다. 예를 들어 abcafa 라는 문자열이 있고 <code class="language-plaintext highlighter-rouge">K</code> 가 2 라고 가정해보자면, a 는 3 번 등장하므로 <code class="language-plaintext highlighter-rouge">K</code> 와 일치하지는 않지만 abca 혹은 afa 혹은 abcafa 이런 <code class="language-plaintext highlighter-rouge">K = 2</code> 개가 속한 문자열을 만들 수 있는 것이다. 내가 착각했었던 부분이다. 따라서 <em>count[str[i] - ‘a’] &gt;= K</em> 조건에 만족하는 문자들에 대해서만 진행해야 하는 것이 맞다.</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//freopen("input.txt", "r", stdin);</span>
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">T</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">T</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">T</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">str</span><span class="p">;</span> 
        <span class="kt">int</span> <span class="n">K</span><span class="p">;</span> 
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">K</span><span class="p">;</span>
        
        <span class="c1">// str 의 알파벳 문자별로 등장 빈도수 저장</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">count</span><span class="p">(</span><span class="mi">26</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="o">++</span><span class="n">count</span><span class="p">[</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">];</span> <span class="c1">// ex) count[0] = 3 은 'a' 가 str 에 3 번 등장했다는 뜻</span>
        
        <span class="kt">int</span> <span class="n">answer3</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span> 
        <span class="kt">int</span> <span class="n">answer4</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ⭐ 빈도수가 K 개 미만인 문자들은 문자열도 못 만들므로 패스</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>

            <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 연속 문자열의 시작 문자 str[i]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>  <span class="c1">// str[j] 와 같다면 카운팅! (자동으로 시작문자 = 끝문자 인 연속 문자열이 되는 것이나 마찬가지)</span>
                    <span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 카운트 수가 K 와 같을 때 길이 업데이트</span>
                    <span class="n">answer3</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">answer3</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                    <span class="n">answer4</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">answer4</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">answer3</span> <span class="o">==</span> <span class="n">INT_MAX</span> <span class="o">||</span> <span class="n">answer4</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">else</span> 
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">answer3</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">answer4</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="-두-번째-풀이-투포인터">🔥 두 번째 풀이 (투포인터)</h3>

<blockquote>
  <p>코드 출처 블로그 <a href="https://blog.naver.com/PostView.nhn?blogId=gustn3964&amp;logNo=222291615095&amp;categoryNo=0&amp;parentCategoryNo=0&amp;viewDate=&amp;currentPage=1&amp;postListTopCurrentPage=1&amp;from=postView">https://blog.naver.com/PostView.nhn?blogId=gustn3964&amp;logNo=222291615095&amp;categoryNo=0&amp;parentCategoryNo=0&amp;viewDate=&amp;currentPage=1&amp;postListTopCurrentPage=1&amp;from=postView</a></p>
</blockquote>

<p>아이디어가 좋은 풀이라고 느꼈다!</p>

<ul>
  <li>1️⃣ 이차원 배열을 선언하여 문자(인덱스)별로 그 문자가 등장하는 위치 인덱스들을 저장한다.</li>
  <li>2️⃣ 어차피 어떠한 문자로 시작하고 끝이나는 문자열을 구해야하는 것이기 때문에 문자 별 위치 인덱스들에서 두 포인터가 가리키는 인덱스의 사이에 <code class="language-plaintext highlighter-rouge">K</code> 개 만큼의 고정적인 문자 수를 유지한 채로 두 포인터를 한 칸씩 옮겨나가면 된다.
    <ul>
      <li>예를 들어 a 문자가 5, 8, 13, 15 위치에 있고 (즉, <code class="language-plaintext highlighter-rouge">alpha_pos[0]</code> 는 <code class="language-plaintext highlighter-rouge">{5, 8, 13, 15}</code>) <code class="language-plaintext highlighter-rouge">K</code> 가 3 이라면 투포인터는 차례로 (5, 13) -&gt; (8, 15) 이 순서로 각각 가리키게 된다. 5 와 13 위치엔 같은 문자가 있으며 5 와 13 사이엔 5, 8, 13 이렇게 <code class="language-plaintext highlighter-rouge">K = 3</code> 개의 동일한 문자가 있게 된다. 마찬가지로 8, 15 위치엔 같은 문자가 있으며 8 과 15 사이엔 8, 13, 15 이렇게 <code class="language-plaintext highlighter-rouge">K = 3</code> 개의 동일한 문자가 있게 된다.</li>
      <li><code class="language-plaintext highlighter-rouge">alpha_pos[문자]</code> 해당 문자의 위치들이 기록된 배열(전부 동일한 문자를 가리키는 위치들)에서 사이에 <code class="language-plaintext highlighter-rouge">K</code> 개의 문자가 포함되도록 거리를 유치한 채 두 포인터를 모두 1 씩 증가하면 됨</li>
      <li>따라서 왼쪽 포인터는 <code class="language-plaintext highlighter-rouge">alpha_pos[문자][0]</code> 을 가리키는 것 에서, 오른쪽 포인터는 <code class="language-plaintext highlighter-rouge">alpha_pos[문자][K - 1]</code> 을 가리키는 것에서 출발한다. (초기값)</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//freopen("input.txt", "r", stdin);</span>
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">T</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">T</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">str</span><span class="p">;</span> 
        <span class="kt">int</span> <span class="n">K</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">K</span><span class="p">;</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">alpha_pos</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">answer3</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span> <span class="kt">int</span> <span class="n">answer4</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
         
         <span class="c1">// 문자(인덱스)별로 그 문자가 등장하는 위치 인덱스들을 저장</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> 
            <span class="n">alpha_pos</span><span class="p">[</span><span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">alpha_pos</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
                <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

                <span class="kt">int</span> <span class="n">temp3</span> <span class="o">=</span> <span class="n">alpha_pos</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="n">alpha_pos</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> 
                <span class="kt">int</span> <span class="n">temp4</span> <span class="o">=</span> <span class="n">alpha_pos</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="n">alpha_pos</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">alpha_pos</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">r</span><span class="o">++</span><span class="p">;</span> 
                    <span class="n">l</span><span class="o">++</span><span class="p">;</span>
                    <span class="n">temp3</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">alpha_pos</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="n">alpha_pos</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">temp3</span><span class="p">);</span>
                    <span class="n">temp4</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">alpha_pos</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="n">alpha_pos</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">l</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">temp4</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">answer3</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">temp3</span><span class="p">,</span> <span class="n">answer3</span><span class="p">);</span>
                <span class="n">answer4</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">temp4</span><span class="p">,</span> <span class="n">answer4</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">answer3</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span> 
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">else</span> 
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">answer3</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">answer4</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>민경</name></author><category term="BOJ" /><category term="Algorithm" /><category term="Coding Test" /><category term="Cpp" /><summary type="html"><![CDATA[🚀 난이도]]></summary></entry><entry><title type="html">[백준 9663][💛5] N-Queen (백트래킹)</title><link href="http://localhost:4000/boj/9663/" rel="alternate" type="text/html" title="[백준 9663][💛5] N-Queen (백트래킹)" /><published>2021-07-26T00:00:00+09:00</published><updated>2021-07-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/9663</id><content type="html" xml:base="http://localhost:4000/boj/9663/"><![CDATA[<h2 id="-난이도">🚀 난이도</h2>

<blockquote>
  <p>💛 골드 5</p>
</blockquote>

<p><br /></p>

<h2 id="-문제">🚀 문제</h2>

<blockquote>
  <p><a href="https://www.acmicpc.net/problem/9663">https://www.acmicpc.net/problem/9663</a></p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/42318591/125166539-0f8c4000-e1d7-11eb-9f0f-5b7e458bab72.png" alt="image" /></p>

<p><br /></p>

<h2 id="-내-풀이">🚀 내 풀이</h2>

<h3 id="-첫-번째-풀이--시간초과">🔥 첫 번째 풀이 ❌ (시간초과)</h3>

<p><a href="https://ansohxxn.github.io/programmers/107/">프로그래머스의 N-Queen</a>에서 제출했던 풀이와 비슷하지만 이번 백준의 N-Queen 에서는 통과하지 못했다..! 백준이 입력 크기가 더 크다. 프로그래머스는 <code class="language-plaintext highlighter-rouge">N = 12</code>, 백준은 <code class="language-plaintext highlighter-rouge">N = 15</code> 가 최대이다. 시간복잡도가 <code class="language-plaintext highlighter-rouge">O(N!)</code> 에 가깝기 때문에 3 만큼만 차이나지만 전체적인 시간복잡도 차이는 어마어마한 것이다..ㅠ ㅠ <code class="language-plaintext highlighter-rouge">N = 15</code> 에서는 통과하기 힘든 풀이였던 것 같다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">answer</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">board</span><span class="p">[</span><span class="mi">15</span><span class="p">][</span><span class="mi">15</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">answer</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">col</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">bool</span> <span class="n">cond1</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">col</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">cond1</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="kt">bool</span> <span class="n">cond2</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">,</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">cond2</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="kt">bool</span> <span class="n">cond3</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">cond3</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cond1</span> <span class="o">&amp;&amp;</span> <span class="n">cond2</span> <span class="o">&amp;&amp;</span> <span class="n">cond3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//freopen("input.txt", "r", stdin);</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span><span class="p">;</span>
	
	<span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="-두-번째-풀이-">🔥 두 번째 풀이 ⭕</h3>

<p>구글링 해보니 대부분 이 풀이로 제출하면 시간 초과 없이 통과하셨더 것 같다! 그런데 사실.. 첫 번째 풀이는 왜 시간초과가 나고 이 풀이는 왜 시간초과가 나지 않는지 잘 모르겠다..! 😥 두 풀이의 dfs 연산 횟수는 동일한데.. 첫 번째 풀이는 안에 있는 for문을 1 개 썼다는 정도이고 두 번째 풀이는 안쪽 for 문을 3 개 썼다는 정도의 차이인데 이 차이로 시간 초과가 발생한 것일까? 잘 모르겠다.. 알려주시면 너무 감사할 것 같아요 흑흑…</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">answer</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">queen</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span> <span class="c1">// 인덱스는 row 가 된다. row 별 어느 col 에 두었는지 그 col 값을 기록.</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">answer</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">col</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queen</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span><span class="p">;</span> 
		
		<span class="kt">bool</span> <span class="n">promising</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">queen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">queen</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">||</span> <span class="n">abs</span><span class="p">(</span><span class="n">queen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">queen</span><span class="p">[</span><span class="n">row</span><span class="p">])</span> <span class="o">==</span> <span class="n">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">row</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">promising</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">promising</span><span class="p">)</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//freopen("input.txt", "r", stdin);</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span><span class="p">;</span>
	
	<span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>민경</name></author><category term="BOJ" /><category term="Algorithm" /><category term="Coding Test" /><category term="Cpp" /><summary type="html"><![CDATA[🚀 난이도]]></summary></entry><entry><title type="html">[백준 9489][💛4] 사촌</title><link href="http://localhost:4000/boj/9489/" rel="alternate" type="text/html" title="[백준 9489][💛4] 사촌" /><published>2021-07-25T00:00:00+09:00</published><updated>2021-07-25T00:00:00+09:00</updated><id>http://localhost:4000/boj/9489</id><content type="html" xml:base="http://localhost:4000/boj/9489/"><![CDATA[<h2 id="-난이도">🚀 난이도</h2>

<blockquote>
  <p>💛 골드 4</p>
</blockquote>

<p><br /></p>

<h2 id="-문제">🚀 문제</h2>

<blockquote>
  <p><a href="https://www.acmicpc.net/problem/9489">https://www.acmicpc.net/problem/9489</a></p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/42318591/123412517-a0b2c280-d5ec-11eb-9024-4e64e137c011.png" alt="image" /></p>

<p><br /></p>

<h2 id="-내-풀이-">🚀 내 풀이 ⭕</h2>

<p>사촌 사이는 조부모가 같고 부모는 다른 사이이다. (부모끼리는 형제) 나는 그냥.. 정말 직관적이고 단순하게 풀었다!</p>

<p>1️⃣ 우선 <code class="language-plaintext highlighter-rouge">arr[i]</code> 모든 노드마다 자신의 부모와 자신의 자식들을 각각 2 가지 <code class="language-plaintext highlighter-rouge">map</code> 에 저장하였다.(<code class="language-plaintext highlighter-rouge">arr[i]</code> 의 부모를 알 수 있도록 반복자를 두었고 연속된 수가 끊기면 반복자를 다음 노드로 옮겨주는 식으로 현재 부모를 가리키도록 했다.)</p>

<p>2️⃣ 위에서 구한 두 <code class="language-plaintext highlighter-rouge">map</code> 을 사용하여 <code class="language-plaintext highlighter-rouge">K</code> 노드의 사촌의 수를 누적합 한다. <code class="language-plaintext highlighter-rouge">K</code> 의 할아버지의 자식들 (<code class="language-plaintext highlighter-rouge">K</code>의 삼촌들 + 부모) 에서 부모는 제외하고 삼촌들의 자식 수를 세면 된다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//freopen("input.txt", "r", stdin);</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 반복 1번 당 테스트케이스 1개 </span>
		<span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">K</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span> <span class="o">&gt;&gt;</span> <span class="n">K</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">N</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">K</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 0 0 입력시 입력 종료</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span> <span class="c1">// key : 노드 번호   value : key 노드의 부모 노드 번호</span>
		<span class="n">parent</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// arr[0] 는 루트 노드이다. 루트는 부모가 없기에 부모를 0 으로 지정</span>
		<span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">children</span><span class="p">;</span> <span class="c1">// key : 노드 번호   value : key 노드의 자식 노드'들'</span>
		<span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">parent_ptr</span><span class="p">;</span>  <span class="c1">// parent 맵 처음부터 순회할 반복자 (조상 노드부터 BFS 방식으로 순회하는 느낌일듯..!)</span>

        <span class="c1">// 1️⃣ 노드마다 자신의 부모와 자식들 map 에 전부 저장! </span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 다음 노드로 포인터 옮기기 (연속된 집합에 속하는 노드들은 같은 부모의 자식이다. 이 집합이 끝났으니 이제 다음 노드들은 다음 노드의 자식들이라는 것이기 때문에 포인터 옮김)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">parent_ptr</span> <span class="o">=</span> <span class="n">parent</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
				<span class="k">else</span> <span class="o">++</span><span class="n">parent_ptr</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">parent</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">parent_ptr</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
			<span class="n">children</span><span class="p">[</span><span class="n">parent_ptr</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
        
		<span class="c1">// 2️⃣ 사촌 가려내기 작업</span>
        <span class="c1">// 루트노드와 루트노드의 직속 자식들은 사촌이 없다.</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">K</span><span class="p">]</span> <span class="o">==</span> <span class="n">K</span> <span class="o">||</span> <span class="n">parent</span><span class="p">[</span><span class="n">K</span><span class="p">]</span> <span class="o">==</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
		<span class="c1">// 그외</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">grandParent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">parent</span><span class="p">[</span><span class="n">K</span><span class="p">]];</span> <span class="c1">// K 노드의 할아버지</span>
			<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">uncles</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">grandParent</span><span class="p">];</span> <span class="c1">// K 노드의 할아버지의 자식들 (= K의 부모 + K의 삼촌들)</span>
			<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">uncles</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">uncles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">[</span><span class="n">K</span><span class="p">])</span> <span class="c1">// K 의 삼촌들의 자식들만 세면 된다.</span>
					<span class="n">count</span> <span class="o">+=</span> <span class="n">children</span><span class="p">[</span><span class="n">uncles</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">size</span><span class="p">();</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>민경</name></author><category term="BOJ" /><category term="Algorithm" /><category term="Coding Test" /><category term="Cpp" /><summary type="html"><![CDATA[🚀 난이도]]></summary></entry><entry><title type="html">[백준 4358][💛5] 생태학 (map, 소수 출력)</title><link href="http://localhost:4000/boj/4358/" rel="alternate" type="text/html" title="[백준 4358][💛5] 생태학 (map, 소수 출력)" /><published>2021-07-24T00:00:00+09:00</published><updated>2021-07-24T00:00:00+09:00</updated><id>http://localhost:4000/boj/4358</id><content type="html" xml:base="http://localhost:4000/boj/4358/"><![CDATA[<h2 id="-난이도">🚀 난이도</h2>

<blockquote>
  <p>💛 골드 5</p>
</blockquote>

<p><br /></p>

<h2 id="-문제">🚀 문제</h2>

<blockquote>
  <p><a href="https://www.acmicpc.net/problem/4358">https://www.acmicpc.net/problem/4358</a></p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/42318591/125741732-e2c7b843-6080-408d-a7c3-1c097fb533a7.png" alt="image" /></p>

<p><br /></p>

<h2 id="-내-풀이-">🚀 내 풀이 ⭕</h2>

<ul>
  <li>주의해야할 점
    <ul>
      <li>공백을 포함하여 문자열 입력 받기. key 는 공백이 포함된 문자열. 👉 <code class="language-plaintext highlighter-rouge">getline</code></li>
      <li>소수점 넷째자리</li>
    </ul>
  </li>
  <li>map 은 추가할 때 자동 정렬이 되므로 (이진 탐색 트리라서) 이 map 을 그냥 반복자를 이용해 출력하면 끝!</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//freopen("input.txt", "r", stdin);</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">trees</span><span class="p">;</span>
	<span class="n">string</span> <span class="n">tree_name</span><span class="p">;</span>
	<span class="kt">double</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">tree_name</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 입력이 더 이상 없을 때까지 반복!</span>
		<span class="n">trees</span><span class="p">[</span><span class="n">tree_name</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">size</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fixed</span> <span class="o">&lt;&lt;</span> <span class="n">setprecision</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 소수점 넷째자리</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">tree</span> <span class="o">:</span> <span class="n">trees</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tree</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="n">second</span> <span class="o">/</span> <span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>민경</name></author><category term="BOJ" /><category term="Algorithm" /><category term="Coding Test" /><category term="Cpp" /><summary type="html"><![CDATA[🚀 난이도]]></summary></entry><entry><title type="html">[백준 1987][💛4] 알파벳 (DFS, 백트래킹)</title><link href="http://localhost:4000/boj/1987/" rel="alternate" type="text/html" title="[백준 1987][💛4] 알파벳 (DFS, 백트래킹)" /><published>2021-07-11T00:00:00+09:00</published><updated>2021-07-11T00:00:00+09:00</updated><id>http://localhost:4000/boj/1987</id><content type="html" xml:base="http://localhost:4000/boj/1987/"><![CDATA[<h2 id="-난이도">🚀 난이도</h2>

<blockquote>
  <p>💛 골드 4</p>
</blockquote>

<p><br /></p>

<h2 id="-문제">🚀 문제</h2>

<blockquote>
  <p><a href="https://www.acmicpc.net/problem/1987">https://www.acmicpc.net/problem/1987</a></p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/42318591/125166518-fdaa9d00-e1d6-11eb-9f2d-0f0205dd0db0.png" alt="image" /></p>

<p><br /></p>

<h2 id="-내-풀이-">🚀 내 풀이 ⭕</h2>

<p>뭔가 생김새는 BFS 문제 같았지만.. 문제를 읽어보니 <u>백트래킹</u>으로 풀어야 하는 문제였다. 왜냐하면 현재까지 선택해 온 경로에서 한번 방문 했었던 종류의 알파벳은 사용할 수 가 없기 때문이다. 즉, 현재까지 “선택해 온 알파벳”들의 정보가 필요하다. N-Queen 문제와 유사하다. BFS 는 너비 우선 탐색을 하기 때문에 이렇게 “선택해 온 경로”의 정보를 담기는 힘들다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">R</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">answer</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">dc</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">,</span> <span class="mi">1</span> <span class="p">};</span>
<span class="kt">char</span> <span class="n">board</span><span class="p">[</span><span class="mi">20</span><span class="p">][</span><span class="mi">20</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span> <span class="c1">// 알파벳 별 방문 체크 (현재의 경로 기준이므로 성공이든 실패든 재귀 함수가 호출을 끝내고 돌아오면 다시 false 로 바꿔 방문 체크를 해제해준다.)</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dist</span><span class="p">)</span> <span class="p">{</span>
	
	<span class="kt">bool</span> <span class="n">canGo</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nextR</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">dr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">nextC</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">dc</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nextR</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nextR</span> <span class="o">&gt;=</span> <span class="n">R</span> <span class="o">||</span> <span class="n">nextC</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nextC</span> <span class="o">&gt;=</span> <span class="n">C</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 갈 수 없는 곳 1 (보드 범위를 넘어섬)</span>
		<span class="kt">char</span> <span class="n">nextAlpha</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">nextR</span><span class="p">][</span><span class="n">nextC</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">nextAlpha</span> <span class="o">-</span> <span class="sc">'A'</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 갈 수 없는 곳 2 (현재의 경로 내에서 이전에 방문했었던 알파벳)</span>

		<span class="n">canGo</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 갈 수 있는 곳 하나라도 발견했다면 true</span>
		<span class="n">visited</span><span class="p">[</span><span class="n">nextAlpha</span> <span class="o">-</span> <span class="sc">'A'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">dfs</span><span class="p">(</span><span class="n">nextR</span><span class="p">,</span> <span class="n">nextC</span><span class="p">,</span> <span class="n">dist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">visited</span><span class="p">[</span><span class="n">nextAlpha</span> <span class="o">-</span> <span class="sc">'A'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// ⭐ 또 다른 경로에서 해당 알파벳이 다시 선택될 수 있도록</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">canGo</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 더 이상 갈 수 있는 곳이 없다면! (즉, for문에서 재귀 한번도 못 돌림. 더 이상 나아갈 경로가 없음)</span>
		<span class="n">answer</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//freopen("input.txt", "r", stdin);</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">R</span> <span class="o">&gt;&gt;</span> <span class="n">C</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">C</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
			<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>

	<span class="kt">char</span> <span class="n">nextAlpha</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">visited</span><span class="p">[</span><span class="n">nextAlpha</span> <span class="o">-</span> <span class="sc">'A'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 출발 지점 체크</span>
	<span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 문제에서 시작점도 카운팅에 포함된다고 했으므로 1 에서 시작</span>
	
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>민경</name></author><category term="BOJ" /><category term="Algorithm" /><category term="Coding Test" /><category term="Cpp" /><summary type="html"><![CDATA[🚀 난이도]]></summary></entry><entry><title type="html">[백준 20924][💛4] 트리의 기둥과 가지 (DFS, 트리)</title><link href="http://localhost:4000/boj/20924/" rel="alternate" type="text/html" title="[백준 20924][💛4] 트리의 기둥과 가지 (DFS, 트리)" /><published>2021-07-10T00:00:00+09:00</published><updated>2021-07-10T00:00:00+09:00</updated><id>http://localhost:4000/boj/20924</id><content type="html" xml:base="http://localhost:4000/boj/20924/"><![CDATA[<h2 id="-난이도">🚀 난이도</h2>

<blockquote>
  <p>💛 골드 4</p>
</blockquote>

<p><br /></p>

<h2 id="-문제">🚀 문제</h2>

<blockquote>
  <p><a href="https://www.acmicpc.net/problem/20924">https://www.acmicpc.net/problem/20924</a></p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/42318591/125154530-58230980-e195-11eb-975f-a8a7b6e37c10.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/42318591/125154577-915b7980-e195-11eb-9f15-bc39f433f4ce.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/42318591/125154588-a0422c00-e195-11eb-980c-d5ff60d672a3.png" alt="image" /></p>

<p><br /></p>

<h2 id="-내-풀이">🚀 내 풀이</h2>

<p>기둥의 길이 / 가지의 최대 길이 이렇게 따로 구해야하기 때문에 <u>기둥 길이를 구하는 재귀</u>, <u>가지 길이를 구하는 재귀</u> 이렇게 구분 하여 DFS 돌리면 편할 것 같다.</p>

<ul>
  <li>1️⃣ 입력시 인접리스트를 만든다. (무방향인 것 고려하기!)</li>
  <li>2️⃣ 기둥 길이를 구하는 DFS 수행
    <ul>
      <li>종료 조건
        <ul>
          <li>“기가 노드”가 등장했을 때 👉 기둥의 끝이자 가지의 시작인 노드.</li>
          <li>더 이상 자식이 없을때, 즉 리프 노드에 도달했을 때 👉 기둥에서 리프노드를 만났다는 것은 가지가 없다는 의미이다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>3️⃣ 가지 길이를 구하는 DFS 수행
    <ul>
      <li>DFS 를 통해 모든 가지를 검사하면서 최대 길이를 업데이트 하면 된다.</li>
      <li>종료 조건
        <ul>
          <li>리프 노드에 도달했을 때</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<p>나는 3 가지 풀이를 제출했는데 사실 로직은 동일하다.</p>

<ul>
  <li>🔥 첫 번째 풀이
    <ul>
      <li>3 가지 재귀 함수 사용 : <em>make_tree, find_pole, find_max_branch</em></li>
      <li>입력에서 저장한 인접리스트는 <code class="language-plaintext highlighter-rouge">[노드] = { 자식, 부모, 자식 }</code> 이런식이다. 즉, 말그대로 인접했다는 정보만 담고 있을 뿐, 부모와 자식 구분은 되어 있지 않은 것이다. 따라서 <em>make_tree</em> 함수를 통해 루트부터 시작하여 타고 내려가 <code class="language-plaintext highlighter-rouge">[부모노드] = { 자식, 자식 }</code> 이렇게 확실히 <u>자식 노드 정보만 담을 수 있도록 새로운 인접 리스트</u> <code class="language-plaintext highlighter-rouge">tree</code> 를 만들어주었고 이걸 <em>find_pole, find_max_branch</em> 에 사용 하였다.</li>
    </ul>
  </li>
  <li>🔥 두 번째 풀이
    <ul>
      <li>2 가지 재귀 함수 사용 : <em>find_pole, find_max_branch</em></li>
      <li><code class="language-plaintext highlighter-rouge">[노드] = { 자식, 부모, 자식 }</code> 에서 자식만 취하는 방법은, 부모노드는 이미 방문하고 내려왔을테니 <u>방문 체크 bool 배열을 마련해두어 방문하지 않은 노드로만 내려가도록</u> 하면 된다. 방문 했었다면 부모 노드인것이다! 굳이 첫번째 풀이처럼 재귀 한번 더 돌릴 필요 없이 그냥 bool 배열 하나만 마련하면 된다.</li>
    </ul>
  </li>
  <li>🔥 세 번째 풀이
    <ul>
      <li>두 번째 풀이의 응용이다. <u>방문 체크 bool 배열을 사용하지 않고</u> 재귀 함수에 <code class="language-plaintext highlighter-rouge">int parent</code> 매개변수를 추가로 두어 호출할 때 현재 노드를 <code class="language-plaintext highlighter-rouge">int parent</code> 에 넘긴다. 현재 노드가 다음 재귀에선 부모 노드가 되기 때문이다. 인접리스트에서 <code class="language-plaintext highlighter-rouge">parnet</code>와 같지 않은 것에 대해서만 재귀 돌리면 된다.</li>
    </ul>
  </li>
</ul>

<p>이런 차이일 뿐이다! 첫 번째 풀이가 재귀함수를 3개 쓰긴하지만 인접리스트를 <code class="language-plaintext highlighter-rouge">[부모] = 자식</code> 형태로 정리한 것을 사용하는게 재귀 종료 조건식이 짧아져 더 직관적이고 가독성이 좋다고 생각했다! 채점 결과 두 풀이의 시간 차이를 그닥 없었다. 10 ms 정도…</p>

<p><br /></p>

<h3 id="-첫-번째-풀이-">🔥 첫 번째 풀이 ⭕</h3>

<p><code class="language-plaintext highlighter-rouge">tree</code> 배열을 <code class="language-plaintext highlighter-rouge">[부모노드] = { 자식, 자식 }</code> 형태로 정리했기에 방문 체크가 전혀 필요하지 않다. 기둥 DFS 경우엔 반복문도 필요 없다. 인접리스트 <code class="language-plaintext highlighter-rouge">tree</code> 에 기둥은 자식이 1 개인게 보장되므로.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">next</span><span class="p">,</span> <span class="n">cost</span><span class="p">;</span> <span class="p">};</span> <span class="c1">// 구조체 안쓰고 cost 정적 이차원 배열 따로 만들어서 사용했는데 메모리 초과가 발생하였다. 안쓰는 공간이 너무 많아져서 그런 듯 하다. 구조체로 바꾸고 jagged array 형태로 바꾸니 메모리 초과는 해결함</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="n">adj_list</span><span class="p">;</span> <span class="c1">// [노드] = { 자식, 부모, 자식 }</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="n">tree</span><span class="p">;</span> <span class="c1">// [부모노드] = { 자식, 자식 }</span>
<span class="kt">int</span> <span class="n">Giga</span><span class="p">,</span> <span class="n">pole</span><span class="p">,</span> <span class="n">branch</span><span class="p">;</span> <span class="c1">// giga 가 이미 C++ 라이브러리에 있는..건가 보다. giga 라고 하니 모호함 떠서 Giga 라고 해줌 ㅠ</span>

<span class="kt">void</span> <span class="nf">make_tree</span><span class="p">(</span><span class="kt">int</span> <span class="n">now</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">adj_list</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">make_tree</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">find_pole</span><span class="p">(</span><span class="kt">int</span> <span class="n">now</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 기가 노드를 발견했거나 리프 노드에 도달했을때 (이땐 기가 노드가 없는 경우)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">Giga</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
		<span class="n">pole</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

    <span class="c1">// 기둥은 자식이 1 개</span>
	<span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nextCost</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">cost</span><span class="p">;</span>
	<span class="n">find_pole</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">nextCost</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">find_max_branch</span><span class="p">(</span><span class="kt">int</span> <span class="n">now</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">)</span> <span class="p">{</span> 
    <span class="c1">// 리프노드에 도달</span>
    <span class="c1">// 기가 노드가 없는 경우에도 find_max_branch 호출하자마자 바로 이곳에 걸리게 된다. 그래서 자연스럽게 branch 는 0 이 된다.</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">branch</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nextCost</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">cost</span><span class="p">;</span>
		<span class="n">find_max_branch</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">nextCost</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//freopen("input.txt", "r", stdin);</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">R</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span> <span class="o">&gt;&gt;</span> <span class="n">R</span><span class="p">;</span>

	<span class="n">adj_list</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">tree</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">cost</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">node1</span> <span class="o">&gt;&gt;</span> <span class="n">node2</span> <span class="o">&gt;&gt;</span> <span class="n">cost</span><span class="p">;</span>

		<span class="n">adj_list</span><span class="p">[</span><span class="n">node1</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span> <span class="n">node2</span><span class="p">,</span> <span class="n">cost</span> <span class="p">});</span>
		<span class="n">adj_list</span><span class="p">[</span><span class="n">node2</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span> <span class="n">node1</span><span class="p">,</span> <span class="n">cost</span> <span class="p">});</span>
	<span class="p">}</span>

	<span class="n">make_tree</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span> 
	<span class="n">find_pole</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">find_max_branch</span><span class="p">(</span><span class="n">Giga</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pole</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">branch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="-두-번째-풀이-">🔥 두 번째 풀이 ⭕</h3>

<p>이 풀이는 부모 자식 섞인 인접리스트를 그대로 사용한다. 따라서 <code class="language-plaintext highlighter-rouge">bool</code> 타입의 <code class="language-plaintext highlighter-rouge">visited</code> 배열을 따로 두고 방문체크를 하였다. 방문한적이 있다면 부모 노드!</p>

<p>트리는 사이클이 없는 그래프이다. 따라서 트리를 순회한다면 이미 탐색 완료한 노드는 다른 경로에서 두 번 다시는 방문할 일이 없다. 그러니 다른 여타 DFS 풀이들처럼 <code class="language-plaintext highlighter-rouge">visited</code>를 <code class="language-plaintext highlighter-rouge">false</code>로 해제하지 않아도 된다.</p>

<p>기둥의 종료 조건문이 좀 더 복잡해졌다. 인접리스트는 부모, 자식 정보가 섞여 있기 때문에 좀 더 세밀하게 조건을 설정해주어야 했다.</p>

<ul>
  <li>기둥 길이 재귀 종료 조건
    <ul>
      <li>기가 노드가 존재하는 경우
        <ul>
          <li>인접 리스트 크기가 3 이상 (명백하게 자식 노드가 2개 이상임)</li>
          <li>인접 리스트 크기가 2 인데 본인이 루트 노드 (이 경우 루트노드가 곧 기가 노드)</li>
        </ul>
      </li>
      <li>기가 노드가 존재하지 않는 경우 (리프 노드에 도달)
        <ul>
          <li>인접 리스트 크기가 1 인데 루트 노드는 아님 (그럼 그 1개는 부모노드라는 뜻이므로)</li>
          <li>인접 리스트 크기가 0 (이 경우 루트가 곧 리프노드)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">R</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">next</span><span class="p">,</span> <span class="n">cost</span><span class="p">;</span> <span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="n">tree</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">giga_node</span><span class="p">,</span> <span class="n">pole</span><span class="p">,</span> <span class="n">branch</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">find_pole</span><span class="p">(</span><span class="kt">int</span> <span class="n">now</span><span class="p">,</span> <span class="kt">int</span> <span class="n">totalCost</span><span class="p">)</span> <span class="p">{</span>
	
	<span class="kt">bool</span> <span class="n">giga_exist</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="n">R</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
	<span class="kt">bool</span> <span class="n">giga_not_exist</span> <span class="o">=</span> <span class="p">(</span><span class="n">now</span> <span class="o">!=</span> <span class="n">R</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="n">R</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">giga_exist</span> <span class="o">||</span> <span class="n">giga_not_exist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">giga_node</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
		<span class="n">pole</span> <span class="o">=</span> <span class="n">totalCost</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nextCost</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">cost</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">next</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">visited</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">find_pole</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">totalCost</span> <span class="o">+</span> <span class="n">nextCost</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">find_max_branch</span><span class="p">(</span><span class="kt">int</span> <span class="n">now</span><span class="p">,</span> <span class="kt">int</span> <span class="n">totalCost</span><span class="p">)</span> <span class="p">{</span>

	<span class="kt">bool</span> <span class="n">isLeaf</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isLeaf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">branch</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span> <span class="n">totalCost</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nextCost</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">cost</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">next</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">visited</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">find_max_branch</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">totalCost</span> <span class="o">+</span> <span class="n">nextCost</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//freopen("input.txt", "r", stdin);</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span> <span class="o">&gt;&gt;</span> <span class="n">R</span><span class="p">;</span>

	<span class="n">tree</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">visited</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">cost</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">node1</span> <span class="o">&gt;&gt;</span> <span class="n">node2</span> <span class="o">&gt;&gt;</span> <span class="n">cost</span><span class="p">;</span>
		
		<span class="n">tree</span><span class="p">[</span><span class="n">node1</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span> <span class="n">node2</span><span class="p">,</span> <span class="n">cost</span> <span class="p">});</span>
		<span class="n">tree</span><span class="p">[</span><span class="n">node2</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span> <span class="n">node1</span><span class="p">,</span> <span class="n">cost</span> <span class="p">});</span>
	<span class="p">}</span>
    
    <span class="n">visited</span><span class="p">[</span><span class="n">R</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 루트 노드 방문 체크 미리!</span>
	<span class="n">find_pole</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">find_max_branch</span><span class="p">(</span><span class="n">giga_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pole</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">branch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="-세-번째-풀이-">🔥 세 번째 풀이 ⭕</h3>

<p>두 번째 풀이와 비교해서 <code class="language-plaintext highlighter-rouge">visited</code> 배열이 사라졌고 재귀 함수에 <code class="language-plaintext highlighter-rouge">int parent</code> 가 추가 되었다. 이걸로 방문 체크, 즉 부모 노드인지를 구분한다. <code class="language-plaintext highlighter-rouge">giga_parent</code> 도 추가로 필요하다. 가지 DFS 를 진행할 때 기가 노드의 부모도 알아야 기가 노드의 인접 리스트에서 부모 자식을 구분해야 하기 떄문이다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">R</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">next</span><span class="p">,</span> <span class="n">cost</span><span class="p">;</span> <span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="n">tree</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">giga_node</span><span class="p">,</span> <span class="n">giga_parent</span><span class="p">,</span> <span class="n">pole</span><span class="p">,</span> <span class="n">branch</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">find_pole</span><span class="p">(</span><span class="kt">int</span> <span class="n">now</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">totalCost</span><span class="p">)</span> <span class="p">{</span>

	<span class="kt">bool</span> <span class="n">giga_exist</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="n">R</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
	<span class="kt">bool</span> <span class="n">giga_not_exist</span> <span class="o">=</span> <span class="p">(</span><span class="n">now</span> <span class="o">!=</span> <span class="n">R</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="n">R</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">giga_exist</span> <span class="o">||</span> <span class="n">giga_not_exist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">giga_parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span> <span class="c1">// 기가 노드의 부모도 저장</span>
		<span class="n">giga_node</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
		<span class="n">pole</span> <span class="o">=</span> <span class="n">totalCost</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nextCost</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">cost</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span>
			<span class="n">find_pole</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">totalCost</span> <span class="o">+</span> <span class="n">nextCost</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">find_max_branch</span><span class="p">(</span><span class="kt">int</span> <span class="n">now</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">totalCost</span><span class="p">)</span> <span class="p">{</span>

	<span class="kt">bool</span> <span class="n">isLeaf</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isLeaf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">branch</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span> <span class="n">totalCost</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nextCost</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">cost</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span>
			<span class="n">find_max_branch</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">totalCost</span> <span class="o">+</span> <span class="n">nextCost</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//freopen("input.txt", "r", stdin);</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span> <span class="o">&gt;&gt;</span> <span class="n">R</span><span class="p">;</span>

	<span class="n">tree</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">cost</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">node1</span> <span class="o">&gt;&gt;</span> <span class="n">node2</span> <span class="o">&gt;&gt;</span> <span class="n">cost</span><span class="p">;</span>

		<span class="n">tree</span><span class="p">[</span><span class="n">node1</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span> <span class="n">node2</span><span class="p">,</span> <span class="n">cost</span> <span class="p">});</span>
		<span class="n">tree</span><span class="p">[</span><span class="n">node2</span><span class="p">].</span><span class="n">push_back</span><span class="p">({</span> <span class="n">node1</span><span class="p">,</span> <span class="n">cost</span> <span class="p">});</span>
	<span class="p">}</span>

	<span class="n">find_pole</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// 루트 노드는 부모가 없으니 루트 노드, 루트 노드로 호출</span>
	<span class="n">find_max_branch</span><span class="p">(</span><span class="n">giga_node</span><span class="p">,</span> <span class="n">giga_parent</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 기가 노드와 기가 노드의 부모</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pole</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">branch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/42318591/125181597-3b441000-e241-11eb-8e44-3a05c1c8d1c5.png" alt="image" /></p>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>민경</name></author><category term="BOJ" /><category term="Algorithm" /><category term="Coding Test" /><category term="Cpp" /><summary type="html"><![CDATA[🚀 난이도]]></summary></entry><entry><title type="html">[백준 20164][💛5] 홀수 홀릭 호석</title><link href="http://localhost:4000/boj/20164/" rel="alternate" type="text/html" title="[백준 20164][💛5] 홀수 홀릭 호석" /><published>2021-07-10T00:00:00+09:00</published><updated>2021-07-10T00:00:00+09:00</updated><id>http://localhost:4000/boj/20164</id><content type="html" xml:base="http://localhost:4000/boj/20164/"><![CDATA[<h2 id="-난이도">🚀 난이도</h2>

<blockquote>
  <p>💛 골드 5</p>
</blockquote>

<p><br /></p>

<h2 id="-문제">🚀 문제</h2>

<blockquote>
  <p><a href="https://www.acmicpc.net/problem/20164">https://www.acmicpc.net/problem/20164</a></p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/42318591/125154337-881ddd00-e194-11eb-9ed4-0c73ec47fe74.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/42318591/125154340-8e13be00-e194-11eb-8611-0b8ee8c992f6.png" alt="image" /></p>

<p><del>홀수에 미친 호석이</del></p>

<p><br /></p>

<h2 id="-내-풀이-">🚀 내 풀이 ⭕</h2>

<p>재귀적으로 다음 과정을 수행하면 된다.</p>

<ul>
  <li>현재의 문자열 길이가 3 이상이라면 👉 <em>문자열 길이를 세 부분으로 나누어 홀수 개수를 세고 합친다.(합친건 다음 재귀 문자열이 된다.)</em>
    <ol>
      <li>문자열 길이를 <code class="language-plaintext highlighter-rouge">S</code> 라고 한다면 <code class="language-plaintext highlighter-rouge">S-1 C 2</code> 개의 조합을 구한다.
        <ul>
          <li>예를 들어 “82019” 라면, 이 문자열을 3 개의 부분으로 나누기 위해선 “8💓2💓0💓1💓9” 이렇게 4 개의 💓 에서 2 개를 뽑는 것이라고 생각할 수 있다. 즉, 문자열을 나눌 수 있는 사이사이 부분은 항상 <code class="language-plaintext highlighter-rouge">S-1</code>개가 있는데 이 중에서 2 개를 뽑아 이 위치를 기준으로 <code class="language-plaintext highlighter-rouge">substr</code>를 통해 문자열을 3 개로 쪼갤 수 있는 것이다.</li>
          <li>임의로 세 파트로 나눈다고 하였으니 현재의 문자열 길이를 기준으로 <code class="language-plaintext highlighter-rouge">S-1 C 2</code> 조합을 모두 구한 후 하나하나 재귀 돌리면 된다.</li>
          <li><code class="language-plaintext highlighter-rouge">N</code>은 입력 크기가 아주 크나 이 <code class="language-plaintext highlighter-rouge">N</code> 의 길이 <code class="language-plaintext highlighter-rouge">S</code> 는 10 을 넘지 않으므로 시간 복잡도는 걱정하지 않아도 된다.</li>
        </ul>
      </li>
      <li>세 파트로 나눈 문자열 각각에서 홀수 개수를 구한다.
        <ul>
          <li><em>check_odd</em> 함수를 만들어 이 함수에서 처리하도로 하였다.</li>
        </ul>
      </li>
      <li>문자열을 정수로 변환하여 합한 후 이를 다시 문자열로 변환하여 다음 재귀에서의 현재 문자열이 되도록 한다.</li>
    </ol>
  </li>
  <li>현재의 문자열 길이가 2 라면 👉 <em>문자열 길이를 두 부분으로 나누어 홀수 개수를 세고 합친다.(합친건 다음 재귀 문자열이 된다.)</em>
    <ul>
      <li>그냥 <code class="language-plaintext highlighter-rouge">s[0]</code> 과 <code class="language-plaintext highlighter-rouge">s[1]</code> 로 나누면 된다.
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 여기서 하나 배운게 있는데, char 문자 하나를 string 화 하려면 길이를 설정하는 생성자를 호출하여 1 로 설정해주면 된다.</span>
<span class="n">string</span> <span class="nf">s1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">s2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>현재의 문자열 길이가 1 이라면 👉 <em>재귀 종료 조건!, 현재 단계까지 구해왔던 홀수 개수의 최소값과 최대값 업데이트</em></li>
</ul>

<hr />

<blockquote>
  <p>조합에 대하여</p>
</blockquote>

<ul>
  <li>나는 <code class="language-plaintext highlighter-rouge">prev_permutation</code> 을 사용하여 조합을 구했다.
    <ul>
      <li><a href="https://ansohxxn.github.io/algorithm/combination/">(C++) 조합(Combination) 구현하기</a></li>
    </ul>
  </li>
  <li>근데 딱 2 개만 뽑는 조합을 구하는 것이기 때문에 굳이 나처럼 <code class="language-plaintext highlighter-rouge">prev_permutation</code> 쓸 필요 없이 <u>이중 for문</u>을 사용하여 조합을 구해도 된다.
    <ul>
      <li>2 개 뽑는 조합은 아래와 같은 이중 for문으로 구할 수 있다. <code class="language-plaintext highlighter-rouge">i</code>와 <code class="language-plaintext highlighter-rouge">j</code>가 뽑은 두 개의 수가 된다.
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 이런식!</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">Min</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">Max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">check_odd</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="c1">// 문자열의 한 문자 한 문자 다 검사 </span>
		<span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 해당 문자를 숫자로 변환했을 때 홀수라면</span>
			<span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">odd_holic</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">totalCount</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">totalCount</span> <span class="o">+=</span> <span class="n">check_odd</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">Min</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">Min</span><span class="p">,</span> <span class="n">totalCount</span><span class="p">);</span>
		<span class="n">Max</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">Max</span><span class="p">,</span> <span class="n">totalCount</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">string</span> <span class="n">s1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">s2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

		<span class="n">string</span> <span class="n">next</span> <span class="o">=</span> <span class="n">to_string</span><span class="p">((</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">));</span>
		<span class="kt">int</span> <span class="n">nowCount</span> <span class="o">=</span> <span class="n">check_odd</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">+</span> <span class="n">check_odd</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
		<span class="n">odd_holic</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">totalCount</span> <span class="o">+</span> <span class="n">nowCount</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">comb</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">comb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">boundary</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
				<span class="k">if</span> <span class="p">(</span><span class="n">comb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
					<span class="n">boundary</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="n">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">string</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

			<span class="n">string</span> <span class="n">next</span> <span class="o">=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">stoi</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">+</span> <span class="n">stoi</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="o">+</span> <span class="n">stoi</span><span class="p">(</span><span class="n">s3</span><span class="p">));</span>
			<span class="kt">int</span> <span class="n">nowCount</span> <span class="o">=</span> <span class="n">check_odd</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">+</span> <span class="n">check_odd</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="o">+</span> <span class="n">check_odd</span><span class="p">(</span><span class="n">s3</span><span class="p">);</span>
			<span class="n">odd_holic</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">totalCount</span> <span class="o">+</span> <span class="n">nowCount</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">prev_permutation</span><span class="p">(</span><span class="n">comb</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">comb</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//freopen("input.txt", "r", stdin);</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">string</span> <span class="n">N</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span><span class="p">;</span>
	
	<span class="n">odd_holic</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Min</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">Max</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>민경</name></author><category term="BOJ" /><category term="Algorithm" /><category term="Coding Test" /><category term="Cpp" /><summary type="html"><![CDATA[🚀 난이도]]></summary></entry><entry><title type="html">[백준 14940][💛5] 쉬운 최단거리 (BFS)</title><link href="http://localhost:4000/boj/14940/" rel="alternate" type="text/html" title="[백준 14940][💛5] 쉬운 최단거리 (BFS)" /><published>2021-07-10T00:00:00+09:00</published><updated>2021-07-10T00:00:00+09:00</updated><id>http://localhost:4000/boj/14940</id><content type="html" xml:base="http://localhost:4000/boj/14940/"><![CDATA[<h2 id="-난이도">🚀 난이도</h2>

<blockquote>
  <p>💛 골드 5</p>
</blockquote>

<p><br /></p>

<h2 id="-문제">🚀 문제</h2>

<blockquote>
  <p><a href="https://www.acmicpc.net/problem/14940">https://www.acmicpc.net/problem/14940</a></p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/42318591/125154064-08434300-e193-11eb-8ba7-cc5dc66ea304.png" alt="image" /></p>

<p><br /></p>

<h2 id="-내-풀이-">🚀 내 풀이 ⭕</h2>

<p>정말 기본적인 BFS 문제!</p>

<ul>
  <li>문제에서 목표지점이라고 주어진 부분을 시작점이라고 생각한다.
    <ul>
      <li>하나의 시작점으로부터 모든 지점까지의 거리를 구하는 <code class="language-plaintext highlighter-rouge">BFS</code></li>
    </ul>
  </li>
  <li>도달할 수 없는 위치는 <code class="language-plaintext highlighter-rouge">-1</code>로 출력을 해야 한다.
    <ul>
      <li><em>if (Dist[i][j] == 0 &amp;&amp; Map[i][j] == 1)</em>
        <ul>
          <li>갈 수 있는 곳임에도 불구하고 <code class="language-plaintext highlighter-rouge">Map[i][j] == 1</code>, BFS 결과 목표지점으로부터 거리가 0 인 곳은 갈 수 없는 곳이나 마찬가지이다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dx</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">dy</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">Pos</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">Map</span><span class="p">[</span><span class="mi">1000</span><span class="p">][</span><span class="mi">1000</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">Dist</span><span class="p">[</span><span class="mi">1000</span><span class="p">][</span><span class="mi">1000</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">Pos</span> <span class="n">dest</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 매개변수 출발지. (문제에선 목표지점으로 주어져서 dest 로 이름 짓긴했지만..)</span>
	<span class="n">queue</span><span class="o">&lt;</span><span class="n">Pos</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">M</span><span class="p">));</span>

	<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
	<span class="n">Dist</span><span class="p">[</span><span class="n">dest</span><span class="p">.</span><span class="n">x</span><span class="p">][</span><span class="n">dest</span><span class="p">.</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">visited</span><span class="p">[</span><span class="n">dest</span><span class="p">.</span><span class="n">x</span><span class="p">][</span><span class="n">dest</span><span class="p">.</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">Pos</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
		<span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">nextX</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="kt">int</span> <span class="n">nextY</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">nextX</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nextX</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="o">||</span> <span class="n">nextY</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nextY</span> <span class="o">&gt;=</span> <span class="n">M</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Map</span><span class="p">[</span><span class="n">nextX</span><span class="p">][</span><span class="n">nextY</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">nextX</span><span class="p">][</span><span class="n">nextY</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>

			<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">({</span> <span class="n">nextX</span><span class="p">,</span> <span class="n">nextY</span> <span class="p">});</span>
			<span class="n">Dist</span><span class="p">[</span><span class="n">nextX</span><span class="p">][</span><span class="n">nextY</span><span class="p">]</span> <span class="o">=</span> <span class="n">Dist</span><span class="p">[</span><span class="n">now</span><span class="p">.</span><span class="n">x</span><span class="p">][</span><span class="n">now</span><span class="p">.</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">visited</span><span class="p">[</span><span class="n">nextX</span><span class="p">][</span><span class="n">nextY</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">//freopen("input.txt", "r", stdin);</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">Pos</span> <span class="n">dest</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span> <span class="o">&gt;&gt;</span> <span class="n">M</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">Map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 출발지 저장</span>
				<span class="n">dest</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="n">dest</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">bfs</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">Dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">Map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
		<span class="p">}</span>	
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>민경</name></author><category term="BOJ" /><category term="Algorithm" /><category term="Coding Test" /><category term="Cpp" /><summary type="html"><![CDATA[🚀 난이도]]></summary></entry></feed>