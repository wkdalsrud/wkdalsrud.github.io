<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-03-15T19:07:17+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">기억저장소</title><subtitle>개발공부를 기록하는 공간입니다.</subtitle><author><name>민경</name></author><entry><title type="html">Java프로그래밍 [5]</title><link href="http://localhost:4000/java/uni_java5/" rel="alternate" type="text/html" title="Java프로그래밍 [5]" /><published>2022-03-15T00:00:00+09:00</published><updated>2022-03-15T00:00:00+09:00</updated><id>http://localhost:4000/java/uni_java5</id><content type="html" xml:base="http://localhost:4000/java/uni_java5/"><![CDATA[<h2 id="추상메서드">추상메서드</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">abstract</code> 사용</li>
  <li>몸체 구현 X</li>
  <li><span style="color:red">자식 클래스에 상속될 때, 몸체의 구현이 필요하다</span></li>
  <li>final과 함께 사용 불가</li>
</ul>

<h2 id="추상클래스">추상클래스</h2>
<ul>
  <li>객체 생성 불가</li>
  <li>추상메서드를 가지고 있는 클래스는 추상클래스여야 함</li>
  <li>자식 클래스로 상속이 되어야 자식 클래스에서 객체를 생성할 수 있다.</li>
  <li>추상메서드 + 일반메서드가 같이 있음</li>
</ul>

<h2 id="인터페이스란-객체를-분리하고-결합하기-위해-만든-약속이다">인터페이스란? 객체를 분리하고 결합하기 위해 만든 약속이다.</h2>
<ul>
  <li><span style="color:green">추상메소드의 집합</span></li>
  <li>객체 생성 불가</li>
  <li>public 또는 default만 사용할 수 있다.</li>
  <li>추상메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 다른 요소는 안됨</li>
  <li>다형성
    <ul>
      <li>인터페이스 타입의 레퍼런스 변수는 선언 가능하다
        <ul>
          <li>해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스 타입으로의 형변환도 가능하다.</li>
          <li>메서드의 매개변수의 타입으로도 사용될 수 있다.</li>
        </ul>
      </li>
      <li>메서드의 리턴타입으로 인터페이스를 지정하는 것도 가능하다.
        <ul>
          <li>리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="인터페이스-구현-부모-인터페이스--자식-클래스">인터페이스 구현 (부모 인터페이스 → 자식 클래스)</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">implements</code> 키워드를 사용
    <ul>
      <li>추상클래스 ⇒ <code class="language-plaintext highlighter-rouge">extends</code>사용</li>
      <li>인터페이스 ⇒ <code class="language-plaintext highlighter-rouge">implements</code>사용</li>
    </ul>
  </li>
  <li>인터페이스의 추상메소드 몸통{} 만들기</li>
</ul>

<h2 id="인터페이스-상속-부모-인터페이스--자식-인터페이스">인터페이스 상속 (부모 인터페이스 → 자식 인터페이스)</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">extends</code> 키워드 사용</li>
  <li>다중 상속 가능</li>
</ul>

<h2 id="인터페이스-제약사항">인터페이스 제약사항</h2>
<ul>
  <li>모든 멤버변수는 <code class="language-plaintext highlighter-rouge">public static final</code> 이어야 하며, 생략 가능</li>
  <li>모든 메서드는 <code class="language-plaintext highlighter-rouge">public abstract</code> 이어야 하며, 생략 가능</li>
</ul>

<h2 id="다형성">다형성</h2>
<ul>
  <li>인터페이스도 구현 클래스의 부모처럼 사용할 수 있다.</li>
  <li>★인터페이스 타입 매개변수는 인터페이스를 구현한 클래스의 객체만 가능★</li>
  <li>인터페이스를 메소드의 리턴타입으로 지정할 수 있다.</li>
  <li>★리턴타입이 인터페이스라는 것은 메소드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미★</li>
</ul>

<h2 id="형변환">형변환</h2>
<ul>
  <li>상속 관계에 있는 클래스 간에는 타입 변환이 가능함</li>
  <li>업캐스팅 : 자동 형변환 가능</li>
</ul>]]></content><author><name>민경</name></author><category term="JAVA" /><category term="Java프로그래밍" /><summary type="html"><![CDATA[추상메서드 abstract 사용 몸체 구현 X 자식 클래스에 상속될 때, 몸체의 구현이 필요하다 final과 함께 사용 불가]]></summary></entry><entry><title type="html">Java프로그래밍 [4]</title><link href="http://localhost:4000/java/uni_java4/" rel="alternate" type="text/html" title="Java프로그래밍 [4]" /><published>2022-03-14T00:00:00+09:00</published><updated>2022-03-14T00:00:00+09:00</updated><id>http://localhost:4000/java/uni_java4</id><content type="html" xml:base="http://localhost:4000/java/uni_java4/"><![CDATA[<h2 id="생성자-constructor">생성자 (Constructor)</h2>
<ul>
  <li>객체가 생성될 때 자동으로 실행되는 메서드
    <ul>
      <li>객체의 필드 값을 초기화하거나 메모리 할당 등의 작업이다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Circle c = new Circle(5);</code>
    <ol>
      <li>new 연산자를 이용하여 Circle 객체를 생성하고</li>
      <li>생성자가 호출되면서 (데이터 필드 초기화)</li>
      <li>객체의 참조값을 변수에 대입</li>
    </ol>
  </li>
</ul>

<h3 id="정의-방법">정의 방법</h3>
<ul>
  <li><span style="color:blue">생성자 이름은 클래스 이름과 같다.</span></li>
  <li><strong>생성자 오버로딩</strong>
    <ul>
      <li>여러 생성자를 정의할 수 있다.
        <ul>
          <li><span style="color:red">매개변수의 개수와 자료형</span>으로 구분한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>생성자는 new를 통해 객체를 생성할 때 한 번만 호출된다.</strong></li>
  <li><span style="color:blue">생성자에 반환형을 선언하지 않는다.</span>
    <ul>
      <li><strong>리턴 값이 없다고 해서 void를 리턴 타입으로 지정하면 안 된다.</strong></li>
      <li>return문은 메소드의 실행을 끝내고 호출한 곳으로 돌아가라는 명령이므로 생성자의 실행을 끝내고자 하면 생성자 코드 내 어디서든 return문을 사용할 수 있다.</li>
    </ul>
  </li>
  <li><strong>생성자의 목적은 객체가 생성될 때 필요한 초기 작업을 위함이다.</strong>
    <ul>
      <li>객체가 생성될 때 필드 초기화, 필요한 메모리 확보, 파일 열기, 네트워크 연결 등 객체가 활동하기 전에 필요한 초기 준비를 하는데 이용된다.</li>
    </ul>
  </li>
</ul>

<h2 id="기본-생성자">기본 생성자</h2>
<ul>
  <li>매개변수와 실행 코드가 없어 아무 일도 하지 않고 단순 리턴하는 생성자</li>
</ul>
<details>
<summary>기본 생성자가 자동으로 생성되는 경우</summary>
<div>
    <ul>
      <li>모든 객체는 생성될 때 반드시 생성자가 실행되기 때문에 생성자가 하나도 없는 경우, 컴파일러는 기본 생성자를 자동으로 생성한다.</li>
    </ul>
  </div>
</details>
<details>
<summary>기본 생성자가 자동으로 생성되지 않는 경우</summary>
<div>
    <ul>
      <li>생성자가 하나라도 존재하는 클래스에는 컴파일러가 기본 생성자를 삽입해 주지 않는다.</li>
    </ul>
  </div>
</details>

<h2 id="매개변수가-있는-생성자">매개변수가 있는 생성자</h2>
<ul>
  <li>인스턴스를 생성하는 동시에 원하는 값으로 초기화할 수 있다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Circle</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">height</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">width</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">radi</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">Circle</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// 기본 생성자</span>
    <span class="n">height</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
    <span class="n">width</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
    <span class="n">radi</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nf">Circle</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 생성자 오버로딩</span>
    <span class="k">this</span><span class="o">.</span><span class="na">height</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">width</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">radi</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="클래스의-사용">클래스의 사용</h2>
<ul>
  <li>상속</li>
  <li>객체 생성</li>
</ul>

<h2 id="객체의-사용">객체의 사용</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">객체.변수</code> 를 사용하여 인스턴스 변수를 읽거나 쓰기</li>
  <li><code class="language-plaintext highlighter-rouge">객체.메서드</code> 를 이용하여 호출</li>
</ul>

<h2 id="static">static</h2>
<ul>
  <li>클래스를 설계할 때,  멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.</li>
  <li>클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.
    <ul>
      <li>staic이 붙은 변수는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성된다.</li>
    </ul>
  </li>
  <li>클래스 메서드(static메서드)는 인스턴스 변수를 사용할 수 없다.
    <ul>
      <li>인스턴스 변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스메서드는 인스턴스 생성 없이 호출 가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다. 반면에 인스턴스 변수나 인스턴스메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다.</li>
    </ul>
  </li>
  <li>메서드 내에서 인스턴스 변수를 사용하지 않는다면 static을 붙이는 것을 고려한다.</li>
</ul>

<h2 id="인스턴스-변수와-static-변수의-차이">인스턴스 변수와 static 변수의 차이</h2>
<h3 id="인스턴스-변수">인스턴스 변수</h3>
<ul>
  <li>멤버는 객체마다 별도로 존재한다.</li>
  <li>객체가 생성 시에 멤버도 생성된다.</li>
  <li>멤버는 객체가 생성된 이후에 사용이 가능하다.</li>
  <li>객체가 사라지면 멤버도 사라진다.</li>
  <li>멤버는 객체 내에 각각 공간 유지를 하며 공유되지 않는다.</li>
</ul>

<h3 id="static-변수">static 변수</h3>
<ul>
  <li>멤버는 클래스당 하나만 생성이 되고 객체 내부가 아닌 별도의 공간에 생성된다.</li>
  <li>클래스 로딩 시에 멤버가 생성되고 객체가 생성되기 전에 이미 생성된다.</li>
  <li>객체가 생기기 전에 사용 가능하다. (<strong><span style="color:red">클래스이름.필드</span></strong> or <span style="color:red">객체변수.필드</span>)</li>
  <li>객체가 사라져도 멤버는 사라지지 않고 프로그램이 종료될 때 사라진다.</li>
  <li>동일한 클래스의 모든 객체들에 의해 공유된다.</li>
</ul>

<h2 id="final-필드">final 필드</h2>
<ul>
  <li>상수 데이터를 선언한다.</li>
  <li>선언할 때 초기값을 지정해야 한다.</li>
</ul>

<h2 id="final-메서드">final 메서드</h2>
<ul>
  <li>자식 클래스로 상속은 가능하지만 재정의는 할 수 없다.</li>
</ul>

<h2 id="오버로드과-오버라이딩-차이">오버로드과 오버라이딩 차이</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: left">메소드 오버로딩</th>
      <th style="text-align: left">메소드 오버라이딩</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">선언</td>
      <td style="text-align: left">매개변수가 다른 생성자를 추가</td>
      <td style="text-align: left">상속받은 메서드의 내용 변경</td>
    </tr>
    <tr>
      <td style="text-align: center">관계</td>
      <td style="text-align: left">동일한 클래스 내 또는 상속관계</td>
      <td style="text-align: left">상속관계</td>
    </tr>
    <tr>
      <td style="text-align: center">목적</td>
      <td style="text-align: left">✔️ 이름이 같은 여러개의 메서드를 중복 작성하여 사용의 편리성 향상<br />✔️ 다형성 실현</td>
      <td style="text-align: left">✔️ 부모 클래스에 구현된 메서드를 무시하고 자식 클래스에서 새로운 기능의 메서드를 재정의<br />✔️ 다형성 실현</td>
    </tr>
    <tr>
      <td style="text-align: center">조건</td>
      <td style="text-align: left">1. 메서드 이름 동일<br />2. 매개변수 타입이나 개수 달라야 함<br />3. 반환 타입이나 접근 지정자는 관계 없음</td>
      <td style="text-align: left">1. 메서드 이름, 매개변수 타입, 개수, 리턴 타입이 모두 동일해야 함<br />2. 접근 제어자는 부모 클래스의 메서드보다 좁은 범위로 변경 불가<br />3. 부모 클래스의 메서드보다 많은 수의 예외 선언 불가</td>
    </tr>
    <tr>
      <td style="text-align: center">바인딩</td>
      <td style="text-align: left">정적 바인딩<br />호출될 메소드는 컴파일 시에 결정</td>
      <td style="text-align: left">동적 바인딩<br />실행 시간에 오버라이딩된 메서드를 찾아 호출</td>
    </tr>
  </tbody>
</table>

<h2 id="상속">상속</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">extends</code> 사용</li>
  <li>단일 상속</li>
  <li>메서드 재정의 (오버라이딩) 가능</li>
</ul>

<h3 id="has-a-합성">has a 합성</h3>
<ul>
  <li>기존 클래스를 새로운 클래스에서 필드의 자료형으로 사용</li>
  <li><code class="language-plaintext highlighter-rouge">Composition has a</code> 관계
    <ul>
      <li>객체 생성을 생성자 내부에서 만듦</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Association has a</code> 관계
    <ul>
      <li>생성된 객체를 넘겨받음
        <ul>
          <li>오버로드 생성자로 객체를 넘겨받기</li>
          <li>Setter로 객체 넘겨받기</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="is-a-상속">is a 상속</h3>
<ul>
  <li>기존 클래스를 사용하여 새로운 클래스 정의</li>
  <li>장점 : 코드의 중복 작성을 줄임</li>
</ul>

<h2 id="this와-super">this와 super</h2>

<p><img width="1178" alt="image" src="https://user-images.githubusercontent.com/73566453/158345682-5eaec350-399a-49ca-b91e-2df7a7aed7e6.png" /></p>]]></content><author><name>민경</name></author><category term="JAVA" /><category term="Java프로그래밍" /><summary type="html"><![CDATA[생성자 (Constructor) 객체가 생성될 때 자동으로 실행되는 메서드 객체의 필드 값을 초기화하거나 메모리 할당 등의 작업이다. Circle c = new Circle(5); new 연산자를 이용하여 Circle 객체를 생성하고 생성자가 호출되면서 (데이터 필드 초기화) 객체의 참조값을 변수에 대입]]></summary></entry><entry><title type="html">Java프로그래밍 [2]</title><link href="http://localhost:4000/java/uni_java2/" rel="alternate" type="text/html" title="Java프로그래밍 [2]" /><published>2022-03-13T00:00:00+09:00</published><updated>2022-03-13T00:00:00+09:00</updated><id>http://localhost:4000/java/uni_java2</id><content type="html" xml:base="http://localhost:4000/java/uni_java2/"><![CDATA[<h2 id="식별자">식별자</h2>
<ul>
  <li>클래스
    <ul>
      <li>낙타표기법</li>
    </ul>
  </li>
  <li>메소드, 변수(필드)
    <ul>
      <li>첫 글자가 소문자</li>
    </ul>
  </li>
  <li>상수
    <ul>
      <li>모든 문자를 대문자로 표기하고 단어 사이에 ‘_‘를 넣어서 구분한다.</li>
    </ul>
  </li>
</ul>

<h2 id="변수의-종류">변수의 종류</h2>
<ul>
  <li>인스턴스 변수
    <ul>
      <li>객체가 소유하는 변수
        <ul>
          <li>클래스 정의에서 static이 아닌 필드</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>클래스 변수
    <ul>
      <li>객체가 공유하는 변수
        <ul>
          <li>클래스 정의에서 static 필드</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>지역변수
    <ul>
      <li>메서드 내부 또는 지역 블럭 내부에서 선언된 변수</li>
    </ul>
  </li>
</ul>

<h2 id="변수의-사용-범위">변수의 사용 범위</h2>
<h3 id="지역-변수">지역 변수</h3>
<ul>
  <li>해당 블럭이 종료될 때까지 유효하다.</li>
  <li>메서드가 실행될 때 만들어지고 끝나면 없어짐</li>
  <li>지역 변수는 초기값을 지정한 후 사용해야 한다.</li>
</ul>

<h3 id="인스턴스-변수나-클래스-변수">인스턴스 변수나 클래스 변수</h3>
<ul>
  <li>선언된 클래스 내부에서 사용 가능하다.</li>
  <li>클래스 외부에서의 사용 가능 여부는 접근제어자에 따라 다르다.</li>
</ul>

<h2 id="기본형-자료형">기본형 자료형</h2>
<p><img src="https://user-images.githubusercontent.com/73566453/158056636-00f70b07-c8d9-45a5-bbd0-16f1b9e5af98.png" alt="image" /></p>

<h2 id="참조형-자료형">참조형 자료형</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Array</code></li>
  <li><code class="language-plaintext highlighter-rouge">Class</code></li>
  <li><code class="language-plaintext highlighter-rouge">Interface</code></li>
</ul>

<blockquote>
  <p><span style="color:red">참조형 변수는 저장 공간에 참조 값을 저장한다.</span><br />
실제 데이터는 별도의 공간에 저장됨<br />
<span style="color:red">기본형 변수는 저장 공간에 값 자체를 저장한다.</span></p>
</blockquote>

<h2 id="형변환">형변환</h2>
<h3 id="묵시적-자료형의-변환">묵시적 자료형의 변환</h3>
<p>작은 타입에서 큰 타입으로는 자동 형변환</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">byte → short → int → long → float → double</code></li>
</ul>

<h3 id="명시적-자료형의-변환">명시적 자료형의 변환</h3>
<p>큰 타입에서 작은 타입으로 변환할 때는 명시적 형변환이 필요하다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">(자료형)피연산자</code></li>
</ul>

<h2 id="명령-행-매개-변수">명령 행 매개 변수</h2>
<p><img width="1082" alt="image" src="https://user-images.githubusercontent.com/73566453/158057583-e8992c99-321c-4122-9de0-ad63b8fd30df.png" /></p>

<p><img src="https://user-images.githubusercontent.com/73566453/158057707-23e02450-7ec4-40b4-a416-d7829a0bea48.png" alt="image" /></p>

<h2 id="제어문">제어문</h2>
<ul>
  <li>실행의 흐름을 바꿈</li>
</ul>

<h3 id="제어문의-종류">제어문의 종류</h3>
<ul>
  <li>선택문
    <ul>
      <li>조건에 따른 문장의 선택
        <ul>
          <li>if문, switch문</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>반복문
    <ul>
      <li>조건에 따른 문장의 반복
        <ul>
          <li>for문</li>
          <li>while문</li>
          <li>do-while문</li>
          <li>for-each문
            <ul>
              <li>개선된 for문</li>
              <li>배열이나 컬렉션의 원소들을 차례로 다룰 때 편리</li>
              <li><code class="language-plaintext highlighter-rouge">for(변수선언:배열){문장,,,}</code></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>점프문
    <ul>
      <li>분기문
        <ul>
          <li>return문</li>
          <li>break문
            <ul>
              <li>break문을 포함하는 가장 가까운 반복문이나 switch문의 실행을 끝낸다.</li>
              <li>레이블을 사용하여 특정 블럭 또는 특정 반복문을 빠져나갈 수 있다.
                <ul>
                  <li><code class="language-plaintext highlighter-rouge">break 레이블;</code></li>
                  <li>예를 들면 <code class="language-plaintext highlighter-rouge">break DONE;</code> 이런식으로 사용</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>continue문
            <ul>
              <li>반복문 안에서 사용함</li>
              <li>반복문을 빠져나가지 않으면서 즉시 다음 반복으로 넘어감</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="선택문">선택문</h2>
<ul>
  <li>if문</li>
  <li>if-else문</li>
  <li>switch문
    <ul>
      <li>다중 선택 구조</li>
      <li>case 조건은 정수와 호환되거나 String 값</li>
      <li>default는 생략 가능, 어떤 case에도 해당되지 않는 경우 매칭된다.</li>
      <li>만족되는 case를 실행한 후, break문을 만날 때까지 계속 실행된다.</li>
    </ul>
  </li>
</ul>]]></content><author><name>민경</name></author><category term="JAVA" /><category term="Java프로그래밍" /><summary type="html"><![CDATA[식별자 클래스 낙타표기법 메소드, 변수(필드) 첫 글자가 소문자 상수 모든 문자를 대문자로 표기하고 단어 사이에 ‘_‘를 넣어서 구분한다.]]></summary></entry><entry><title type="html">Java프로그래밍 [3]</title><link href="http://localhost:4000/java/uni_java3/" rel="alternate" type="text/html" title="Java프로그래밍 [3]" /><published>2022-03-13T00:00:00+09:00</published><updated>2022-03-13T00:00:00+09:00</updated><id>http://localhost:4000/java/uni_java3</id><content type="html" xml:base="http://localhost:4000/java/uni_java3/"><![CDATA[<h2 id="배열-array">배열 (Array)</h2>
<ul>
  <li>같은 타입의 데이터들이 순차적으로 저장된다.</li>
  <li>배열의 크기는 배열이 초기화 또는 생성할 때 정해지고 한번 생성하면 길이를 변경할 수 없기 때문에 이미 생성된 배열의 길이는 변하지 않는다.
    <ol>
      <li>왜? : 배열은 연속적인 자료이다. 배열의 길이에 맞춰서(byte) 메모리의 공간을 찾아서 만드는데 배열의 길이를 변경하게 되면 그 공간에 변경된 배열의 길이만큼의 메모리 공간이 있는지 보장할 수 없다.</li>
      <li>부족하면? : 배열의 길이를 크게 새로 만들고 원래 배열을 복사한다.</li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ArrayIndexOutOfBoundsException</code> → 배열의 index가 유효한 범위를 벗어났다는 에러</li>
  <li>인덱스를 이용하여 특정 원소를 다룬다.</li>
</ul>

<h2 id="배열의-선언과-생성">배열의 선언과 생성</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">i</span><span class="o">;</span> <span class="c1">// 배열에 대한 레퍼런스 변수 선언</span>
<span class="n">i</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span> <span class="c1">// 배열 생성</span>

<span class="o">=&gt;</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">i</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span> <span class="c1">// 선언과 동시에 생성함</span>
</code></pre></div></div>

<ol>
  <li>배열에 대한 레퍼런스 변수 선언
    <ul>
      <li>배열에 대한 레퍼런스 변수 선언만으로 배열 공간이 할당되지 않으며 레퍼런스 변수는 배열 공간에 대한 주소 값을 가지며 그 자체가 배열은 아니다.</li>
      <li>배열 선언 시 []안에 크기를 지정해서는 안 된다.</li>
    </ul>
  </li>
  <li>배열 생성
    <ul>
      <li>배열 생성은 반드시 <u>new연산자</u>를 이용하여 배열을 생성하며 []안에 생성할 원소 개수를 지정한다.</li>
      <li>배열을 생성하면 각 요소에는 원소가 숫자인 경우 0, 참조형인 경우에는 null로 자동 초기화된다.</li>
    </ul>
  </li>
</ol>

<h2 id="배열의-초기화">배열의 초기화</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span><span class="mi">20</span><span class="o">,</span><span class="mi">30</span><span class="o">,</span><span class="mi">40</span><span class="o">};</span> <span class="c1">// 선언과 동시에 초기화</span>
<span class="kt">int</span> <span class="n">b</span><span class="o">[];</span>
<span class="n">b</span> <span class="o">=</span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">};</span> <span class="c1">// 오류</span>
</code></pre></div></div>

<h2 id="배열의-크기">배열의 크기</h2>
<ul>
  <li>배열이 생성되면 객체가 생성되고 이 객체에는 배열의 저장 공간과 함께 배열의 크기 값을 가진 length필드가 존재한다.</li>
  <li>length는 객체의 멤버라 <code class="language-plaintext highlighter-rouge">배열이름.length</code>로 배열의 크기를 알아낼 수 있다.</li>
</ul>

<h2 id="문자열의--연산자">문자열의 + 연산자</h2>
<ul>
  <li>두 문자열을 연결</li>
  <li>+연산자를 사용할 때 기본형 또는 다른 참조형 값은 문자열로 자동 형변환이 가능하다.</li>
</ul>

<h2 id="scanner-클래스">Scanner 클래스</h2>
<ul>
  <li>키보드나 파일로부터 다양한 자료를 입력 받을 때 사용
    <ul>
      <li>기본적으로 공백 문자로 구분되는 단어 단위로 입력이 된다.</li>
      <li>문자열이나 기본형 값의 입력을 위해 <code class="language-plaintext highlighter-rouge">nextXXX()</code>메소드를 제공함</li>
      <li><code class="language-plaintext highlighter-rouge">System.in</code>을 이용하여 키보드에서 입력을 받는 객체를 만들고 사용</li>
    </ul>
  </li>
</ul>

<h2 id="hasnext-활용">hasNext() 활용</h2>
<div align="center">
<img width="771" alt="image" src="https://user-images.githubusercontent.com/73566453/158060750-aa7bdc02-62da-4ef7-a245-43eb1dd315f8.png" /></div>

<h2 id="클래스">클래스</h2>
<h3 id="클래스의-정의">클래스의 정의</h3>
<ul>
  <li>데이터 필드와 메서드를 정의</li>
  <li>객체의 상태는 데이터 → 필드, 기능 → 메서드로 구현된다.</li>
</ul>

<h3 id="클래스의-사용">클래스의 사용</h3>
<ul>
  <li>클래스형 변수를 선언할 때
    <ul>
      <li>클래스는 객체의 자료형</li>
      <li>예를 들면 <code class="language-plaintext highlighter-rouge">Car c</code></li>
    </ul>
  </li>
  <li>객체를 생성할 때
    <ul>
      <li>예를 들면 <code class="language-plaintext highlighter-rouge">Circle c = new Circle()</code></li>
    </ul>
  </li>
  <li>상속받아 클래스를 정의할 때</li>
</ul>

<h2 id="클래스의-접근제어자">클래스의 접근제어자</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">접근지정자</th>
      <th style="text-align: center">같은 클래스의 멤버</th>
      <th style="text-align: center">같은 패키지의 멤버</th>
      <th style="text-align: center">다른 패키지 자식 클래스의 멤버</th>
      <th style="text-align: center">그 외의 영역</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">public</td>
      <td style="text-align: center">O</td>
      <td style="text-align: center">O</td>
      <td style="text-align: center">O</td>
      <td style="text-align: center">O</td>
    </tr>
    <tr>
      <td style="text-align: center">protected</td>
      <td style="text-align: center">O</td>
      <td style="text-align: center">O</td>
      <td style="text-align: center">O</td>
      <td style="text-align: center">X</td>
    </tr>
    <tr>
      <td style="text-align: center">default(생략)</td>
      <td style="text-align: center">O</td>
      <td style="text-align: center">O</td>
      <td style="text-align: center">X</td>
      <td style="text-align: center">X</td>
    </tr>
    <tr>
      <td style="text-align: center">private</td>
      <td style="text-align: center">O</td>
      <td style="text-align: center">X</td>
      <td style="text-align: center">X</td>
      <td style="text-align: center">X</td>
    </tr>
  </tbody>
</table>]]></content><author><name>민경</name></author><category term="JAVA" /><category term="Java프로그래밍" /><summary type="html"><![CDATA[배열 (Array) 같은 타입의 데이터들이 순차적으로 저장된다. 배열의 크기는 배열이 초기화 또는 생성할 때 정해지고 한번 생성하면 길이를 변경할 수 없기 때문에 이미 생성된 배열의 길이는 변하지 않는다. 왜? : 배열은 연속적인 자료이다. 배열의 길이에 맞춰서(byte) 메모리의 공간을 찾아서 만드는데 배열의 길이를 변경하게 되면 그 공간에 변경된 배열의 길이만큼의 메모리 공간이 있는지 보장할 수 없다. 부족하면? : 배열의 길이를 크게 새로 만들고 원래 배열을 복사한다. ArrayIndexOutOfBoundsException → 배열의 index가 유효한 범위를 벗어났다는 에러 인덱스를 이용하여 특정 원소를 다룬다.]]></summary></entry><entry><title type="html">IntelliJ에서 Java 프로젝트 만들기</title><link href="http://localhost:4000/etc/intelliJ/" rel="alternate" type="text/html" title="IntelliJ에서 Java 프로젝트 만들기" /><published>2022-03-11T00:00:00+09:00</published><updated>2022-03-11T00:00:00+09:00</updated><id>http://localhost:4000/etc/intelliJ</id><content type="html" xml:base="http://localhost:4000/etc/intelliJ/"><![CDATA[<h2 id="새-프로젝트-생성">새 프로젝트 생성</h2>
<blockquote>
  <p>기존에 생성되어 있는 프로젝트를 불러오려면 Open 선택 후 파일 선택!</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/73566453/157888788-0beb19a5-77ce-43ec-bb77-a05635ed4125.png" alt="image" /></p>

<h2 id="java-선택--jdk-버전-확인">JAVA 선택 → JDK 버전 확인!</h2>
<p><img src="https://user-images.githubusercontent.com/73566453/157889077-76686410-4690-4c13-a99d-230c879ef6f3.png" alt="image" /></p>

<h2 id="next-선택">Next 선택</h2>
<p><img src="https://user-images.githubusercontent.com/73566453/157891326-4e41df0e-9d91-4b28-8e0a-649b7575a3d6.png" alt="image" /></p>

<h2 id="경로-선택">경로 선택!</h2>
<ul>
  <li>폴더를 새로 만들 거면 폴더를 새로 만들고 새로 만든 폴더를 지정해 주면 된다.</li>
  <li>경로선택 후 Finish 선택
<img src="https://user-images.githubusercontent.com/73566453/157907413-0a3ce011-c5df-4fe9-a9c2-d2ec2935e2d9.png" alt="image" /></li>
</ul>

<h2 id="완성">완성!</h2>
<p><img src="https://user-images.githubusercontent.com/73566453/157891469-d5a2d9ff-fe56-4c15-8a8f-b4ea3cf79e0f.png" alt="image" /></p>

<h2 id="패키지-만들기">패키지 만들기</h2>
<blockquote>
  <p>src → New → Package</p>
</blockquote>

<p><img width="1512" alt="image" src="https://user-images.githubusercontent.com/73566453/157893553-df47fb9e-eaee-4e89-a0d6-67f19133c1ec.png" /></p>

<h2 id="클래스-만들기">클래스 만들기</h2>
<blockquote>
  <p>src → New → Java Class</p>
</blockquote>

<p><img width="1512" alt="image" src="https://user-images.githubusercontent.com/73566453/157892386-17d9158b-18b1-4587-b232-cef656228f3a.png" /></p>]]></content><author><name>민경</name></author><category term="ETC" /><category term="IntelliJ" /><summary type="html"><![CDATA[새 프로젝트 생성 기존에 생성되어 있는 프로젝트를 불러오려면 Open 선택 후 파일 선택!]]></summary></entry><entry><title type="html">연산자</title><link href="http://localhost:4000/java/2operator/" rel="alternate" type="text/html" title="연산자" /><published>2022-03-10T00:00:00+09:00</published><updated>2022-03-10T00:00:00+09:00</updated><id>http://localhost:4000/java/2operator</id><content type="html" xml:base="http://localhost:4000/java/2operator/"><![CDATA[<h2 id="연산자">연산자</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">기호</th>
      <th style="text-align: center">연산자</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">=</td>
      <td style="text-align: center">대입 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">+</td>
      <td style="text-align: center">덧셈 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">-</td>
      <td style="text-align: center">뺄셈 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">곱셈 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">/</td>
      <td style="text-align: center">나눗셈 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">%</td>
      <td style="text-align: center">나머지 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">!</td>
      <td style="text-align: center">부정 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">==</td>
      <td style="text-align: center">같다</td>
    </tr>
    <tr>
      <td style="text-align: center">!=</td>
      <td style="text-align: center">같지 않다</td>
    </tr>
    <tr>
      <td style="text-align: center">&amp;&amp;</td>
      <td style="text-align: center">교집합 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">||</td>
      <td style="text-align: center">합집합 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">++</td>
      <td style="text-align: center">증가 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">–</td>
      <td style="text-align: center">감소 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">&amp;</td>
      <td style="text-align: center">비트 교집합 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">|</td>
      <td style="text-align: center">비트 합집합 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">^</td>
      <td style="text-align: center">비트 차집합 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">~</td>
      <td style="text-align: center">비트 부정 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">«</td>
      <td style="text-align: center">왼쪽 쉬프트 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">»</td>
      <td style="text-align: center">오른쪽 쉬프트 연산자</td>
    </tr>
    <tr>
      <td style="text-align: center">3항 연산자</td>
      <td style="text-align: center">(조건)?true:false</td>
    </tr>
  </tbody>
</table>

<h2 id="나눗셈-연산자">나눗셈 연산자</h2>
<ul>
  <li>10 / 3 → 3</li>
  <li>정수 / 정수 → 정수</li>
  <li>10.0 / 3.0 → 3.333…</li>
  <li>실수 / 실수 → 실수</li>
  <li>10 / 3.0 → 묵시적인 형변화</li>
  <li>정수 / 실수 → 예전에는 오류였지만 형변환으로 인해 계산이 가능해졌다.</li>
</ul>

<blockquote>
  <p>묵시적인 형변환은 자료형을 일치시킬 때 손실되는 방법은 사용하지 않는다.
정수 / 실수 → 실수 / 실수</p>
</blockquote>

<h2 id="비트--쉬프트-연산자">비트 &amp; 쉬프트 연산자</h2>

<p><img src="https://user-images.githubusercontent.com/73566453/157651875-4c064218-852d-40c9-9142-671c015d7150.png" alt="image" /></p>]]></content><author><name>민경</name></author><category term="JAVA" /><category term="연산자" /><summary type="html"><![CDATA[연산자]]></summary></entry><entry><title type="html">Java프로그래밍 [1]</title><link href="http://localhost:4000/java/uni_java1/" rel="alternate" type="text/html" title="Java프로그래밍 [1]" /><published>2022-03-10T00:00:00+09:00</published><updated>2022-03-10T00:00:00+09:00</updated><id>http://localhost:4000/java/uni_java1</id><content type="html" xml:base="http://localhost:4000/java/uni_java1/"><![CDATA[<h2 id="자바-언어의-역사">자바 언어의 역사</h2>
<ul>
  <li>Sun Microsystems의 제임스 고슬링</li>
  <li>1990년 그린 프로젝트(소형 전자제품에 들어가는 소프트웨어)와 Oak 언어에서 시작</li>
  <li>1995년 Java와 HotJava(자바 언어로 구현한 웹 브라우저) 발표함</li>
  <li>1996년 1월 공식적으로 JDK1.0을 발표</li>
</ul>

<h2 id="java-언어의-특징">Java 언어의 특징</h2>
<ul>
  <li>C와 C++ 언어에서 발전된 언어</li>
  <li>플랫폼에 독립적</li>
  <li>객체지향언어</li>
  <li>웹이나 네트워크 프로그래밍에 용이하다.</li>
  <li>예외 처리 기능을 제공한다.</li>
  <li>멀티 스레딩을 지원한다.</li>
  <li>WORA(Write Once Run Anywhere) : 한번 작성한 코드는 어떠한 환경에서도 실행이 가능하게 한다.</li>
</ul>

<h2 id="java-프로그램의-실행">Java 프로그램의 실행</h2>
<blockquote>
  <p>HelloWorld.java → <code class="language-plaintext highlighter-rouge">compiler</code> → HelloWorld.class → <code class="language-plaintext highlighter-rouge">JVM</code> → HelloWorld 실행</p>
</blockquote>

<ul>
  <li>Java 소스 프로그램의 확장자는 <code class="language-plaintext highlighter-rouge">.java</code>이다.</li>
  <li>바이트 코드
    <ul>
      <li>Java 소스를 컴파일한 결과물의 확장자는 <code class="language-plaintext highlighter-rouge">.class</code>이다.</li>
      <li>컴파일된 자바코드라고도 한다.</li>
    </ul>
  </li>
</ul>

<h3 id="애플리케이션">애플리케이션</h3>
<ul>
  <li>Java 프로그램을 실행하려면 <code class="language-plaintext highlighter-rouge">main()</code> 함수가 반드시 필요하다.</li>
</ul>

<h3 id="애플릿">애플릿</h3>
<ul>
  <li>HTML 웹 페이지에 포함되어 웹 브라우저를 통해 실행</li>
</ul>

<p><br /></p>

<h2 id="플랫폼-platform">플랫폼 (platform)</h2>
<ul>
  <li>프로그램의 실행을 위한 <span style="color:red">하드웨어</span>와 <span style="color:red">소프트웨어</span> 환경을 말한다.</li>
</ul>

<h2 id="java-플랫폼">JAVA 플랫폼</h2>
<ul>
  <li>Java 프로그램의 <u>개발과 실행</u>을 위한 환경(소프트웨어환경)이다.</li>
  <li>운영체제에 맞는 Java 플랫폼을 설치해야 한다.</li>
</ul>

<h3 id="c프로그램">C프로그램</h3>
<blockquote>
  <p>컴퓨터 시스템(하드웨어) → 운영체제(windows, unix, linux 등) → C프로그램</p>
</blockquote>

<h3 id="java프로그램">JAVA프로그램</h3>
<blockquote>
  <p>컴퓨터 시스템(하드웨어) → 운영체제(windows, unix, linux 등) → <span style="color:red">Java 플랫폼</span> → Java 프로그램</p>
</blockquote>

<p>C프로그램이나 다른 언어 프로그램은 운영체제만 거치고 하드웨어로 전달이 되는데 <strong>Java애플리케이션</strong>은 중간에 플랫폼(JVM)을 한 번 더 거치게 되고, 하드웨어에 맞게 완전히 컴파일 된 상태가 아니고 실행 시에 해석이 된다. (인터프리터)</p>

<p><br /></p>

<h2 id="컴파일러">컴파일러</h2>
<ul>
  <li>컴파일러는 소스코드에서 기계어로 번역 시 특정 CPU에 맞게 번역이 된다.
    <ul>
      <li>이는 한 번 실행을 하고 다시 실행 시 바로 실행이 되기 때문에 속도가 빠르다는 장점이 있지만 컴파일 과정을 거치면 다른 OS에서 해당 프로그램을 실행시키기 어려운 단점도 있다.</li>
    </ul>
  </li>
  <li>자바에서는 배포할 때 컴파일러를 사용한다.</li>
</ul>

<h2 id="인터프리터">인터프리터</h2>
<ul>
  <li>통역처럼 한 줄 한 줄 번역하여 코드를 바로 실행하는 것</li>
  <li>인터프리터는 한 줄씩 실행하는 게 아니라 함수 단위로 실행하는 실행기이다.</li>
  <li>함수단위로 번역할 때 에러가 날 때까지 실행한다.</li>
</ul>

<p><br /></p>

<h2 id="java-플랫폼의-구성">Java 플랫폼의 구성</h2>
<ul>
  <li>JVM
    <ul>
      <li>Java <span style="color:Red"><strong>프로그램의 실행 환경</strong></span>을 제공하는 가상 기계</li>
      <li>Java 프로그램의 구동 엔진</li>
      <li>실행에 필요한 사항을 관리한다.</li>
      <li>메모리 정리를 자동으로 수행한다.
        <ul>
          <li>가비지컬렉터 (Garbage Collector)
            <ul>
              <li>new 연산자를 이용하여 메모리를 할당받아서 사용하고 더이상 필요가 없어지면 가비지컬렉터가 자동으로 메로리를 관리하여 삭제해준다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Java API
    <ul>
      <li>Application Programming Interface
        <ul>
          <li>응용 프로그램에서 사용할 수 있도록 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스</li>
        </ul>
      </li>
      <li>프로그램의 개발에 필요한 클래스 단위의 구성 <span style="color:red"><strong>라이브러리</strong></span></li>
      <li>관련이 있는 패키지들이 계층 구조로 묶여있다.</li>
    </ul>
  </li>
</ul>

<h2 id="출력">출력</h2>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">System.out</code><br />
표준 출력을 담당하는 객체이다. 콘솔창에 출력</p>
</blockquote>

<h2 id="실행">실행</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">프로그램 작성</th>
      <th style="text-align: center">컴파일 명령</th>
      <th style="text-align: center">실행 명령</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Hello.java로 저장</td>
      <td style="text-align: center">javac Hello.java</td>
      <td style="text-align: center">java Hello</td>
    </tr>
  </tbody>
</table>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">javac</span> <span class="nc">Hello</span><span class="o">.</span><span class="na">java</span> <span class="c1">// Hello.class가 만들어진다.</span>
<span class="o">&gt;</span> <span class="n">java</span> <span class="nc">Hello</span> <span class="c1">// Hello 클래스에서 main() 메서드가 실행된다.</span>
</code></pre></div></div>
<p><img width="986" alt="image" src="https://user-images.githubusercontent.com/73566453/157903081-cbc19ae6-65da-4069-9980-715ba97017c8.png" /></p>

<p align="center"><img width="800" height="500" alt="image" src="https://user-images.githubusercontent.com/73566453/157908997-daeac232-6c2b-4e38-a474-5928d64f42bc.png" /></p>

<h2 id="추상화">추상화</h2>
<ul>
  <li>구체적인 모든 사실이 아니라 전형적이고 필요한 부분만을 발췌하여 사물을 이해하고 표현하는 것</li>
  <li>기존 클래스의 공통적인 부분을 뽑아서 부모 클래스로 만드는 것이다.</li>
</ul>

<h3 id="추상화의-목적">추상화의 목적</h3>
<ul>
  <li>집중화</li>
  <li>재사용</li>
</ul>

<h2 id="클래스">클래스</h2>
<ul>
  <li>객체를 만들기 위한 설계도 또는 틀을 말한다.</li>
  <li>공통적인 특징을 가지는 객체들을 추상화하기 위한 수단</li>
  <li>캡슐화 때문에 클래스 외부에는 어떤 필드나 메소드를 둘 수 없다.
    <blockquote>
      <p>객체는 특정 클래스의 인스턴스이다.</p>
    </blockquote>
  </li>
  <li>객체는 필드(속성)와 메소드(기능)로 구성되어 있다.</li>
</ul>

<h2 id="java-프로그램">Java 프로그램</h2>
<ul>
  <li>클래스가 프로그램 구성의 기본 단위</li>
  <li>데이터와 알고리즘이 클래스에 캡슐화되어 있다.</li>
</ul>]]></content><author><name>민경</name></author><category term="JAVA" /><category term="Java프로그래밍" /><summary type="html"><![CDATA[자바 언어의 역사 Sun Microsystems의 제임스 고슬링 1990년 그린 프로젝트(소형 전자제품에 들어가는 소프트웨어)와 Oak 언어에서 시작 1995년 Java와 HotJava(자바 언어로 구현한 웹 브라우저) 발표함 1996년 1월 공식적으로 JDK1.0을 발표]]></summary></entry><entry><title type="html">String</title><link href="http://localhost:4000/java/3string/" rel="alternate" type="text/html" title="String" /><published>2022-03-10T00:00:00+09:00</published><updated>2022-03-10T00:00:00+09:00</updated><id>http://localhost:4000/java/3string</id><content type="html" xml:base="http://localhost:4000/java/3string/"><![CDATA[<h2 id="️-문자열-비교">✔️ 문자열 비교</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">==</code>
    <ul>
      <li>객체의 <span style="color:blue">주소</span>를 비교한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">equals()</code>
    <ul>
      <li>객체의 <span style="color:blue">내용</span>을 비교한다.</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"JAVA"</span><span class="o">);</span> <span class="c1">// 생성자 사용</span>
<span class="nc">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"JAVA"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">str3</span> <span class="o">=</span> <span class="s">"JAVA"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">str4</span> <span class="o">=</span> <span class="s">"JAVA"</span><span class="o">;</span>
</code></pre></div></div>

<p>이렇게 4개의 문자열이 있다고 했을 때</p>

<p><code class="language-plaintext highlighter-rouge">str1 == str2</code><br />
str1과 str2의 <strong>객체 주소</strong>를 비교하게 된다.<br />
str1과 str2는 서로 다른 객체이므로 결과는 <strong>false</strong>가 된다.</p>

<p><code class="language-plaintext highlighter-rouge">str1.equals(str2)</code><br />
str1과 str2의 <strong>내용을 비교</strong>하게 된다.
str1의 내용과 str2의 내용은 JAVA로 동일하기 때문에 결과는 <strong>true</strong>가 된다.</p>

<p><code class="language-plaintext highlighter-rouge">str3 == str4</code><br />
str3과 str4의 <strong>객체 주소</strong>를 비교하게 된다.<br />
str3가 생성이 되면서 컴파일러는 자동으로 객체화 한다.<br />
후에 str4가 생성 되면서 컴파일러는 이미 존재하는 str3를 사용하기 때문에 str3와 str4는 같은 주소이다.<br />
따라서 결과값은 <strong>true</strong>이다.</p>

<p><code class="language-plaintext highlighter-rouge">str3.equals(str4)</code><br />
str3과 str4의 <strong>내용을 비교</strong>하게 된다.<br />
str3의 내용과 str4의 내용은 JAVA로 동일하기 때문에 결과는 <strong>true</strong>가 된다.</p>

<p><code class="language-plaintext highlighter-rouge">str1 == str3</code><br />
str1과 str3의 <strong>객체 주소</strong>를 비교하게 된다.<br />
서로 다른 객체이므로 결과는 <strong>false</strong>이다.</p>

<p><code class="language-plaintext highlighter-rouge">str1.equals(str3)</code><br />
str1과 str3의 <strong>내용을 비교</strong>하게 된다.<br />
내용은 동일하므로 <strong>true</strong>이다.</p>

<h2 id="️-문자열-자르기">✔️ 문자열 자르기</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">subString()</code></li>
</ul>

<h2 id="️-문자열-합치기">✔️ 문자열 합치기</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">concat()</code></li>
</ul>

<h2 id="️-문자열-찾기">✔️ 문자열 찾기</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">indexOf()</code></li>
</ul>]]></content><author><name>민경</name></author><category term="JAVA" /><category term="string" /><summary type="html"><![CDATA[✔️ 문자열 비교 == 객체의 주소를 비교한다. equals() 객체의 내용을 비교한다.]]></summary></entry><entry><title type="html">포맷 문자열과 진법</title><link href="http://localhost:4000/java/1format/" rel="alternate" type="text/html" title="포맷 문자열과 진법" /><published>2022-03-10T00:00:00+09:00</published><updated>2022-03-10T00:00:00+09:00</updated><id>http://localhost:4000/java/1format</id><content type="html" xml:base="http://localhost:4000/java/1format/"><![CDATA[<h2 id="포맷-문자열과-형식-지정자">포맷 문자열과 형식 지정자</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">코드</th>
      <th style="text-align: center">데이터 형식</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">d</td>
      <td style="text-align: center">정수 (10진수)</td>
    </tr>
    <tr>
      <td style="text-align: center">x</td>
      <td style="text-align: center">정수 (16진수)</td>
    </tr>
    <tr>
      <td style="text-align: center">o</td>
      <td style="text-align: center">정수 (8진수)</td>
    </tr>
    <tr>
      <td style="text-align: center">f</td>
      <td style="text-align: center">실수</td>
    </tr>
    <tr>
      <td style="text-align: center">c</td>
      <td style="text-align: center">문자</td>
    </tr>
    <tr>
      <td style="text-align: center">s</td>
      <td style="text-align: center">문자열</td>
    </tr>
  </tbody>
</table>

<h2 id="값의-종류와-표현방법">값의 종류와 표현방법</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">진법</th>
      <th style="text-align: center">표현 예</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">2진법</td>
      <td style="text-align: center">0b32</td>
      <td style="text-align: center">숫자 앞에 0과 b를 사용</td>
    </tr>
    <tr>
      <td style="text-align: center">8진법</td>
      <td style="text-align: center">032</td>
      <td style="text-align: center">숫자 앞에 0을 사용</td>
    </tr>
    <tr>
      <td style="text-align: center">10진법</td>
      <td style="text-align: center">32</td>
      <td style="text-align: center">숫자 앞에 아무것도 사용하지 않음</td>
    </tr>
    <tr>
      <td style="text-align: center">16진법</td>
      <td style="text-align: center">0x1A</td>
      <td style="text-align: center">숫자 앞에 0과 x를 사용</td>
    </tr>
  </tbody>
</table>]]></content><author><name>민경</name></author><category term="JAVA" /><category term="포맷문자열" /><category term="진법" /><summary type="html"><![CDATA[포맷 문자열과 형식 지정자]]></summary></entry><entry><title type="html">javac와 java의 차이</title><link href="http://localhost:4000/java/1javac/" rel="alternate" type="text/html" title="javac와 java의 차이" /><published>2022-03-09T00:00:00+09:00</published><updated>2022-03-09T00:00:00+09:00</updated><id>http://localhost:4000/java/1javac</id><content type="html" xml:base="http://localhost:4000/java/1javac/"><![CDATA[<h2 id="javac">javac</h2>
<p><code class="language-plaintext highlighter-rouge">.java</code> 파일을 <code class="language-plaintext highlighter-rouge">.class</code> 파일로 변환시켜 주는 컴파일러를 의미한다.<br />
그래서 <code class="language-plaintext highlighter-rouge">hello.java</code> 파일이 있다는 가정하에 터미널에 <code class="language-plaintext highlighter-rouge">javac hello.java</code> 명령어를 입력하면
<code class="language-plaintext highlighter-rouge">hello.java</code> 라는 파일이 생성된다.</p>

<h2 id="java">java</h2>
<p><code class="language-plaintext highlighter-rouge">javac</code>로 컴파일된 <strong>.class</strong> 파일을 실행하는 명령어다.<br />
<code class="language-plaintext highlighter-rouge">java hello.java</code> 명령어를 입력하면 hello.java 파일 안에 내용이 실행된다.</p>]]></content><author><name>민경</name></author><category term="JAVA" /><category term="JAVA" /><summary type="html"><![CDATA[javac .java 파일을 .class 파일로 변환시켜 주는 컴파일러를 의미한다. 그래서 hello.java 파일이 있다는 가정하에 터미널에 javac hello.java 명령어를 입력하면 hello.java 라는 파일이 생성된다.]]></summary></entry></feed>