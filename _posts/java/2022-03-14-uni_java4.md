---
title:  "Java프로그래밍 [4]" 

categories:
  - JAVA
tags:
  - Java프로그래밍

date: 2022-03-14

published : true

toc: true

---


## 생성자 (Constructor)
- 객체가 생성될 때 자동으로 실행되는 메서드
  - 객체의 필드 값을 초기화하거나 메모리 할당 등의 작업이다.
- `Circle c = new Circle(5);`
  1. new 연산자를 이용하여 Circle 객체를 생성하고
  2. 생성자가 호출되면서 (데이터 필드 초기화)
  3. 객체의 참조값을 변수에 대입

### 정의 방법
- <span style="color:blue">생성자 이름은 클래스 이름과 같다.</span>
- **생성자 오버로딩**
  - 여러 생성자를 정의할 수 있다.
    - <span style="color:red">매개변수의 개수와 자료형</span>으로 구분한다.
- **생성자는 new를 통해 객체를 생성할 때 한 번만 호출된다.**
- <span style="color:blue">생성자에 반환형을 선언하지 않는다.</span>
    - **리턴 값이 없다고 해서 void를 리턴 타입으로 지정하면 안 된다.**
    - return문은 메소드의 실행을 끝내고 호출한 곳으로 돌아가라는 명령이므로 생성자의 실행을 끝내고자 하면 생성자 코드 내 어디서든 return문을 사용할 수 있다.
- **생성자의 목적은 객체가 생성될 때 필요한 초기 작업을 위함이다.**
    - 객체가 생성될 때 필드 초기화, 필요한 메모리 확보, 파일 열기, 네트워크 연결 등 객체가 활동하기 전에 필요한 초기 준비를 하는데 이용된다.


## 기본 생성자
- 매개변수와 실행 코드가 없어 아무 일도 하지 않고 단순 리턴하는 생성자
<details>
<summary>기본 생성자가 자동으로 생성되는 경우</summary>
<div markdown="1">  
- 모든 객체는 생성될 때 반드시 생성자가 실행되기 때문에 생성자가 하나도 없는 경우, 컴파일러는 기본 생성자를 자동으로 생성한다.
</div>
</details>
<details>
<summary>기본 생성자가 자동으로 생성되지 않는 경우</summary>
<div markdown="1">  
- 생성자가 하나라도 존재하는 클래스에는 컴파일러가 기본 생성자를 삽입해 주지 않는다.
</div>
</details>


## 매개변수가 있는 생성자
- 인스턴스를 생성하는 동시에 원하는 값으로 초기화할 수 있다.

```java
public class Circle {
  int height;
  int width;
  int radi;

  public Circle() { // 기본 생성자
    height = 2;
    width = 3;
    radi = 4;
  }

  public Circle(int a, int b, int c) { // 생성자 오버로딩
    this.height = a;
    this.width = b;
    this.radi = c;
  }
}
```

## 클래스의 사용
- 상속
- 객체 생성

## 객체의 사용
- `객체.변수` 를 사용하여 인스턴스 변수를 읽거나 쓰기
- `객체.메서드` 를 이용하여 호출

## static
- 클래스를 설계할 때,  멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
- 클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.
  - staic이 붙은 변수는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성된다.
- 클래스 메서드(static메서드)는 인스턴스 변수를 사용할 수 없다.
  - 인스턴스 변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스메서드는 인스턴스 생성 없이 호출 가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다. 반면에 인스턴스 변수나 인스턴스메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다.
- 메서드 내에서 인스턴스 변수를 사용하지 않는다면 static을 붙이는 것을 고려한다.

## 인스턴스 변수와 static 변수의 차이
### 인스턴스 변수
- 멤버는 객체마다 별도로 존재한다.
- 객체가 생성 시에 멤버도 생성된다.
- 멤버는 객체가 생성된 이후에 사용이 가능하다.
- 객체가 사라지면 멤버도 사라진다.
- 멤버는 객체 내에 각각 공간 유지를 하며 공유되지 않는다.

### static 변수
- 멤버는 클래스당 하나만 생성이 되고 객체 내부가 아닌 별도의 공간에 생성된다.
- 클래스 로딩 시에 멤버가 생성되고 객체가 생성되기 전에 이미 생성된다.
- 객체가 생기기 전에 사용 가능하다. (**<span style="color:red">클래스이름.필드</span>** or <span style="color:red">객체변수.필드</span>)
- 객체가 사라져도 멤버는 사라지지 않고 프로그램이 종료될 때 사라진다.
- 동일한 클래스의 모든 객체들에 의해 공유된다.

## final 필드
- 상수 데이터를 선언한다.
- 선언할 때 초기값을 지정해야 한다.

## final 메서드
- 자식 클래스로 상속은 가능하지만 재정의는 할 수 없다.

## 오버로드과 오버라이딩 차이

| |메소드 오버로딩|메소드 오버라이딩|
|:---:|:---|:---|
|선언|매개변수가 다른 생성자를 추가|상속받은 메서드의 내용 변경|
|관계|동일한 클래스 내 또는 상속관계|상속관계|
|목적|✔️ 이름이 같은 여러개의 메서드를 중복 작성하여 사용의 편리성 향상<br>✔️ 다형성 실현|✔️ 부모 클래스에 구현된 메서드를 무시하고 자식 클래스에서 새로운 기능의 메서드를 재정의<br>✔️ 다형성 실현|
|조건|1. 메서드 이름 동일<br>2. 매개변수 타입이나 개수 달라야 함<br>3. 반환 타입이나 접근 지정자는 관계 없음|1. 메서드 이름, 매개변수 타입, 개수, 리턴 타입이 모두 동일해야 함<br>2. 접근 제어자는 부모 클래스의 메서드보다 좁은 범위로 변경 불가<br>3. 부모 클래스의 메서드보다 많은 수의 예외 선언 불가
|바인딩|정적 바인딩<br>호출될 메소드는 컴파일 시에 결정|동적 바인딩<br>실행 시간에 오버라이딩된 메서드를 찾아 호출

## 상속
- `extends` 사용
- 단일 상속
- 메서드 재정의 (오버라이딩) 가능

### has a 합성
- 기존 클래스를 새로운 클래스에서 필드의 자료형으로 사용
- `Composition has a` 관계
  - 객체 생성을 생성자 내부에서 만듦
- `Association has a` 관계
  - 생성된 객체를 넘겨받음
    - 오버로드 생성자로 객체를 넘겨받기
    - Setter로 객체 넘겨받기

### is a 상속
- 기존 클래스를 사용하여 새로운 클래스 정의
- 장점 : 코드의 중복 작성을 줄임

## this와 super

<img width="1178" alt="image" src="https://user-images.githubusercontent.com/73566453/158345682-5eaec350-399a-49ca-b91e-2df7a7aed7e6.png">